{"version":3,"sources":["FileImport.js","notation.js","Pattern.js","utilities.js","track.js","h2.js","formatSettings.js","instrumentConfig.js","instrumentation.js","App.js","serviceWorker.js","index.js"],"names":["FileImport","props","onChange","bind","e","fileObject","target","files","reader","FileReader","onload","loadEvent","onImport","file","content","result","readAsText","type","this","React","Component","notation","config","patternResolution","beatResolution","Error","lineResolution","str","chunkSize","match","RegExp","patternSize","validateConfig","lineLength","Math","min","beatCount","ceil","numberMarkerArray","Array","from","numberRestMark","beat","toString","join","line","beatChunkSize","lineWithBeats","showBeatMark","chunkString","beatMark","lineMark","instrument","trackDict","formatConfig","Object","keys","propName","DEFAULT_FORMAT_CONFIG","hasOwnProperty","assign","instrumentTracks","values","length","resolution","notationLength","patternArray","fill","restMark","charIndex","entries","trackID","trackSymbol","trackInstance","rep","patternString","lineArray","formattedLineArray","showBeatNumbers","push","formatLineWithMarkers","createNumberMarker","i","FORMAT_CONFIG_STRINGS","FORMAT_CONFIG_BOOLS","Pattern","state","instruments","configOverride","page","instrumentName","notationString","fromInstrumentAndTrack","tracks","split","x","className","style","whiteSpace","formatText","map","index","key","calculateResolution","positions","size","implicitPositions","concat","b","allNotesPass","track","reduce","a","count","other","_sumOverlapsOfArrays","hcf","y","max","findHCF","formatResolution","totalLength","points","toPoints","representPoints","arrayIndex","s","p","resolutionToUse","parseHydrogenJs","instrumentElements","song","instrumentList","instrumentArray","element","parseInt","id","name","parseFloat","volume","isMuted","gain","patternElements","patternList","pattern","noteElements","noteList","note","notes","noteElement","position","filter","n","patternsWithTracks","calculatePatternResolution","relevantNotes","relevantHits","fromPositions","xmlString","parser","xml2js","Parser","parseStringPromise","then","parseHydrogenPromise","useStyles","makeStyles","theme","formControl","margin","spacing","minWidth","selectEmpty","marginTop","camelToReadable","spacedString","replace","toUpperCase","slice","FormatSettings","classes","stateToItem","value","handleOptionChange","event","updatedState","settings","handleCheckedChange","checked","FormGroup","root","op","options","idString","FormControl","variant","InputLabel","Select","labelId","MenuItem","createOptionMenu","prev","curr","Divider","FormControlLabel","control","Switch","label","DefaultSettings","display","DEFAULT_INSTRUMENT_SYMBOLS","normalizeInstrumentsForFiguring","inst","nInst","toLowerCase","manageAccentOrGhost","accentSymbol","ghostSymbol","outputInstruments","t0","t1","zeroLouder","mapping","activeInstruments","patterns","nonTrivialInstruments","Set","instrumentID","empty","add","figureInstruments","instrumentsRaw","symbolConfig","output","worthwhileInstruments","relevantTracks","has","includes","trackIsClick","t","collated","candidate","floor","clickTrack","hitTrack","lastTrack","figureClickyInstruments","djembeTracks","slapArray","toneArray","bassArray","djembeMapping","figureDjembes","figureSnares","figureShakers","instrumentUsed","createMuiTheme","palette","primary","main","secondary","App","selectedPattern","loadedFile","settingsOpen","formatSettings","h2","h","assessedInstruments","setState","patternIndex","Fragment","optionalAlert","Alert","severity","handleFileImport","patternContent","renderPattern","patternToRender","width","flexGrow","IconButton","color","aria-label","edge","onClick","clsx","hide","Drawer","drawer","anchor","open","paper","drawerPaper","drawerHeader","patternsReady","mainContent","renderMainContent","ThemeProvider","CssBaseline","drawerContainer","List","ListItem","button","selectPattern","ListItemText","Boolean","window","location","hostname","ReactDOM","render","StrictMode","document","getElementById","navigator","serviceWorker","ready","registration","unregister","catch","error","console","message"],"mappings":"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","file":"static/js/main.1a32a3c7.chunk.js","sourcesContent":["// FileUpload.react.js\n\n// inspired by https://gist.github.com/AshikNesin/e44b1950f6a24cfcd85330ffc1713513\n// and https://stackoverflow.com/questions/55830414/how-to-read-text-file-in-react\n\nimport React from 'react'\n\nclass FileImport extends React.Component {\n\n  constructor(props) {\n    super(props);\n    this.onChange = this.onChange.bind(this)\n  }\n\n  onChange(e) {\n    const fileObject = e.target.files[0]\n    const reader = new FileReader()\n    reader.onload = loadEvent => {\n      if( this.props.onImport )\n      {\n        this.props.onImport(\n          { file: fileObject, content : loadEvent.target.result}\n        );\n      }\n    }\n    reader.readAsText(fileObject);\n  }\n\n  render() {\n    return (\n      <input type=\"file\" onChange={this.onChange} />\n   )\n  }\n}\n\nexport default FileImport;\n","\nclass notation\n{\n\n  static DEFAULT_FORMAT_CONFIG = {\n    \"restMark\" : \"-\",\n    \"beatMark\" : \"|\",\n    \"lineMark\" : \"|\",\n    \"numberRestMark\" : \"-\",\n    \"beatResolution\" : 48,\n    \"showBeatMark\" : true,\n    \"showBeatNumbers\" : true,\n    // lineResolution needs to be determined on a per-pattern-basis \n    // so let's just not cut the lines apart, by default\n    \"lineResolution\" : 48 * 16\n  };\n\n  static FORMAT_CONFIG_STRINGS = [\n    [\"restMark\",[\"-\", \".\", \" \"]],\n    [\"numberRestMark\",[\"-\", \".\", \" \"]],\n    [\"beatResolution\",[\"24\", \"48\", \"96\"]]\n  ];\n\n  static FORMAT_CONFIG_BOOLS = [\n    \"showBeatMark\",\n    \"showBeatNumbers\"\n  ];\n\n  static validateConfig(config, patternResolution) {\n    if( patternResolution != null && ( config.beatResolution % patternResolution ) !== 0 )\n    {\n      throw new Error(\"patternResolution doesn't divide beatResolution\");\n    }\n    if( config.lineResolution <= 0 )\n    {\n      throw new Error(\"config.lineResolution doesn't divide patternResolution\");\n    }\n  }\n\n  static chunkString(str, chunkSize) {\n    if( chunkSize <= 0 )\n    {\n      throw new Error(\"chunkSize must be > 0\")\n    }\n    return str.match(new RegExp('.{1,' + chunkSize + '}', 'g'));\n  }\n\n  static createNumberMarker(config, patternResolution, patternSize)\n  {\n    if( patternResolution <= 0 || patternSize <= 0 )\n    {\n      throw new Error(\"(patternResolution, patternSize) arguments <= 0\");\n    }\n    if( ( patternSize % patternResolution) !== 0 )\n    {\n      throw new Error(\"patternSize,doesn't divide patternResolution\");\n    }\n\n    notation.validateConfig(config, patternResolution);\n\n    // note, this assumes that each line makes this match evenly\n    // but ... there's nothing you can do in that case really unless you take an array of lineResolutions\n    const lineLength = Math.min(patternSize, config.lineResolution);\n    let beatCount = Math.ceil(lineLength / config.beatResolution);\n\n    let numberMarkerArray = Array.from( Array(lineLength / patternResolution), e => config.numberRestMark );\n\n    for( let beat = 0; beat < beatCount; beat++ )\n    {\n      numberMarkerArray[ beat * ( config.beatResolution / patternResolution ) ] = ( (beat+1) % 10 ).toString();\n    }\n    return numberMarkerArray.join(\"\");\n  }\n\n  static formatLineWithMarkers(config, line, patternResolution)\n  {\n    notation.validateConfig(config);\n\n    const beatChunkSize = config.beatResolution / patternResolution;\n\n\n    const lineWithBeats = config.showBeatMark ? notation.chunkString(line, beatChunkSize).join(config.beatMark) : line;\n    // note: we choose to always show the lineMarker even if it doesn't match the line resolution\n    return config.lineMark + lineWithBeats + config.lineMark;\n  }\n\n  static fromInstrumentAndTrack(\n    instrument,\n    trackDict,\n    formatConfig = {}\n  )\n  {\n    for( const propName of Object.keys(formatConfig))\n    {\n      if(!notation.DEFAULT_FORMAT_CONFIG.hasOwnProperty(propName))\n      {\n        throw new Error(\"passed unrecognised property \" + propName);\n      }\n    }\n\n    let config = Object.assign( Object.assign({}, notation.DEFAULT_FORMAT_CONFIG), formatConfig );\n\n    let instrumentTracks = Object.values(trackDict);\n    if(instrumentTracks.length === 0)\n    {\n      return \"\";\n    }\n\n    // turn the tracks, into one char string\n\n    const patternSize = instrumentTracks[0].length();\n    const patternResolution = instrumentTracks[0].resolution;\n    const notationLength = instrumentTracks[0].length() / instrumentTracks[0].resolution;\n    // we only format tracks to the correct resolution\n    let patternArray = Array(notationLength).fill(config.restMark);\n    for( let charIndex = 0; charIndex < patternArray.length; ++charIndex)\n    {\n      // todo: handle collisions\n      for( const [trackID, trackSymbol] of Object.entries(instrument) )\n      {\n        const trackInstance = trackDict[trackID];\n        if( trackInstance != null && trackInstance.rep[charIndex] === 1 )\n        {\n          patternArray[charIndex] = trackSymbol;\n        }\n      }\n    }\n    const patternString = patternArray.join(\"\");\n\n    // handle lines and beatMarkers\n    let lineArray = notation.chunkString( patternString, config.lineResolution / patternResolution );\n\n    let formattedLineArray = [];\n    // add numbers on the first line\n    if( config.showBeatNumbers )\n    {\n      formattedLineArray.push( notation.formatLineWithMarkers( \n        config, \n        notation.createNumberMarker(config, patternResolution, patternSize), \n        patternResolution \n      ) );\n    }\n    for( let i = 0; i < lineArray.length; ++i )\n    {\n      formattedLineArray.push( notation.formatLineWithMarkers( config, lineArray[i], patternResolution ));\n    }\n\n    return formattedLineArray.join(\"\\n\");\n  }\n};\n\nexport default notation;","import React from 'react';\nimport notation from \"./notation\"\n\nclass Pattern extends React.Component\n{\n  constructor(props) {\n    super(props);\n    this.state = {\n    };\n  }\n\n  // remove me and relpace with me with something way better\n  // this is taken from the notation formatAsPage code\n  formatText(instruments)\n  {\n    let configOverride = this.props.config;\n    let page = [];\n    for( const [instrumentName, instrument] of instruments )\n    {\n      const notationString = notation.fromInstrumentAndTrack(\n        instrument,\n        this.props.tracks,\n        configOverride\n      );\n      page.push(instrumentName);\n      for( const x of notationString.split(\"\\n\"))\n      {\n        page.push(x);\n      }\n    }\n    return page;\n  }\n\n  render() {\n    return (\n      <div className=\"Pattern\" style={{\"fontFamily\": \"Roboto Mono\", \"textAlign\": \"left\", whiteSpace:\"pre\"}}>\n        { this.formatText(this.props.instruments).map((x,index) => <p key={index.toString()}>{x}</p>) }\n      </div>\n    );\n  }\n}\n\nexport default Pattern;","// utilities.js\n\nfunction calculateResolution(positions, size)\n{\n  // hydrogen treats 48 as a beat\n  const basesToTry = [\n    48, // beat\n    24, // 1/2 beat\n    16, // 1/3 beat\n    12, // 1/4\n    8, // 1/6 \n    6, // 1/8\n    4, // 1/12\n    3, // 1/16\n    2, // 1/24\n    1 // 1/48\n  ];\n\n  // note that, fundamentally the size of the pattern is a \"keypoint\"\n  // that needs to be properly recorded by the resolution\n  const implicitPositions = positions.concat( [size] );\n\n  for( const b of basesToTry )\n  {\n    let allNotesPass = true;\n    for( const p of implicitPositions )\n    {\n      if( (p % b) !== 0 )\n      {\n        allNotesPass = false;\n        break;\n      }\n    }\n    if(allNotesPass)\n    {\n      return b;\n    }\n  }\n  throw new Error(\"Failed to predict base\");\n}\n\nexport { calculateResolution };","import { calculateResolution } from \"./utilities\"\n\n// stolen from https://studymaths.co.uk/topics/findingHCFWithJavaScript.php\nfunction findHCF(x, y) {\n\n   // If the input numbers are less than 1 return an error message.\n   if (x < 1 || y < 1) {\n    throw new Error(\"x<1 || y<1\");\n      // return \"Please enter values greater than zero.\";\n   }\n\n   // Now apply Euclid's algorithm to the two numbers.\n   while (Math.max(x, y) % Math.min(x, y) !== 0) {\n      if (x > y) {\n         x %= y;\n      }\n      else {\n         y %= x;\n      }\n   }\n   \n   // When the while loop finishes the minimum of x and y is the HCF.\n   return Math.min(x, y);\n}\n\nclass track\n{\n  \n  constructor(patternArray, resolution)\n  {\n    if(patternArray.length === 0)\n    {\n      throw new Error(\"patternArray must not be zero length\");\n    }\n    this.rep = patternArray;\n    this.resolution = resolution;\n  }\n\n  length()\n  {\n    return this.rep.length * this.resolution;\n  }\n\n  empty()\n  {\n    return this.rep.reduce( (a,b) => ( a + b ) ) === 0;\n  }\n\n  _sumOverlapsOfArrays(a,b)\n  {\n    let count = 0;\n    for( let i = 0; i < a.length; ++i)\n    {\n      if(a[i] && b[i])\n      {\n        count++;\n      }\n    }\n    return count;\n  }\n\n  countOverlaps(other)\n  {\n    if( this.resolution === other.resolution )\n    {\n      return this._sumOverlapsOfArrays( this.rep, other.rep );\n    }\n    else\n    {\n      const hcf = findHCF(this.resolution, other.resolution);\n      const a = this.formatResolution( hcf );\n      const b = other.formatResolution( hcf );\n      return this._sumOverlapsOfArrays( a.rep, b.rep );\n    }\n  }\n\n  static representPoints(points, resolution, size)\n  {\n    if( size <= 0 )\n    {\n      throw new Error(\"size must be greater than zero\");\n    }\n    if( size < resolution || (size % resolution) !== 0)\n    {\n      throw new Error(\"resolution must be less than size and divide it evenly\");\n    }\n    let s = new Array(size / resolution).fill(0);\n    for( const p of points )\n    {\n      if( (p % resolution) !== 0)\n      {\n        throw new Error(\"Failed to represent point \" + p.toString() + \" at resolution \" + resolution.toString());\n      }\n      if (p >= size)\n      {\n        throw new Error(\"Failed to represent point \" + p.toString() + \" for invalid specified size \" + size.toString());\n      }\n      const arrayIndex = p / resolution;\n      s[arrayIndex] = 1;\n    }\n    return s;\n  }\n\n  format(formatResolution)\n  {\n    // formatResolution must cleanly divide for every hit & the length of the pattern\n\n    const totalLength = (this.resolution * this.rep.length);\n    const points = this.toPoints();\n    const rep = track.representPoints(points, formatResolution, totalLength);\n    if(!rep)\n    {\n      return null;\n    }\n    return new track(\n      rep,\n      formatResolution\n    );\n  }\n\n  toPoints()\n  {\n    let points = [];\n    for( const arrayIndex of Array(this.rep.length).keys() )\n    {\n      const indicator = this.rep[arrayIndex];\n      if(indicator)\n      {\n        points.push( this.resolution * arrayIndex )\n      }\n    }\n    return points;\n  }\n\n  static fromPositions(positions, size, resolution = null)\n  {\n    const resolutionToUse = resolution ?? calculateResolution( positions, size );\n    return new track( \n      track.representPoints(positions, resolutionToUse, size), \n      resolutionToUse\n    );\n  }\n}\n\nexport default track;","// h2.js\n\nimport track from \"./track\"\nimport xml2js from \"xml2js\";\nimport { calculateResolution } from \"./utilities\";\n\n// let's think about the data representation needed\n\nfunction calculatePatternResolution(pattern, size)\n{\n  const positions = Array.from(pattern.notes, note => note.position)\n  return calculateResolution(positions, size);\n}\n\nfunction parseHydrogenJs(result)\n{\n    // fixme:\n    // this parsing often assumes there's >=2 elements\n\n    // this \"zero\" here is presumably an artefact of xml --> json representation\n    const instrumentElements = result.song.instrumentList[0].instrument;\n\n    // instruments\n    // [  { id, name } ]\n    const instrumentArray = Array.from(\n      instrumentElements,\n      function(element){\n        return {\"id\" : parseInt(element.id), \"name\" : element.name, \"volume\" : parseFloat(element.volume), \"muted\" : element.isMuted[0] === \"true\", \"gain\" : parseFloat(element.gain)};\n      }\n    );\n\n    const patternElements = result.song.patternList[0].pattern;\n    // patterns\n    // [  { name, size, notes } ]\n    const patternArray = Array.from(\n      patternElements,\n      function(element){\n        const noteElements = element.noteList[0].note;\n        const patternSize = parseInt(element.size);\n        let notes = [];\n        if( noteElements )\n        {\n          // notes \n          // [ {position, instrument(id}]\n          notes = Array.from(\n            noteElements,\n            function(noteElement){\n              return {\"position\" : parseInt(noteElement.position), \"instrument\" : parseInt(noteElement.instrument)};\n            }\n          );\n\n          // hydrogen permits you to have notes that reach past the pattern size, \n          // they then get revealed when you extend the pattern, \n          // here's an easy point to get rid of them, we don't want them to factor into any calculations\n          notes = notes.filter( n => n.position < patternSize );\n        }\n        return {\n          \"size\" : patternSize, \n          \"name\" : element.name,\n          \"notes\" : notes\n        };\n      }\n    );\n\n    // transform pattern to a managable data\n    const patternsWithTracks = Array.from(\n      patternArray,\n      function(pattern)\n      { \n        const resolution = calculatePatternResolution(pattern, pattern.size);\n        let instrumentTracks = {};\n        for( const instrument of instrumentArray )\n        {\n          const relevantNotes = pattern.notes.filter( \n            note => (note.instrument === instrument.id)\n          );\n          const relevantHits = Array.from(\n            relevantNotes,\n            note => note.position\n          );\n          instrumentTracks[ instrument.id.toString() ] = track.fromPositions( relevantHits, pattern.size, resolution);\n        }\n        pattern.resolution = resolution;\n        pattern.instrumentTracks = instrumentTracks;\n        return pattern;\n      }\n    );\n\n    return {\n      \"instruments\" : instrumentArray,\n      \"patterns\" : patternsWithTracks\n    }\n}\n\nasync function parseHydrogenPromise(xmlString)\n{\n  let parser = new xml2js.Parser();\n\n  return parser.parseStringPromise(xmlString).then(parseHydrogenJs);\n}\n\nexport default { parseHydrogenPromise };","import React from 'react';\nimport { makeStyles } from '@material-ui/core/styles';\nimport InputLabel from '@material-ui/core/InputLabel';\nimport MenuItem from '@material-ui/core/MenuItem';\nimport FormControl from '@material-ui/core/FormControl';\nimport FormGroup from '@material-ui/core/FormGroup';\nimport FormControlLabel from '@material-ui/core/FormControlLabel';\nimport Switch from '@material-ui/core/Switch';\nimport Select from '@material-ui/core/Select';\nimport Divider from \"@material-ui/core/Divider\";\n\nimport notation from \"./notation\";\n\nconst useStyles = makeStyles((theme) => ({\n  formControl: {\n    margin: theme.spacing(1),\n    minWidth: 120,\n  },\n  selectEmpty: {\n    marginTop: theme.spacing(2),\n  },\n}));\n\nfunction camelToReadable(s)\n{\n  const spacedString = s.replace(/([A-Z])/g, ' $1');\n  return spacedString[0].toUpperCase() + spacedString.slice(1);\n}\n\nfunction FormatSettings(props) {\n  const classes = useStyles();\n  // todo: change to multiple useState calls?\n\n  function stateToItem(value)\n  {\n    return value === \" \" ? \"space\" : value;\n  }\n\n  function itemToState(value)\n  {\n    return value === \"space\" ? \" \" : value;\n  }\n\n  const handleOptionChange = (event) => {\n    const updatedState = {...props.settings, [event.target.name]: itemToState(event.target.value)};\n    props.onChange(updatedState);\n  };\n\n  const handleCheckedChange = (event) => {\n    const updatedState = {...props.settings, [event.target.name]: event.target.checked};\n    props.onChange(updatedState);\n  };\n\n  function createOptionMenu(name, options)\n  {\n    const idString = \"form-control-\" + name + \"-id\";\n    return (\n      <FormControl variant=\"filled\" className={classes.formControl} key={idString} id={idString}>\n        <InputLabel id=\"settings-option-{name}\">{name}</InputLabel>\n        <Select\n          labelId={\"settings-option-\" + name + \"-labelID\"}\n          id={\"settings-option-\" + name + \"-id\"}\n          value={stateToItem(props.settings[name])}\n          name={name}\n          onChange={handleOptionChange}\n        >\n          {options.map((op) => <MenuItem key={\"settings-menu-item-\" + name + \"-\" + op} value={stateToItem(op)}>{stateToItem(op)}</MenuItem>)}\n        </Select>\n      </FormControl>\n    );\n  };\n\n  function createBoolControl(name)\n  {\n    return (\n      <FormControlLabel\n        control={<Switch checked={props.settings[name]} onChange={handleCheckedChange} name={name} />}\n        label={camelToReadable(name)}\n        key={\"switch-\"+name}\n      />\n    );\n  };\n\n  return (\n    <FormGroup className={classes.root}>\n      {notation.FORMAT_CONFIG_STRINGS.map( op => createOptionMenu( op[0], op[1] ) ).reduce((prev, curr) => [prev, <Divider/>, curr])}\n      <Divider/>\n      {notation.FORMAT_CONFIG_BOOLS.map( op => createBoolControl( op )).reduce((prev, curr) => [prev, <Divider/>, curr]) }\n    </FormGroup>\n  );\n}\n\nconst DefaultSettings = notation.DEFAULT_FORMAT_CONFIG; \n\n\nexport { FormatSettings, DefaultSettings }\nexport default FormatSettings;","import React from 'react';\nimport { makeStyles } from '@material-ui/core/styles';\nimport FormLabel from '@material-ui/core/FormLabel';\nimport FormControl from '@material-ui/core/FormControl';\nimport FormGroup from '@material-ui/core/FormGroup';\nimport FormControlLabel from '@material-ui/core/FormControlLabel';\nimport Checkbox from '@material-ui/core/Checkbox';\n\nconst useStyles = makeStyles((theme) => ({\n  root: {\n    display: 'flex',\n  },\n  formControl: {\n    margin: theme.spacing(1),\n  },\n}));\n\nexport default function InstrumentConfig(props) {\n  const classes = useStyles();\n\n  const currentInstruments = 3;\n  const currentTracks = props.instruments.length;\n\n  let instrumentMask = [];\n\n  for( let i = 0; i < currentInstruments; ++i )\n  {\n    instrumentMask.push(Array(currentTracks).fill(0));\n  }\n\n  const [state, setState] = React.useState({\n    instrumentMask : instrumentMask,\n    instrumentNames: [\"djembe\", \"bass\", \"snare\"]\n  });\n\n  const handleChange = (event) => {\n    setState({ ...state, [event.target.name]: event.target.checked });\n  };\n\n  const createLabel = (x,y) => {\n    return( <FormControlLabel\n      control={<Checkbox checked={state.instrumentMask[y][x]} onChange={handleChange} name={x.toString() + \",\" + y.toString()} />}\n    />\n    );\n  };\n\n  const createColumn = (title, trackIndex) => {    \n    return (\n        <FormControl component=\"fieldset\" className={classes.formControl} key={\"track-form-\" + title}>\n          <FormLabel component=\"legend\">{title}</FormLabel>\n          <FormGroup>\n            {[...Array(state.instrumentNames.length).keys()].map(y => createLabel(trackIndex,y))}\n          </FormGroup>\n        </FormControl>\n    );\n  };\n\n  return (\n    <FormGroup className={classes.root} row>\n      {[...Array(props.instruments.length).keys()].map(x=>createColumn(props.instruments[x].name, x))}\n    </FormGroup>\n  );\n}\n\n","const DEFAULT_INSTRUMENT_SYMBOLS = {\n  \"Djembe Slap\" : \"S\",\n  \"Djembe Tone\" : \"t\",\n  \"Djembe Bass\" : \"O\",\n  \"Snare Ghost\" : \"-\",\n  \"Snare Accent\" : \"X\",\n  \"Shaker Ghost\" : \"x\",\n  \"Shaker Accent\" : \"X\",\n  \"Click\" : \"X\",\n  \"Bass\" : \"O\",\n  \"Tom\" : \"O\",\n  \"Default\" : \"X\"\n};\n\nfunction normalizeInstrumentsForFiguring(instruments)\n{\n  let n = [];\n  for(const inst of instruments)\n  {\n    let nInst = Object.assign({}, inst);\n    // for some reason these instruments are one-size arrays, and one id ... the track id from hydrogen\n    // this should be fixed, this doesn't make sense\n    nInst.name = nInst.name[0].toLowerCase();\n    n.push( nInst );\n  }\n  return n;\n}\n\nfunction figureDjembes(instrumentsRaw, symbolConfig)\n{\n  const instruments = normalizeInstrumentsForFiguring(instrumentsRaw);\n  const djembeTracks = instruments.filter( (inst) => inst.name.includes(\"djembe\") );\n  if(djembeTracks.length === 0)\n  {\n    return [];\n  }\n  else if(djembeTracks.length <= 3)\n  {\n    // let's lazily assume we have a slap, tone, bass\n    const slapArray = Array.from( djembeTracks, (inst) => inst.name.includes(\"slap\") );\n    const toneArray = Array.from( djembeTracks, (inst) => inst.name.includes(\"tone\") );\n    const bassArray = Array.from( djembeTracks, (inst) => inst.name.includes(\"bass\") );\n    for( let i = 0; i < djembeTracks.length; ++i )\n    {\n      let parityCheck = slapArray[i] + toneArray[i] + bassArray[i];\n      // failed to figure out how djembes work return empty array\n      if(parityCheck !== 1)\n      {\n        return [];\n      }\n    }\n    let djembeMapping = {};\n    for( let i = 0; i < djembeTracks.length; ++i )\n    {\n      if( slapArray[i] )\n      {\n        djembeMapping[ djembeTracks[i].id.toString() ] = symbolConfig[\"Djembe Slap\"];\n      }\n      else if( toneArray[i] )\n      {\n        djembeMapping[ djembeTracks[i].id.toString() ] = symbolConfig[\"Djembe Tone\"];\n      }\n      else if( bassArray[i] )\n      {\n        djembeMapping[ djembeTracks[i].id.toString() ] = symbolConfig[\"Djembe Bass\"];\n      }\n    }\n    return [ [ \"Djembe\", djembeMapping ] ];\n  }\n  else\n  {\n    // TODO: support more than one djembe\n    return []\n  }\n}\n\n// used by snare/shaker\nfunction manageAccentOrGhost(instrumentTracks, instrumentName, accentSymbol, ghostSymbol)\n{\n  let outputInstruments = [];\n  if(instrumentTracks.length === 2)\n  {\n    const t0 = instrumentTracks[0];\n    const t1 = instrumentTracks[1];\n    // attempt to determine ghost/accent\n    const zeroLouder = t0.volume > t1.volume || (t0.volume === t1.volume && t0.gain > t1.gain);\n    let mapping = {};\n    mapping[ t0.id.toString() ] = zeroLouder ? accentSymbol : ghostSymbol;\n    mapping[ t1.id.toString() ] = zeroLouder ? ghostSymbol : accentSymbol;\n    outputInstruments.push([instrumentName, mapping] );  \n  }\n  else // if 1 it must be an accent, if >= 3 ... I don't want to try and assign ghosts/accents\n  {\n    // I don't want to support ghost/accent here right now\n    for( const track of instrumentTracks )\n    {\n      let mapping = {};\n      mapping[ track.id.toString() ] = accentSymbol;\n      outputInstruments.push([instrumentName, mapping] );  \n    }\n  }\n  return outputInstruments;\n\n}\n\nfunction figureShakers(instrumentsRaw, symbolConfig)\n{\n  const instruments = normalizeInstrumentsForFiguring(instrumentsRaw);\n  // todo: support common alternative shakers? Tambourine?\n  const shakerTracks = instruments.filter( (inst) => ( inst.name.includes(\"shaker\") ) );\n  return manageAccentOrGhost( \n    shakerTracks, \n    \"Shaker\", \n    symbolConfig[\"Shaker Accent\"],\n    symbolConfig[\"Shaker Ghost\"]\n  );\n}\n\nfunction figureSnares(instrumentsRaw, symbolConfig)\n{\n  const instruments = normalizeInstrumentsForFiguring(instrumentsRaw);\n  const snareTracks = instruments.filter( (inst) => ( inst.name.includes(\"snare\") ) );\n  // todo: we currently assume 2 snares is accent/ghost ... but I think it's relatively\n  // common to be 2 snare parts too, I think the algorithm here is check patterns to\n  // see if they overlap ... if the \"ghosts\" overlap the \"hits\" sometimes, assume 2 parts\n  return manageAccentOrGhost( \n    snareTracks, \n    \"Snare\", \n    symbolConfig[\"Snare Accent\"],\n    symbolConfig[\"Snare Ghost\"]\n  );\n}\n\nfunction activeInstruments(patterns)\n{\n  let nonTrivialInstruments = new Set();\n  for( const p of patterns )\n  {\n    for(const [instrumentID, part] of Object.entries(p.instrumentTracks))\n    {\n      if( !part.empty() )\n      {\n        nonTrivialInstruments.add(parseInt(instrumentID));\n      }\n    }\n  }\n  return nonTrivialInstruments;\n}\n\nfunction countInstrumentOverlapForAllTracks(aid, bid, patterns)\n{\n  let count = 0;\n  for( const p of patterns )\n  {\n    const aTrack = p.instrumentTracks[aid];\n    const bTrack = p.instrumentTracks[bid];\n    if( aTrack != null && bTrack != null )\n    {\n      count += aTrack.countOverlap( bTrack );\n    }\n  }\n  return count;\n}\n\nfunction figureClickyInstruments(instrumentsRaw, symbolConfig, patterns)\n{\n  const instruments = normalizeInstrumentsForFiguring(instrumentsRaw);\n  const worthwhileInstruments = activeInstruments(patterns);\n  const relevantTracks = instruments.filter( (inst) => ( worthwhileInstruments.has(inst.id) &&\n    !inst.name.includes(\"djembe\") &&\n    ( inst.name.includes(\"click\") || \n    inst.name.includes(\"stick\") || \n    inst.name.includes(\"tom\") || \n    inst.name.includes(\"bass\") ||\n    inst.name.includes(\"kick\") )\n  ) );\n\n  const trackIsClick = Array.from(\n    relevantTracks,\n    (t) => t.name.includes(\"click\") || t.name.includes(\"stick\")\n  );\n  // we rioritise the early tracks\n  // and hope for the best\n\n  let collated = [];\n  for( let candidate = 0; candidate < Math.floor(relevantTracks.length/2); ++candidate )\n  {\n    if( trackIsClick[candidate*2] !== trackIsClick[candidate*2+1] )\n    {\n      const clickTrack = trackIsClick[candidate*2] ? relevantTracks[candidate*2] : relevantTracks[candidate*2+1];\n      const hitTrack = trackIsClick[candidate*2] ? relevantTracks[candidate*2+1] : relevantTracks[candidate*2];\n      const instrumentIsTom = hitTrack.name.includes(\"tom\");\n      const instrumentName = instrumentIsTom ? \"Tom\" : \"Bass\";\n      let mapping = {};\n      mapping[hitTrack.id.toString()] = symbolConfig[instrumentName];\n      mapping[clickTrack.id.toString()] = symbolConfig[\"Click\"];\n      collated.push([instrumentName, mapping] );  \n    }\n  }\n\n  // If there's a remainder instrument and there's no click\n  if( ((relevantTracks.length % 2 ) !== 0) && !trackIsClick[ relevantTracks.length - 1 ] )\n  {\n    const lastTrack = relevantTracks[relevantTracks.length - 1];\n    const instrumentName = lastTrack.name.includes(\"tom\") ? \"Tom\" : \"Bass\";\n    let mapping = {};\n    mapping[lastTrack.id.toString()] = symbolConfig[instrumentName];\n    collated.push([instrumentName, mapping] );  \n  }\n\n  return collated;\n}\n\nfunction figureInstruments(instrumentsRaw, symbolConfig, patterns)\n{\n  let output = [];\n  output = output.concat( figureClickyInstruments( instrumentsRaw, symbolConfig, patterns ) );\n  output = output.concat( figureDjembes( instrumentsRaw, symbolConfig ) );\n  output = output.concat( figureSnares( instrumentsRaw, symbolConfig ) );\n  output = output.concat( figureShakers( instrumentsRaw, symbolConfig ) );\n\n  // we ignore track used by multiple instruments\n\n  // but attempt to cover \"instrument not recognised anywhere\"\n\n  const worthwhileInstruments = activeInstruments(patterns);\n\n  for(const inst of instrumentsRaw)\n  {\n    if( !worthwhileInstruments.has(inst.id) )\n    {\n      continue;\n    }\n    let instrumentUsed = false;\n    for( const op of output)\n    {\n      if( inst.id.toString() in op[1] ) \n      {\n        instrumentUsed = true;\n      }\n    }\n    if(instrumentUsed === false)\n    {\n      let mapping = {};\n      mapping[ inst.id.toString() ] = symbolConfig[\"Default\"];\n      output.push( [inst.name[0], mapping] );\n    }\n  }\n  \n  return output; \n}\n\nexport { DEFAULT_INSTRUMENT_SYMBOLS, figureClickyInstruments, figureDjembes, figureShakers, figureSnares, figureInstruments };","import React from 'react';\nimport clsx from 'clsx';\nimport FileImport from \"./FileImport\";\nimport Pattern from \"./Pattern\";\nimport h2 from './h2';\nimport './App.css';\n\nimport { Alert } from '@material-ui/lab';\n\n// define mui theme, including responsiveFont\nimport { createMuiTheme, ThemeProvider } from '@material-ui/core/styles';\n\n// drawer\nimport Drawer from '@material-ui/core/Drawer';\nimport CssBaseline from '@material-ui/core/CssBaseline';\nimport List from '@material-ui/core/List';\nimport ListItem from '@material-ui/core/ListItem';\nimport ListItemText from '@material-ui/core/ListItemText';\n\nimport IconButton from '@material-ui/core/IconButton';\nimport MenuIcon from '@material-ui/icons/Menu';\nimport ChevronRightIcon from \"@material-ui/icons/ChevronRight\";\n\n// notationSettings\n\nimport {FormatSettings, DefaultSettings} from \"./formatSettings\";\nimport InstrumentConfig from \"./instrumentConfig\";\nimport { figureInstruments, DEFAULT_INSTRUMENT_SYMBOLS } from \"./instrumentation\";\n\n// mui theme config\nlet theme = createMuiTheme( { \n  palette: { \n    type: 'dark',\n    primary: { main: '#36d9be' },\n    secondary: { main: '#f50057' }\n   } \n} );\n\n\nclass App extends React.Component\n{\n  constructor(props) {\n    super(props);\n    this.state = {\n      instruments : null,\n      patterns : null,\n      selectedPattern : null,\n      loadedFile : null,\n      settingsOpen : false,\n      formatSettings : Object.assign({}, DefaultSettings)\n    };\n  }\n\n  handleFileImport(e)\n  {\n    // e = { file : , content : }\n    h2.parseHydrogenPromise(e.content).then(h => {\n      const assessedInstruments = figureInstruments(h.instruments, DEFAULT_INSTRUMENT_SYMBOLS, h.patterns);\n      this.setState({\n        instruments : assessedInstruments,\n        patterns : h.patterns,\n        selectedPattern : h.patterns.length === 0 ? null : 0,\n        loadedFile : e.file.name\n      });\n    });\n  }\n\n  selectPattern(patternIndex)\n  {\n    this.setState( { selectedPattern: patternIndex } );\n  }\n\n  // todo: this is a separate component!\n  renderPattern(pattern, settings)\n  {\n    const changeInstrumentsCallback = (instruments) => {\n      this.setState( { instruments : instruments } );\n    }\n    /*\n        <InstrumentConfig \n          instruments={this.state.instruments}\n          onChange={changeInstrumentsCallback}\n        />\n    */\n    return (\n      <React.Fragment>\n        <Pattern \n          instruments={this.state.instruments} \n          tracks={pattern.instrumentTracks}\n          config={this.state.formatSettings}\n        />\n      </React.Fragment>\n    );\n  }\n\n  // todo: this will go away eventually, once I choose how to load a file\n  // (though it should obviously be another component anyway)\n  renderMainContent()\n  {\n    if(this.state.patterns == null || this.state.patterns.length === 0)\n    {\n      const showAlert = this.state.patterns != null && this.state.patterns.length === 0;\n      const optionalAlert = showAlert ? ( <Alert severity=\"error\">{this.state.loadedFile} contained no patterns! Try another.</Alert> )\n                                      : \"\";\n      return (\n        <div>\n          <h2>tabit</h2>\n          <FileImport\n            onImport={this.handleFileImport.bind(this)}\n            />\n            {optionalAlert}\n        </div>\n      );      \n    }\n    else\n    {\n      let patternContent = null;\n      // default title \n      if( this.state.selectedPattern == null )\n      {\n        patternContent = [];\n        for( const pattern of this.state.patterns ) {\n          patternContent.push( this.renderPattern(pattern) );\n        }\n      }\n      else\n      {\n        const patternToRender = this.state.patterns[this.state.selectedPattern];\n        patternContent = this.renderPattern(patternToRender);\n      }\n       \n      const handleDrawerOpen = () => {\n        this.setState( {settingsOpen : true} );\n      };\n\n      const handleDrawerClose = () => {\n        this.setState( {settingsOpen : false} );\n      };\n\n      const settingsChangeCallback = (config) => {\n        this.setState( { formatSettings: config } );\n      };\n\n      const classes = this.props;\n\n      // ugh 95%, seems flex doesn't solve everything\n      return (\n        <React.Fragment>\n          <div style={{display:\"flex\", width: \"95%\"}}> \n            <div className=\"content-title\" style={{flexGrow:1}}>\n            </div>\n            <IconButton\n              color=\"inherit\"\n              aria-label=\"open drawer\"\n              edge=\"end\"\n              onClick={handleDrawerOpen}\n              className={clsx(this.state.settingsOpen && classes.hide)}\n            >\n              <MenuIcon />\n            </IconButton>\n          </div>\n          {patternContent}\n\n      <Drawer\n        className={classes.drawer}\n        variant=\"persistent\"\n        anchor=\"right\"\n        open={this.state.settingsOpen}\n        classes={{\n          paper: classes.drawerPaper\n        }}\n      >\n        <div className={classes.drawerHeader}>\n          <IconButton onClick={handleDrawerClose}>\n              <ChevronRightIcon />\n          </IconButton>\n        </div>\n        <FormatSettings onChange={settingsChangeCallback} settings={this.state.formatSettings}/>  \n        </Drawer>\n        </React.Fragment>\n      );\n    }\n  }\n\n  render() {\n    const classes = this.props;\n    const patternsReady = this.state.patterns != null;\n    const mainContent = this.renderMainContent();\n    return (\n      <div className=\"App\">\n        <ThemeProvider theme={theme}>\n          <CssBaseline />\n          <Drawer\n            className={classes.drawer}\n            variant=\"persistent\"\n            open={patternsReady}\n          >\n            <div className={classes.drawerContainer}>\n              <List>\n                {(this.state.patterns ?? []).map( (pattern, index) => (\n                  <ListItem button key={\"drawer-pattern\" + index.toString()} onClick={() => this.selectPattern(index)}>\n                      <ListItemText primary={pattern.name} />\n                  </ListItem>\n                ))}\n              </List>\n            </div>\n          </Drawer>\n          {mainContent}\n        </ThemeProvider>\n      </div>\n    );\n  }\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' },\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}