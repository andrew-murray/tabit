{"version":3,"sources":["formatSettings.js","App.js","FileImport.js","Pattern.js","h2.js","Audio.js","AudioRequest.js","SoundBoard.js","serviceWorker.js","index.js","instrumentation.js","notation.js","instrumentConfig.js","track.js","utilities.js"],"names":["useStyles","makeStyles","theme","formControl","margin","spacing","minWidth","selectEmpty","marginTop","camelToReadable","s","spacedString","replace","toUpperCase","slice","FormatSettings","props","classes","stateToItem","value","handleOptionChange","event","updatedState","settings","target","name","onChange","handleCheckedChange","checked","className","root","notation","FORMAT_CONFIG_STRINGS","map","op","options","idString","variant","key","id","labelId","createOptionMenu","reduce","prev","curr","FORMAT_CONFIG_BOOLS","control","label","DefaultSettings","DEFAULT_FORMAT_CONFIG","createMuiTheme","palette","type","primary","main","secondary","App","state","instruments","instrumentIndex","instrumentMask","patterns","selectedPattern","loadedFile","settingsOpen","patternsOpen","formatSettings","Object","assign","progress","e","h2","parseHydrogenPromise","content","then","h","assessedInstruments","figureInstruments","DEFAULT_INSTRUMENT_SYMBOLS","activeInstrumentation","setState","createInstrumentMask","length","file","patternIndex","this","pattern","Fragment","tracks","instrumentTracks","config","active","container","item","xs","k","replacedTracks","entries","trackData","track","rep","resolution","createObjects","kuva","a","check","navigator","userAgent","vendor","window","opera","test","substr","optionalAlert","severity","onClick","loadExample","bind","onImport","handleFileImport","style","position","bottom","href","patternContent","push","renderPattern","patternToRender","ignoreEvent","handleDrawerOpen","handleDrawerClose","handlePatternsClose","handlePatternsOpen","iOS","process","browser","mobile","checkMobile","display","width","color","aria-label","edge","clsx","hide","flexGrow","disableBackdropTransition","disableDiscovery","drawer","undefined","open","onOpen","onClose","drawerHeader","drawerContainer","index","button","toString","selectPattern","anchor","paper","drawerPaper","mainContent","renderMainContent","React","Component","FileImport","fileObject","files","reader","FileReader","onload","loadEvent","result","readAsText","Pattern","configOverride","page","instrumentName","instrument","notationString","fromInstrumentAndTrack","split","x","formatText","dangerouslySetInnerHTML","withStyles","fontFamily","textAlign","whiteSpace","parseHydrogenJs","instrumentElements","song","instrumentList","instrumentArray","Array","from","element","instrumentComponent","inst","parseInt","parseFloat","volume","isMuted","gain","drumkit","layer","filename","patternElements","patternList","patternArray","noteElements","noteList","note","patternSize","size","notes","noteElement","filter","n","patternsWithTracks","positions","calculateResolution","calculatePatternResolution","relevantNotes","relevantHits","fromPositions","xmlString","parser","xml2js","Parser","parseStringPromise","Audio","minResolution","t","empty","Math","min","trackLength","max","combined","peakValue","channel","numberOfChannels","combinedChannel","getChannelData","sample","abs","peakAmplitude","context","sounds","tempo","determineTrackLength","trackLengthSamples","totalSamples","floor","samplesPerHydrogen","createBuffer","selected","audioBuffer","audioChannel","trackPoints","toPoints","sampleStart","normalizeAudioBuffer","buffer","source","createBufferSource","loop","connect","destination","AudioContext","webkitAudioContext","AudioRequest","url","Promise","resolve","reject","request","XMLHttpRequest","responseType","status","response","Error","statusText","onerror","send","decodeAudioData","err","DRUMKITS","SoundBoard","audioSource","soundsPopulated","collatedPromises","selected_instrument","includes","dest_url","actx","make","parse","catch","fail","console","log","board","all","b","createMasterTrack","determineMinResolution","stop","timeoutID","clearTimeout","playPos","prevProps","prevState","snapshot","tracksAreDifferent","playBuffer","populateSounds","createAudioSource","start","startTime","currentTime","onPlaybackPositionChange","updatePlayPos","duration","beatCount","currentBeat","round","nextBeatTime","setTimeout","IconButton","Boolean","location","hostname","match","ReactDOM","render","StrictMode","document","getElementById","serviceWorker","ready","registration","unregister","error","message","normalizeInstrumentsForFiguring","nInst","toLowerCase","manageAccentOrGhost","accentSymbol","ghostSymbol","outputInstruments","t0","t1","zeroLouder","mapping","activeInstruments","nonTrivialInstruments","Set","p","instrumentID","add","has","instrumentsRaw","symbolConfig","output","concat","worthwhileInstruments","relevantTracks","trackIsClick","collated","candidate","clickTrack","hitTrack","lastTrack","figureClickyInstruments","djembeTracks","slapArray","toneArray","bassArray","i","djembeMapping","figureDjembes","figureSnares","figureShakers","instrumentUsed","patternResolution","beatResolution","lineResolution","str","chunkSize","RegExp","validateConfig","lineLength","ceil","numberMarkerArray","numberRestMark","beat","join","line","asHTML","beatChunkSize","formatSymbol","symbol","numericPosition","formattedLine","charAt","lineWithBeats","showBeatMark","chunkString","beatMark","lineMark","trackDict","formatConfig","keys","propName","hasOwnProperty","values","notationLength","fill","restMark","charIndex","trackID","trackSymbol","trackInstance","patternString","lineArray","formattedLineArray","showBeatNumbers","formatLineWithMarkers","createNumberMarker","ThinFormControlLabel","marginLeft","marginRight","FormControlLabel","InlinableIconButton","padding","CenterTableCell","TableCell","InstrumentConfig","useState","renamingInstrument","setRenamingInstrument","nameState","setNameState","createCell","y","align","oldInstrumentIndex","findIndex","dstInstrumentIndex","oldInstrument","replacedSrcInstrument","dstInstrument","replacedInstruments","handleChange","createMatchingRow","component","scope","fontSize","removeInstrument","editSymbol","setEditSymbol","editSymbolState","setEditSymbolState","aria-labelledby","autoFocus","fullWidth","trim","extraInstrument","updatedSymbol","alert","table","currentSymbol","startEditingSymbol","baseInstrumentIndex","baseInstrumentId","targetInstrumentIndex","count","other","_sumOverlapsOfArrays","hcf","findHCF","formatResolution","totalLength","points","representPoints","arrayIndex","resolutionToUse","implicitPositions","allNotesPass"],"mappings":"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","file":"static/js/main.741fbf9d.chunk.js","sourcesContent":["import React from 'react';\nimport { makeStyles } from '@material-ui/core/styles';\nimport InputLabel from '@material-ui/core/InputLabel';\nimport MenuItem from '@material-ui/core/MenuItem';\nimport FormControl from '@material-ui/core/FormControl';\nimport FormGroup from '@material-ui/core/FormGroup';\nimport FormControlLabel from '@material-ui/core/FormControlLabel';\nimport Switch from '@material-ui/core/Switch';\nimport Select from '@material-ui/core/Select';\nimport Divider from \"@material-ui/core/Divider\";\n\nimport notation from \"./notation\";\n\nconst useStyles = makeStyles((theme) => ({\n  formControl: {\n    margin: theme.spacing(1),\n    minWidth: 120,\n  },\n  selectEmpty: {\n    marginTop: theme.spacing(2),\n  },\n}));\n\nfunction camelToReadable(s)\n{\n  const spacedString = s.replace(/([A-Z])/g, ' $1');\n  return spacedString[0].toUpperCase() + spacedString.slice(1);\n}\n\nfunction FormatSettings(props) {\n  const classes = useStyles();\n  // todo: change to multiple useState calls?\n\n  function stateToItem(value)\n  {\n    return value === \" \" ? \"space\" : value;\n  }\n\n  function itemToState(value)\n  {\n    return value === \"space\" ? \" \" : value;\n  }\n\n  const handleOptionChange = (event) => {\n    const updatedState = {...props.settings, [event.target.name]: itemToState(event.target.value)};\n    props.onChange(updatedState);\n  };\n\n  const handleCheckedChange = (event) => {\n    const updatedState = {...props.settings, [event.target.name]: event.target.checked};\n    props.onChange(updatedState);\n  };\n\n  function createOptionMenu(name, options)\n  {\n    const idString = \"form-control-\" + name + \"-id\";\n    return (\n      <FormControl variant=\"filled\" className={classes.formControl} key={idString} id={idString}>\n        <InputLabel id=\"settings-option-{name}\">{name}</InputLabel>\n        <Select\n          labelId={\"settings-option-\" + name + \"-labelID\"}\n          id={\"settings-option-\" + name + \"-id\"}\n          value={stateToItem(props.settings[name])}\n          name={name}\n          onChange={handleOptionChange}\n        >\n          {options.map((op) => <MenuItem key={\"settings-menu-item-\" + name + \"-\" + op} value={stateToItem(op)}>{stateToItem(op)}</MenuItem>)}\n        </Select>\n      </FormControl>\n    );\n  };\n\n  function createBoolControl(name)\n  {\n    return (\n      <FormControlLabel\n        control={<Switch checked={props.settings[name]} onChange={handleCheckedChange} name={name} />}\n        label={camelToReadable(name)}\n        key={\"switch-\"+name}\n      />\n    );\n  };\n\n  return (\n    <FormGroup className={classes.root}>\n      {notation.FORMAT_CONFIG_STRINGS.map( op => createOptionMenu( op[0], op[1] ) ).reduce((prev, curr) => [prev, <Divider/>, curr])}\n      <Divider/>\n      {notation.FORMAT_CONFIG_BOOLS.map( op => createBoolControl( op )).reduce((prev, curr) => [prev, <Divider/>, curr]) }\n    </FormGroup>\n  );\n}\n\nconst DefaultSettings = notation.DEFAULT_FORMAT_CONFIG; \n\n\nexport { FormatSettings, DefaultSettings }\nexport default FormatSettings;","import React from 'react';\nimport clsx from 'clsx';\nimport FileImport from \"./FileImport\";\nimport Pattern from \"./Pattern\";\nimport h2 from './h2';\nimport './App.css';\n\nimport { Alert } from '@material-ui/lab';\n\n// define mui theme, including responsiveFont\nimport { createMuiTheme, ThemeProvider } from '@material-ui/core/styles';\n\n// drawer\nimport SwipeableDrawer from '@material-ui/core/SwipeableDrawer';\nimport CssBaseline from '@material-ui/core/CssBaseline';\nimport List from '@material-ui/core/List';\nimport ListItem from '@material-ui/core/ListItem';\nimport ListItemText from '@material-ui/core/ListItemText';\n\nimport IconButton from '@material-ui/core/IconButton';\nimport Button from '@material-ui/core/Button';\nimport MenuIcon from '@material-ui/icons/Menu';\nimport ChevronLeftIcon from \"@material-ui/icons/ChevronLeft\";\nimport ChevronRightIcon from \"@material-ui/icons/ChevronRight\";\nimport Divider from \"@material-ui/core/Divider\";\n\n// notationSettings\n\nimport {FormatSettings, DefaultSettings} from \"./formatSettings\";\nimport {createInstrumentMask, InstrumentConfig} from \"./instrumentConfig\";\nimport { activeInstrumentation, figureInstruments, DEFAULT_INSTRUMENT_SYMBOLS } from \"./instrumentation\";\n\nimport Grid from '@material-ui/core/Grid';\n\n// load static data\nimport kuva from \"./kuva.json\";\nimport track from \"./track\";\n\nimport SoundBoard from \"./SoundBoard\";\n// mui theme config\nlet theme = createMuiTheme( { \n  palette: { \n    type: 'dark',\n    primary: { main: '#36d9be' },\n    secondary: { main: '#f50057' }\n   } \n} );\n\nclass App extends React.Component\n{\n  constructor(props) {\n    super(props);\n    this.state = {\n      instruments : null,\n      instrumentIndex : null,\n      instrumentMask : null,\n      patterns : null,\n      selectedPattern : null,\n      loadedFile : null,\n      settingsOpen : false,\n      patternsOpen : false,\n      formatSettings : Object.assign({}, DefaultSettings),\n      progress : null\n    };\n  }\n\n  handleFileImport(e)\n  {\n    // e = { file : , content : }\n    h2.parseHydrogenPromise(e.content).then(h => {\n      const assessedInstruments = figureInstruments(h.instruments, DEFAULT_INSTRUMENT_SYMBOLS, h.patterns);\n      const instrumentIndex = activeInstrumentation(h.instruments, h.patterns);\n      this.setState({\n        instrumentIndex : instrumentIndex,\n        instrumentMask : createInstrumentMask(instrumentIndex, assessedInstruments),\n        instruments : assessedInstruments,\n        patterns : h.patterns,\n        selectedPattern : h.patterns.length === 0 ? null : 0,\n        loadedFile : e.file.name,\n        patternsOpen : true\n      });\n    });\n  }\n\n  selectPattern(patternIndex)\n  {\n    this.setState( { selectedPattern: patternIndex } );\n  }\n\n  // todo: this is a separate component!\n  renderPattern(pattern, settings)\n  {\n    const changeInstrumentsCallback = (instruments) => {\n      this.setState( {\n        instruments : instruments,\n        instrumentMask : createInstrumentMask(this.state.instrumentIndex, instruments)\n      } );\n    }\n\n    return (\n      <React.Fragment>\n        <Pattern \n          instruments={this.state.instruments} \n          tracks={pattern.instrumentTracks}\n          config={this.state.formatSettings}\n          active={this.state.progress}\n        />\n        <SoundBoard \n          instruments={this.state.instruments} \n          instrumentIndex={this.state.instrumentIndex} \n          tracks={pattern.instrumentTracks}\n        />\n        <Grid container>\n        <Grid item xs={2} />\n        <Grid item xs={8}>\n          <InstrumentConfig\n            instruments={this.state.instruments}\n            instrumentIndex={this.state.instrumentIndex}\n            instrumentMask={this.state.instrumentMask}\n            onChange={changeInstrumentsCallback}\n          />\n        </Grid>\n        <Grid item xs={2} />\n        </Grid>\n      </React.Fragment>\n    );\n  }\n\n\n\n  loadExample()\n  {\n    const createObjects = (state) => \n    {\n      // the instruments currently work as simple objects\n      // we need to create tracks!\n      for( let pattern of state.patterns )\n      {\n        let replacedTracks = {};\n        // todo: find a more compact way of doing this\n        for( const [id, trackData] of Object.entries(pattern.instrumentTracks) )\n        {\n          replacedTracks[id] = new track( trackData.rep, trackData.resolution );\n        }\n        pattern.instrumentTracks = replacedTracks;\n      }\n      return state;\n    }\n    const k = createObjects(kuva);\n    const assessedInstruments = figureInstruments(k.instruments, DEFAULT_INSTRUMENT_SYMBOLS, k.patterns);\n    const instrumentIndex = activeInstrumentation(k.instruments, k.patterns);\n    this.setState({\n      instrumentIndex : instrumentIndex,\n      instrumentMask : createInstrumentMask(instrumentIndex, assessedInstruments),\n      instruments : assessedInstruments,\n      patterns : k.patterns,\n      selectedPattern : k.patterns.length === 0 ? null : 0,\n      loadedFile : \"kuva.example\",\n      patternsOpen : true\n    });\n  }\n\n  checkMobile()\n  {\n    // https://stackoverflow.com/questions/11381673/detecting-a-mobile-browser\n    let check = false;\n    (function(a){if(/(android|bb\\d+|meego).+mobile|avantgo|bada\\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(a)||/1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\\-(n|u)|c55\\/|capi|ccwa|cdm\\-|cell|chtm|cldc|cmd\\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\\-s|devi|dica|dmob|do(c|p)o|ds(12|\\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\\-|_)|g1 u|g560|gene|gf\\-5|g\\-mo|go(\\.w|od)|gr(ad|un)|haie|hcit|hd\\-(m|p|t)|hei\\-|hi(pt|ta)|hp( i|ip)|hs\\-c|ht(c(\\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\\-(20|go|ma)|i230|iac( |\\-|\\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\\/)|klon|kpt |kwc\\-|kyo(c|k)|le(no|xi)|lg( g|\\/(k|l|u)|50|54|\\-[a-w])|libw|lynx|m1\\-w|m3ga|m50\\/|ma(te|ui|xo)|mc(01|21|ca)|m\\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\\-2|po(ck|rt|se)|prox|psio|pt\\-g|qa\\-a|qc(07|12|21|32|60|\\-[2-7]|i\\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\\-|oo|p\\-)|sdk\\/|se(c(\\-|0|1)|47|mc|nd|ri)|sgh\\-|shar|sie(\\-|m)|sk\\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\\-|v\\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\\-|tdg\\-|tel(i|m)|tim\\-|t\\-mo|to(pl|sh)|ts(70|m\\-|m3|m5)|tx\\-9|up(\\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\\-|your|zeto|zte\\-/i.test(a.substr(0,4))) check = true;})(navigator.userAgent||navigator.vendor||window.opera);\n    return check;\n  }\n\n  // todo: this will go away eventually, once I choose how to load a file\n  // (though it should obviously be another component anyway)\n  renderMainContent()\n  {\n    if(this.state.patterns == null || this.state.patterns.length === 0)\n    {\n      const showAlert = this.state.patterns != null && this.state.patterns.length === 0;\n      const optionalAlert = showAlert ? ( <Alert severity=\"error\">{this.state.loadedFile} contained no patterns! Try another.</Alert> )\n                                      : \"\";\n      return (\n        <React.Fragment>\n        <div>\n          <h2>tabit</h2>\n          <p>I read .h2songs and write tab</p>\n          <Button variant=\"contained\" onClick={this.loadExample.bind(this)}>See an example</Button>\n          <p>Or import your own</p>\n          <FileImport\n            onImport={this.handleFileImport.bind(this)}\n            />\n            {optionalAlert}\n        </div>\n        <div style={{ position:\"absolute\", bottom:0 }} >\n          <p>tabit relies on publicly available sound libraries listed at <a href=\"https://github.com/andrew-murray/tabit\">https://github.com/andrew-murray/tabit</a></p>\n        </div>\n        </React.Fragment>\n      );      \n    }\n    else\n    {\n      let patternContent = null;\n      // default title \n      if( this.state.selectedPattern == null )\n      {\n        patternContent = [];\n        for( const pattern of this.state.patterns ) {\n          patternContent.push( this.renderPattern(pattern) );\n        }\n      }\n      else\n      {\n        const patternToRender = this.state.patterns[this.state.selectedPattern];\n        patternContent = this.renderPattern(patternToRender);\n      }\n       \n      const ignoreEvent = (event) => {\n        return event && event.type === 'keydown' && (event.key === 'Tab' || event.key === 'Shift');\n      };\n\n      const settingsChangeCallback = (config) => {\n        this.setState( { formatSettings: config } );\n      };\n\n      const handleDrawerOpen = (e) => {\n        if( ignoreEvent(e) ){ return; }\n        this.setState( {settingsOpen : true} );\n      };\n\n      const handleDrawerClose = (e) => {\n        if( ignoreEvent(e) ){ return; }\n        this.setState( {settingsOpen : false} );\n      };\n\n      const handlePatternsClose = (e) => {\n        if( ignoreEvent(e) ){ return; }\n        this.setState( { patternsOpen : false } );\n      };\n      const handlePatternsOpen = (e) => {\n        if( ignoreEvent(e) ){ return; }\n        this.setState( { patternsOpen : true } );\n      };\n\n      const classes = this.props;\n      const iOS = process.browser && /iPad|iPhone|iPod/.test(navigator.userAgent);\n      const mobile = this.checkMobile();\n\n      return (\n        <React.Fragment>\n          <div style={{display:\"flex\", width: \"95%\"}}> \n            <IconButton\n              color=\"inherit\"\n              aria-label=\"open drawer\"\n              edge=\"start\"\n              onClick={handlePatternsOpen}\n              className={clsx({\n                [classes.hide] : !this.state.patternsOpen\n              })}\n            >\n              <ChevronRightIcon />\n            </IconButton>\n            <div className=\"content-title\" style={{flexGrow:1}}>\n            </div>\n            <IconButton\n              color=\"inherit\"\n              aria-label=\"open drawer\"\n              edge=\"end\"\n              onClick={handleDrawerOpen}\n              className={clsx(this.state.settingsOpen && classes.hide)}\n            >\n              <MenuIcon />\n            </IconButton>\n          </div>\n          {patternContent}\n\n        <SwipeableDrawer disableBackdropTransition={!iOS} disableDiscovery={iOS}\n          className={classes.drawer}\n          variant={ mobile ? undefined : \"persistent\" }\n          open={this.state.patternsOpen}\n          onOpen={handlePatternsOpen}\n          onClose={handlePatternsClose}\n        >\n          <div className={classes.drawerHeader}>\n            <IconButton onClick={handlePatternsClose}>\n                <ChevronLeftIcon />\n            </IconButton>\n          </div>\n          <Divider />\n          <div className={classes.drawerContainer}>\n            <List>\n              {(this.state.patterns ?? []).map( (pattern, index) => (\n                <ListItem button key={\"drawer-pattern\" + index.toString()} onClick={() => this.selectPattern(index)}>\n                    <ListItemText primary={pattern.name} />\n                </ListItem>\n              ))}\n            </List>\n          </div>\n        </SwipeableDrawer>\n        <SwipeableDrawer disableBackdropTransition={!iOS} disableDiscovery={iOS}\n          className={classes.drawer}\n          variant={ mobile ? undefined : \"persistent\" }\n          anchor=\"right\"\n          open={this.state.settingsOpen}\n          onOpen={handleDrawerOpen}\n          onClose={handleDrawerClose}\n          classes={{\n            paper: classes.drawerPaper\n          }}\n        >\n          <div className={classes.drawerHeader}>\n            <IconButton onClick={handleDrawerClose}>\n                <ChevronRightIcon />\n            </IconButton>\n          </div>\n          <Divider />\n          <FormatSettings onChange={settingsChangeCallback} settings={this.state.formatSettings}/>  \n        </SwipeableDrawer>\n        </React.Fragment>\n      );\n    }\n  }\n\n  render() {\n    const mainContent = this.renderMainContent();\n    return (\n      <div className=\"App\">\n        <ThemeProvider theme={theme}>\n          <CssBaseline />\n          {mainContent}\n        </ThemeProvider>\n      </div>\n    );\n  }\n}\n\nexport default App;\n","// FileUpload.react.js\n\n// inspired by https://gist.github.com/AshikNesin/e44b1950f6a24cfcd85330ffc1713513\n// and https://stackoverflow.com/questions/55830414/how-to-read-text-file-in-react\n\nimport React from 'react'\n\nclass FileImport extends React.Component {\n\n  constructor(props) {\n    super(props);\n    this.onChange = this.onChange.bind(this)\n  }\n\n  onChange(e) {\n    const fileObject = e.target.files[0]\n    const reader = new FileReader()\n    reader.onload = loadEvent => {\n      if( this.props.onImport )\n      {\n        this.props.onImport(\n          { file: fileObject, content : loadEvent.target.result}\n        );\n      }\n    }\n    reader.readAsText(fileObject);\n  }\n\n  render() {\n    return (\n      <input type=\"file\" onChange={this.onChange} />\n   )\n  }\n}\n\nexport default FileImport;\n","import React from 'react';\nimport notation from \"./notation\"\nimport { withStyles } from '@material-ui/core/styles';\n\nconst useStyles = theme => ({\n  root: {\n    \"margin-bottom\": theme.spacing(2),\n    fontFamily: \"Roboto Mono\",\n    textAlign: \"left\",\n    whiteSpace:\"pre\",\n    \"& .activeNote\": {\n      color : theme.palette.secondary.main\n    }\n  },\n});\n\n// const classes = useStyles();\n\nclass Pattern extends React.Component\n{\n  constructor(props) {\n    super(props);\n    this.state = {\n    };\n  }\n\n  // remove me and relpace with me with something way better\n  // this is taken from the notation formatAsPage code\n  formatText(instruments)\n  {\n    let configOverride = this.props.config;\n    let page = [];\n    for( const [instrumentName, instrument] of instruments )\n    {\n      const notationString = notation.fromInstrumentAndTrack(\n        instrument,\n        this.props.tracks,\n        configOverride\n      );\n      page.push(instrumentName);\n      for( const x of notationString.split(\"\\n\"))\n      {\n        page.push(x);\n      }\n    }\n    return page;\n  }  \n\n  render() {\n    const { classes } = this.props;\n    // todo: I think I need to turn the creation of the pattern text, into a react setting,\n    // so that I can add my light show\n    return (\n      <div className={classes.root} >\n        { this.formatText(this.props.instruments).map((x,index) => <p key={index.toString()} dangerouslySetInnerHTML={{\"__html\" : x}} />) }\n      </div>\n    );\n  }\n}\n\nexport default withStyles(useStyles)(Pattern);","// h2.js\n\nimport track from \"./track\"\nimport xml2js from \"xml2js\";\nimport { calculateResolution } from \"./utilities\";\n\n// let's think about the data representation needed\n\nfunction calculatePatternResolution(pattern, size)\n{\n  const positions = Array.from(pattern.notes, note => note.position)\n  return calculateResolution(positions, size);\n}\n\nfunction parseHydrogenJs(result)\n{\n    // fixme:\n    // this parsing often assumes there's >=2 elements\n\n    // this \"zero\" here is presumably an artefact of xml --> json representation\n    const instrumentElements = result.song.instrumentList[0].instrument;\n\n    // instruments\n    // [  { id, name } ]\n    const instrumentArray = Array.from(\n      instrumentElements,\n      function(element){\n        const instrumentComponent = element.instrumentComponent[0];\n        let inst = {\n          \"id\" : parseInt(element.id), \n          \"name\" : element.name,\n           \"volume\" : parseFloat(element.volume), \n           \"muted\" : element.isMuted[0] === \"true\",\n           \"gain\" : parseFloat(element.gain),\n           \"drumkit\" : element.drumkit[0]\n        };\n        if( \"layer\" in instrumentComponent )\n        {\n          inst[\"filename\"] = instrumentComponent.layer[0].filename[0];\n        }\n        return inst;\n      }\n    );\n\n    const patternElements = result.song.patternList[0].pattern;\n    // patterns\n    // [  { name, size, notes } ]\n    const patternArray = Array.from(\n      patternElements,\n      function(element){\n        const noteElements = element.noteList[0].note;\n        const patternSize = parseInt(element.size);\n        let notes = [];\n        if( noteElements )\n        {\n          // notes \n          // [ {position, instrument(id}]\n          notes = Array.from(\n            noteElements,\n            function(noteElement){\n              return {\"position\" : parseInt(noteElement.position), \"instrument\" : parseInt(noteElement.instrument)};\n            }\n          );\n\n          // hydrogen permits you to have notes that reach past the pattern size, \n          // they then get revealed when you extend the pattern, \n          // here's an easy point to get rid of them, we don't want them to factor into any calculations\n          notes = notes.filter( n => n.position < patternSize );\n        }\n        return {\n          \"size\" : patternSize, \n          \"name\" : element.name,\n          \"notes\" : notes\n        };\n      }\n    );\n\n    // transform pattern to a managable data\n    const patternsWithTracks = Array.from(\n      patternArray,\n      function(pattern)\n      { \n        const resolution = calculatePatternResolution(pattern, pattern.size);\n        let instrumentTracks = {};\n        for( const instrument of instrumentArray )\n        {\n          const relevantNotes = pattern.notes.filter( \n            note => (note.instrument === instrument.id)\n          );\n          const relevantHits = Array.from(\n            relevantNotes,\n            note => note.position\n          );\n          instrumentTracks[ instrument.id.toString() ] = track.fromPositions( relevantHits, pattern.size, resolution);\n        }\n        pattern.resolution = resolution;\n        pattern.instrumentTracks = instrumentTracks;\n        return pattern;\n      }\n    );\n\n    return {\n      \"instruments\" : instrumentArray,\n      \"patterns\" : patternsWithTracks\n    }\n}\n\nasync function parseHydrogenPromise(xmlString)\n{\n  let parser = new xml2js.Parser();\n\n  return parser.parseStringPromise(xmlString).then(parseHydrogenJs);\n}\n\nexport default { parseHydrogenPromise };","class Audio\n{\n\n  // todo: this context should be maintained at the app top-level, rather than internal to this class\n  // todo: we replace a valid audioConext with a blank object, so that we can run tests in node\n  //       this should probably be replaced by https://github.com/audiojs/web-audio-api \n  //       and a test-suite written\n  static context = new (window.AudioContext || window.webkitAudioContext || Object)();\n\n  static determineMinResolution(\n    instrumentIndex,\n    tracks\n  )\n  {\n      let minResolution = 48; \n      for(const [id,t] of Object.entries(tracks))\n      { \n        // the lookup and iteration shouldn't look like this\n        const selected =  instrumentIndex.filter(inst => inst.id.toString() === id);\n        if( \n          selected.length > 0 \n          && !t.empty()\n        )\n        {\n          minResolution = Math.min( minResolution, t.resolution );\n        }\n      }\n      return minResolution;\n  }\n\n  static determineTrackLength(\n    instrumentIndex,\n    tracks\n  )\n  {\n      let trackLength = 48;\n      for(const [id,t] of Object.entries(tracks))\n      { \n        // the lookup and iteration shouldn't look like this\n        const selected =  instrumentIndex.filter(inst => inst.id.toString() === id);\n        if( \n          selected.length > 0 \n          && !t.empty() \n        )\n        {\n          trackLength = Math.max( trackLength, t.length() );\n        }\n      }\n      return trackLength;\n  }\n\n  static peakAmplitude(\n    combined\n  )\n  {\n    let peakValue = 0.0;\n    for (let channel = 0; channel < combined.numberOfChannels; channel++) {\n      let combinedChannel = combined.getChannelData(channel);\n      for( let sample = 0; sample < combinedChannel.length; ++sample)\n      {\n        peakValue = Math.max( Math.abs(combinedChannel[sample]), peakValue );\n      }\n    }\n    return peakValue;\n  }\n\n  static normalizeAudioBuffer(\n    combined\n  )\n  {\n    const peakValue = Audio.peakAmplitude( combined );\n    if( peakValue > 1.0 )\n    {\n      for (let channel = 0; channel < combined.numberOfChannels; channel++) {\n        let combinedChannel = combined.getChannelData(channel);\n        for( let sample = 0; sample < combinedChannel.length; ++sample)\n        {\n          combinedChannel[sample] = combinedChannel[sample] / peakValue;\n        }\n      }\n    }\n    return combined;\n  }\n\n  static createMasterTrack(\n    context,\n    tracks,\n    instrumentIndex,\n    sounds,\n    tempo\n  )\n  {\n    const trackLength = Audio.determineTrackLength( instrumentIndex, tracks );\n\n\n    const beatTime =  (60.0 / tempo) * 1000;\n    const timePerHydrogen = beatTime / 48.0;\n\n\n    // let's assume we can do some simple things\n\n    const sampleRate = 44100;\n    const channels = 2;\n    const trackLengthMs = trackLength * timePerHydrogen;\n    const trackLengthSamples = trackLengthMs * sampleRate / 1000.0;\n    const totalSamples = Math.floor(trackLengthSamples);\n    const samplesPerHydrogen = Math.floor( totalSamples / trackLength );\n    const combined = context.createBuffer(channels, totalSamples, sampleRate);\n\n    // populate blank buffer with sounds\n    for (let channel = 0; channel < combined.numberOfChannels; channel++) {\n      let combinedChannel = combined.getChannelData(channel);\n      for(const [id,t] of Object.entries(tracks))\n      { \n        // the lookup and iteration shouldn't look like this\n        const selected =  instrumentIndex.filter(inst => inst.id.toString() === id);\n        if( \n          selected.length > 0 \n          && selected[0].id in sounds\n          && !t.empty()\n        )\n        {\n          const audioBuffer = sounds[selected[0].id];\n          // fallback to copying the mono buffer across both channels\n          const audioChannel = audioBuffer.numberOfChannels === 2 ? audioBuffer.getChannelData(channel) : audioBuffer.getChannelData(0);\n          const trackPoints = t.toPoints();\n          for( const noteStart of trackPoints )\n          {\n            const sampleStart = noteStart * samplesPerHydrogen;\n            // console.log(\"inserting sample at \" + sampleStart * (trackLengthBeats/trackLengthSamples));\n            for( let sample = 0; sample < audioBuffer.length; ++sample )\n            {\n              // add sample to mega track\n              combinedChannel[sampleStart + sample] = combinedChannel[sampleStart + sample] + audioChannel[sample];\n            }\n          }\n        }\n      }\n    }\n\n    return Audio.normalizeAudioBuffer( combined );\n  }\n\n  static createAudioSource(context, buffer)\n  {\n    var source = context.createBufferSource();\n    // set the buffer in the AudioBufferSourceNode\n    source.buffer = buffer;\n    source.loop=true;\n    // connect the AudioBufferSourceNode to the\n    // destination so we can hear the sound\n    source.connect(context.destination);\n    return source;\n  }\n}\n\nexport default Audio;","class AudioRequest {\n  static make(url) {\n    // Create new promise with the Promise() constructor;\n    // This has as its argument a function\n    // with two parameters, resolve and reject\n    return new Promise(function(resolve, reject) {\n      // Standard XHR \n      var request = new XMLHttpRequest();\n      request.open('GET', url);\n      request.responseType = \"arraybuffer\";\n      // When the request loads, check whether it was successful\n      request.onload = function() {\n        if (request.status === 200) {\n        // If successful, resolve the promise by passing back the request response\n          resolve(request.response);\n        } else {\n        // If it fails, reject the promise with a error message\n          reject(Error('Buffer didn\\'t load successfully; error code:' + request.statusText));\n        }\n      };\n      request.onerror = function() {\n      // Also deal with the case when the entire request fails to begin with\n      // This is probably a network error, so reject the promise with an appropriate message\n          reject(Error('There was a network error.'));\n      };\n      // Send the request\n      request.send();\n    });\n  }\n\n  static parse(context, response)\n  {\n    return new Promise(function(resolve,reject) {\n      // Asynchronously decode the audio file data in request.response\n      context.decodeAudioData(\n        response,\n        (buffer) => { \n          if(buffer){ resolve(buffer); }\n          else{ reject( \"buffer null\" ); }\n        },\n        (err) => { reject(err); }\n      );\n    });\n  }\n};\n\nexport default AudioRequest;","import React from 'react';\nimport Audio from \"./Audio\"\nimport AudioRequest from \"./AudioRequest\";\n\nimport IconButton from '@material-ui/core/IconButton';\nimport PlayArrowIcon from '@material-ui/icons/PlayArrow';\nimport StopIcon from '@material-ui/icons/Stop';\n\n// these are the hydrogen drumkits available by GPL/CC\n\nconst DRUMKITS = [\n  \"circAfrique v4\",\n  \"DeathMetal\",\n  \"The Black Pearl 1.0\",\n  \"GMRockKit\",\n  \"TR808EmulationKit\"\n];\n\n// TODO: This is very much not a react component, as it stands\n//   \n\nclass SoundBoard extends React.Component\n{\n\n  constructor(props) {\n    super(props);\n    this.state = {\n      audioBuffer : null,\n      audioSource : null,\n      soundsPopulated : false\n    }\n    this.sounds = {};\n  }\n\n  populateSounds()\n  {\n    let collatedPromises = []; \n    for(const [id,] of Object.entries(this.props.tracks))\n    {\n      const selected = this.props.instrumentIndex.filter(inst => inst.id.toString() === id);\n      if( selected.length > 0)\n      {\n        const selected_instrument = selected[0];\n        // todo: many hydrogen drumkits are unsupported\n        //       we should fallback to sensible defaults when the drumkit is not available\n        //       rules for {tom, stick, shaker, kick, bass}\n        if( \n          \"drumkit\" in selected_instrument && \n          \"filename\" in selected_instrument &&\n          DRUMKITS.includes(selected_instrument.drumkit) )\n        {\n\n          const filename = selected_instrument.filename.replace(\".flac\", \".wav\");\n          if(!(selected_instrument.id in this.sounds))\n          {\n            const dest_url = process.env.PUBLIC_URL + \"/wav/\" + selected_instrument.drumkit + \"/\" + filename;\n            const actx = Audio.context;\n            let sounds = this.sounds;\n            collatedPromises.push( \n              AudioRequest.make( dest_url )\n              .then( (response) =>{ return AudioRequest.parse(actx, response); } )\n              .then( (buffer) => { sounds[selected_instrument.id] = buffer } )\n              .catch( (fail) => { console.log(fail); })\n            );\n          }\n        }\n      }\n    }\n\n    const sounds = this.sounds;\n    const instrumentIndex = this.props.instrumentIndex;\n    const tracks = this.props.tracks;\n    let board = this;\n\n    Promise.all(collatedPromises).then( () => {\n      const b = Audio.createMasterTrack(\n        Audio.context,\n        tracks,\n        instrumentIndex,\n        sounds,\n        100 // hardcoded tempo\n      );\n\n      // todo: this could happen before componentDidMount!!\n      board.setState( { \n        audioBuffer : b, \n        resolution : Audio.determineMinResolution(instrumentIndex, tracks ),\n        length : Audio.determineTrackLength(instrumentIndex, tracks ),\n        soundsPopulated : true \n      } );\n    });\n  }\n\n  stop()\n  {\n    // if playing, stop\n    if(this.state.audioSource){\n      this.state.audioSource.stop(); \n      if( this.timeoutID != null )\n      {\n        clearTimeout(this.timeoutID);\n        this.timeoutID = null;\n      }\n      this.playPos = 0;\n      this.setState( { audioSource : null } );\n    }\n  }\n\n  componentDidUpdate(prevProps, prevState, snapshot)\n  {\n    // todo: this is a bit fishy, what is this comparison exactly?\n    const tracksAreDifferent = prevProps.tracks != this.props.tracks;\n    if( tracksAreDifferent )\n    {\n      this.stop();\n    }\n\n    if( tracksAreDifferent && this.state.soundsPopulated)\n    {\n      // if( !this.state.soundsPopulated ) then we already have a task in flight to do this\n      const b = Audio.createMasterTrack(\n        Audio.context,\n        this.props.tracks,\n        this.props.instrumentIndex,\n        this.sounds,\n        100 // hardcoded tempo\n      );\n\n      this.setState({\n        audioBuffer: b,\n        resolution : Audio.determineMinResolution(this.props.instrumentIndex, this.props.tracks ),\n        length : Audio.determineTrackLength(this.props.instrumentIndex, this.props.tracks )\n      });\n\n      // we were playing\n      if( prevState.audioSource )\n      {\n        this.playBuffer( b );\n      }\n    }\n  }\n\n  componentDidMount()\n  {\n    this.populateSounds();\n  }\n\n  playBuffer( b )\n  {\n\n    const source = Audio.createAudioSource( Audio.context, b );\n\n    // kick it off immediately\n    source.start();\n    this.startTime = Audio.context.currentTime;\n\n\n    const tempo = 100.0;\n    const beatTime =  (60.0 / tempo) / 4.0;\n\n    \n    const updatePlayPos = () => {\n      const currentTime = Audio.context.currentTime;\n      const playPos = ( ( currentTime - this.startTime )  / this.state.audioBuffer.duration ) % 1.0;\n\n      const beatCount = ( currentTime - this.startTime ) / beatTime;\n      const currentBeat = Math.round(beatCount);\n      const nextBeatTime = this.startTime + beatTime * ( currentBeat + 1 );\n\n      this.timeoutID = setTimeout(\n        updatePlayPos,\n        Math.floor( ( nextBeatTime - Audio.context.currentTime ) * 1000 )\n      );\n      if( this.props.onPlaybackPositionChange  )\n      {\n        this.props.onPlaybackPositionChange( playPos );\n      }\n    };\n\n    if( this.props.onPlaybackPositionChange )\n    {\n      updatePlayPos();\n    }\n    \n    this.setState( { audioSource : source} );\n  }\n  \n\n  render() {\n\n    const play = (e) => {\n      // if not playing, but buffer is ready\n      if(!this.state.audioSource && this.state.audioBuffer)\n      {\n        this.playBuffer(this.state.audioBuffer);\n      }\n    };\n\n    return (\n      <React.Fragment>\n        <div>\n          <IconButton\n            color=\"primary\"\n            aria-label=\"play\"\n            onClick={play}\n          >\n            <PlayArrowIcon />\n          </IconButton>\n\n          <IconButton\n            color=\"secondary\"\n            aria-label=\"stop\"\n            onClick={(e)=>{this.stop();}}\n          >\n            <StopIcon />\n          </IconButton>\n        </div>\n      </React.Fragment>\n   );\n  }\n};\n\nexport default SoundBoard;","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' },\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n","const DEFAULT_INSTRUMENT_SYMBOLS = {\n  \"Djembe Slap\" : \"S\",\n  \"Djembe Tone\" : \"t\",\n  \"Djembe Bass\" : \"O\",\n  \"Snare Ghost\" : \"-\",\n  \"Snare Accent\" : \"X\",\n  \"Shaker Ghost\" : \"x\",\n  \"Shaker Accent\" : \"X\",\n  \"Click\" : \"X\",\n  \"Bass\" : \"O\",\n  \"Tom\" : \"O\",\n  \"Default\" : \"X\"\n};\n\nfunction normalizeInstrumentsForFiguring(instruments)\n{\n  let n = [];\n  for(const inst of instruments)\n  {\n    let nInst = Object.assign({}, inst);\n    // for some reason these instruments are one-size arrays, and one id ... the track id from hydrogen\n    // this should be fixed, this doesn't make sense\n    nInst.name = nInst.name[0].toLowerCase();\n    n.push( nInst );\n  }\n  return n;\n}\n\nfunction figureDjembes(instrumentsRaw, symbolConfig)\n{\n  const instruments = normalizeInstrumentsForFiguring(instrumentsRaw);\n  const djembeTracks = instruments.filter( (inst) => inst.name.includes(\"djembe\") );\n  if(djembeTracks.length === 0)\n  {\n    return [];\n  }\n  else if(djembeTracks.length <= 3)\n  {\n    // let's lazily assume we have a slap, tone, bass\n    const slapArray = Array.from( djembeTracks, (inst) => inst.name.includes(\"slap\") );\n    const toneArray = Array.from( djembeTracks, (inst) => inst.name.includes(\"tone\") );\n    const bassArray = Array.from( djembeTracks, (inst) => inst.name.includes(\"bass\") );\n    for( let i = 0; i < djembeTracks.length; ++i )\n    {\n      let parityCheck = slapArray[i] + toneArray[i] + bassArray[i];\n      // failed to figure out how djembes work return empty array\n      if(parityCheck !== 1)\n      {\n        return [];\n      }\n    }\n    let djembeMapping = {};\n    for( let i = 0; i < djembeTracks.length; ++i )\n    {\n      if( slapArray[i] )\n      {\n        djembeMapping[ djembeTracks[i].id.toString() ] = symbolConfig[\"Djembe Slap\"];\n      }\n      else if( toneArray[i] )\n      {\n        djembeMapping[ djembeTracks[i].id.toString() ] = symbolConfig[\"Djembe Tone\"];\n      }\n      else if( bassArray[i] )\n      {\n        djembeMapping[ djembeTracks[i].id.toString() ] = symbolConfig[\"Djembe Bass\"];\n      }\n    }\n    return [ [ \"Djembe\", djembeMapping ] ];\n  }\n  else\n  {\n    // TODO: support more than one djembe\n    return []\n  }\n}\n\n// used by snare/shaker\nfunction manageAccentOrGhost(instrumentTracks, instrumentName, accentSymbol, ghostSymbol)\n{\n  let outputInstruments = [];\n  if(instrumentTracks.length === 2)\n  {\n    const t0 = instrumentTracks[0];\n    const t1 = instrumentTracks[1];\n    // attempt to determine ghost/accent\n    const zeroLouder = t0.volume > t1.volume || (t0.volume === t1.volume && t0.gain > t1.gain);\n    let mapping = {};\n    mapping[ t0.id.toString() ] = zeroLouder ? accentSymbol : ghostSymbol;\n    mapping[ t1.id.toString() ] = zeroLouder ? ghostSymbol : accentSymbol;\n    outputInstruments.push([instrumentName, mapping] );  \n  }\n  else // if 1 it must be an accent, if >= 3 ... I don't want to try and assign ghosts/accents\n  {\n    // I don't want to support ghost/accent here right now\n    for( const track of instrumentTracks )\n    {\n      let mapping = {};\n      mapping[ track.id.toString() ] = accentSymbol;\n      outputInstruments.push([instrumentName, mapping] );  \n    }\n  }\n  return outputInstruments;\n\n}\n\nfunction figureShakers(instrumentsRaw, symbolConfig)\n{\n  const instruments = normalizeInstrumentsForFiguring(instrumentsRaw);\n  // todo: support common alternative shakers? Tambourine?\n  const shakerTracks = instruments.filter( (inst) => ( inst.name.includes(\"shaker\") ) );\n  return manageAccentOrGhost( \n    shakerTracks, \n    \"Shaker\", \n    symbolConfig[\"Shaker Accent\"],\n    symbolConfig[\"Shaker Ghost\"]\n  );\n}\n\nfunction figureSnares(instrumentsRaw, symbolConfig)\n{\n  const instruments = normalizeInstrumentsForFiguring(instrumentsRaw);\n  const snareTracks = instruments.filter( (inst) => ( inst.name.includes(\"snare\") ) );\n  // todo: we currently assume 2 snares is accent/ghost ... but I think it's relatively\n  // common to be 2 snare parts too, I think the algorithm here is check patterns to\n  // see if they overlap ... if the \"ghosts\" overlap the \"hits\" sometimes, assume 2 parts\n  return manageAccentOrGhost( \n    snareTracks, \n    \"Snare\", \n    symbolConfig[\"Snare Accent\"],\n    symbolConfig[\"Snare Ghost\"]\n  );\n}\n\n\nfunction activeInstruments(patterns)\n{\n  let nonTrivialInstruments = new Set();\n  for( const p of patterns )\n  {\n    for(const [instrumentID, part] of Object.entries(p.instrumentTracks))\n    {\n      if( !part.empty() )\n      {\n        nonTrivialInstruments.add(parseInt(instrumentID));\n      }\n    }\n  }\n  return nonTrivialInstruments;\n}\n\nfunction activeInstrumentation(instrumentIndex, patterns)\n{\n  const active = activeInstruments(patterns);\n  let nonTrivialInstruments = [];\n  for( const inst of instrumentIndex)\n  {\n    if( active.has(inst.id) )\n    {\n      nonTrivialInstruments.push( inst );\n    }\n  }\n  return nonTrivialInstruments;\n}\n\nfunction figureClickyInstruments(instrumentsRaw, symbolConfig, patterns)\n{\n  const instruments = normalizeInstrumentsForFiguring(instrumentsRaw);\n  const worthwhileInstruments = activeInstruments(patterns);\n  const relevantTracks = instruments.filter( (inst) => ( worthwhileInstruments.has(inst.id) &&\n    !inst.name.includes(\"djembe\") &&\n    ( inst.name.includes(\"click\") || \n    inst.name.includes(\"stick\") || \n    inst.name.includes(\"tom\") || \n    inst.name.includes(\"bass\") ||\n    inst.name.includes(\"kick\") )\n  ) );\n\n  const trackIsClick = Array.from(\n    relevantTracks,\n    (t) => t.name.includes(\"click\") || t.name.includes(\"stick\")\n  );\n  // we rioritise the early tracks\n  // and hope for the best\n\n  let collated = [];\n  for( let candidate = 0; candidate < Math.floor(relevantTracks.length/2); ++candidate )\n  {\n    if( trackIsClick[candidate*2] !== trackIsClick[candidate*2+1] )\n    {\n      const clickTrack = trackIsClick[candidate*2] ? relevantTracks[candidate*2] : relevantTracks[candidate*2+1];\n      const hitTrack = trackIsClick[candidate*2] ? relevantTracks[candidate*2+1] : relevantTracks[candidate*2];\n      const instrumentIsTom = hitTrack.name.includes(\"tom\");\n      const instrumentName = instrumentIsTom ? \"Tom\" : \"Bass\";\n      let mapping = {};\n      mapping[hitTrack.id.toString()] = symbolConfig[instrumentName];\n      mapping[clickTrack.id.toString()] = symbolConfig[\"Click\"];\n      collated.push([instrumentName, mapping] );  \n    }\n  }\n\n  // If there's a remainder instrument and there's no click\n  if( ((relevantTracks.length % 2 ) !== 0) && !trackIsClick[ relevantTracks.length - 1 ] )\n  {\n    const lastTrack = relevantTracks[relevantTracks.length - 1];\n    const instrumentName = lastTrack.name.includes(\"tom\") ? \"Tom\" : \"Bass\";\n    let mapping = {};\n    mapping[lastTrack.id.toString()] = symbolConfig[instrumentName];\n    collated.push([instrumentName, mapping] );  \n  }\n\n  return collated;\n}\n\nfunction figureInstruments(instrumentsRaw, symbolConfig, patterns)\n{\n  let output = [];\n  output = output.concat( figureClickyInstruments( instrumentsRaw, symbolConfig, patterns ) );\n  output = output.concat( figureDjembes( instrumentsRaw, symbolConfig ) );\n  output = output.concat( figureSnares( instrumentsRaw, symbolConfig ) );\n  output = output.concat( figureShakers( instrumentsRaw, symbolConfig ) );\n\n  // we ignore track used by multiple instruments\n\n  // but attempt to cover \"instrument not recognised anywhere\"\n\n  const worthwhileInstruments = activeInstruments(patterns);\n\n  for(const inst of instrumentsRaw)\n  {\n    if( !worthwhileInstruments.has(inst.id) )\n    {\n      continue;\n    }\n    let instrumentUsed = false;\n    for( const op of output)\n    {\n      if( inst.id.toString() in op[1] ) \n      {\n        instrumentUsed = true;\n      }\n    }\n    if(instrumentUsed === false)\n    {\n      let mapping = {};\n      mapping[ inst.id.toString() ] = symbolConfig[\"Default\"];\n      output.push( [inst.name[0], mapping] );\n    }\n  }\n  \n  return output; \n}\n\nexport { activeInstrumentation, DEFAULT_INSTRUMENT_SYMBOLS, figureClickyInstruments, figureDjembes, figureShakers, figureSnares, figureInstruments };","\nclass notation\n{\n\n  static DEFAULT_FORMAT_CONFIG = {\n    \"restMark\" : \"-\",\n    \"beatMark\" : \"|\",\n    \"lineMark\" : \"|\",\n    \"numberRestMark\" : \"-\",\n    \"beatResolution\" : 48,\n    \"showBeatMark\" : true,\n    \"showBeatNumbers\" : true,\n    // lineResolution needs to be determined on a per-pattern-basis \n    // so let's just not cut the lines apart, by default\n    \"lineResolution\" : 48 * 16\n  };\n\n  static FORMAT_CONFIG_STRINGS = [\n    [\"restMark\",[\"-\", \".\", \" \"]],\n    [\"numberRestMark\",[\"-\", \".\", \" \"]],\n    [\"beatResolution\",[\"24\", \"48\", \"96\"]]\n  ];\n\n  static FORMAT_CONFIG_BOOLS = [\n    \"showBeatMark\",\n    \"showBeatNumbers\"\n  ];\n\n  static validateConfig(config, patternResolution) {\n    if( patternResolution != null && ( config.beatResolution % patternResolution ) !== 0 )\n    {\n      throw new Error(\"patternResolution doesn't divide beatResolution\");\n    }\n    if( config.lineResolution <= 0 )\n    {\n      throw new Error(\"config.lineResolution doesn't divide patternResolution\");\n    }\n  }\n\n  static chunkString(str, chunkSize) {\n    if( chunkSize <= 0 )\n    {\n      throw new Error(\"chunkSize must be > 0\")\n    }\n    return str.match(new RegExp('.{1,' + chunkSize + '}', 'g'));\n  }\n\n  static createNumberMarker(config, patternResolution, patternSize)\n  {\n    if( patternResolution <= 0 || patternSize <= 0 )\n    {\n      throw new Error(\"(patternResolution, patternSize) arguments <= 0\");\n    }\n    if( ( patternSize % patternResolution) !== 0 )\n    {\n      throw new Error(\"patternSize,doesn't divide patternResolution\");\n    }\n\n    notation.validateConfig(config, patternResolution);\n\n    // note, this assumes that each line makes this match evenly\n    // but ... there's nothing you can do in that case really unless you take an array of lineResolutions\n    const lineLength = Math.min(patternSize, config.lineResolution);\n    let beatCount = Math.ceil(lineLength / config.beatResolution);\n\n    let numberMarkerArray = Array.from( Array(lineLength / patternResolution), e => config.numberRestMark );\n\n    for( let beat = 0; beat < beatCount; beat++ )\n    {\n      numberMarkerArray[ beat * ( config.beatResolution / patternResolution ) ] = ( (beat+1) % 10 ).toString();\n    }\n    return numberMarkerArray.join(\"\");\n  }\n\n  static formatLineWithMarkers(config, line, patternResolution, asHTML)\n  {\n    notation.validateConfig(config);\n\n    const beatChunkSize = config.beatResolution / patternResolution;\n\n    const padZero = (n, width) => {\n      n = n + '';\n      return n.length >= width ? n : new Array(width - n.length + 1).join('0') + n;\n    };\n    const formatSymbolAsSpans = (symbol, numericPosition) => {\n      return \"<span class='note-\" + padZero(numericPosition, 4) + \"'>\" +  symbol + \"</span>\";\n    };\n\n    const formatSymbol = asHTML ? formatSymbolAsSpans : (symbol, numericPosition) => symbol;\n\n    let formattedLine = \"\";\n    for( let index = 0; index < line.length; ++ index )\n    {\n      const numericPosition = patternResolution * index;\n      formattedLine += formatSymbol(line.charAt(index), numericPosition);\n    }\n\n\n    const lineWithBeats = config.showBeatMark ? notation.chunkString(formattedLine, beatChunkSize * formatSymbol(\"X\", 0).length).join(config.beatMark) : formattedLine;\n    // note: we choose to always show the lineMarker even if it doesn't match the line resolution\n    return config.lineMark + lineWithBeats + config.lineMark;\n  }\n\n  static fromInstrumentAndTrack(\n    instrument,\n    trackDict,\n    asHTML,\n    formatConfig = {},\n    activeNote = null\n  )\n  {\n    for( const propName of Object.keys(formatConfig))\n    {\n      if(!notation.DEFAULT_FORMAT_CONFIG.hasOwnProperty(propName))\n      {\n        throw new Error(\"passed unrecognised property \" + propName);\n      }\n    }\n\n    let config = Object.assign( Object.assign({}, notation.DEFAULT_FORMAT_CONFIG), formatConfig );\n\n    let instrumentTracks = Object.values(trackDict);\n    if(instrumentTracks.length === 0)\n    {\n      return \"\";\n    }\n\n    // turn the tracks, into one char string\n\n    const patternSize = instrumentTracks[0].length();\n    const patternResolution = instrumentTracks[0].resolution;\n    const notationLength = instrumentTracks[0].length() / instrumentTracks[0].resolution;\n    // we only format tracks to the correct resolution\n    let patternArray = Array(notationLength).fill(config.restMark);\n    for( let charIndex = 0; charIndex < patternArray.length; ++charIndex)\n    {\n      // todo: handle collisions\n      for( const [trackID, trackSymbol] of Object.entries(instrument) )\n      {\n        const trackInstance = trackDict[trackID];\n        if( trackInstance != null && trackInstance.rep[charIndex] === 1 )\n        {\n          patternArray[charIndex] = trackSymbol;\n        }\n      }\n    }\n    const patternString = patternArray.join(\"\");\n\n    // handle lines and beatMarkers\n    let lineArray = notation.chunkString( patternString, config.lineResolution / patternResolution );\n\n    let formattedLineArray = [];\n    // add numbers on the first line\n    if( config.showBeatNumbers )\n    {\n      formattedLineArray.push( notation.formatLineWithMarkers( \n        config, \n        notation.createNumberMarker(config, patternResolution, patternSize), \n        patternResolution,\n        asHTML\n      ) );\n    }\n    for( let i = 0; i < lineArray.length; ++i )\n    {\n      formattedLineArray.push( notation.formatLineWithMarkers( config, lineArray[i], patternResolution, asHTML ) );\n    }\n\n    return formattedLineArray.join(\"\\n\");\n  }\n};\n\nexport default notation;","import React from 'react';\nimport { makeStyles } from '@material-ui/core/styles';\nimport FormControlLabel from '@material-ui/core/FormControlLabel';\nimport Checkbox from '@material-ui/core/Checkbox';\n\n// table\nimport Table from '@material-ui/core/Table';\nimport TableBody from '@material-ui/core/TableBody';\nimport TableCell from '@material-ui/core/TableCell';\nimport TableContainer from '@material-ui/core/TableContainer';\nimport TableHead from '@material-ui/core/TableHead';\nimport TableRow from '@material-ui/core/TableRow';\n\nimport AddBoxIcon from '@material-ui/icons/AddBox';\nimport EditIcon from '@material-ui/icons/Edit';\nimport Button from '@material-ui/core/Button';\nimport IconButton from '@material-ui/core/IconButton';\nimport ClearIcon from '@material-ui/icons/Clear';\n\nimport TextField from '@material-ui/core/TextField';\nimport Dialog from '@material-ui/core/Dialog';\nimport DialogActions from '@material-ui/core/DialogActions';\nimport DialogContent from '@material-ui/core/DialogContent';\nimport DialogContentText from '@material-ui/core/DialogContentText';\nimport DialogTitle from '@material-ui/core/DialogTitle';\nimport { withStyles } from '@material-ui/core/styles';\nimport Typography from '@material-ui/core/Typography';\n\nconst useStyles = makeStyles((theme) => ({\n  root: {\n    display: 'flex',\n  }\n}));\n\nconst ThinFormControlLabel = withStyles({\n  root: {\n    marginLeft: 0,\n    marginRight: 0\n  }\n})(FormControlLabel);\n\nconst InlinableIconButton = withStyles({\n  root: {\n    padding: 2\n  }\n})(IconButton);\n\nconst CenterTableCell = withStyles({\n  root: {\n    textAlign: \"center\"\n  }\n})(TableCell);\n\nfunction InstrumentConfig(props) {\n  const classes = useStyles();\n\n  const handleChange = (x,y, event) => {\n    const instrumentID = props.instrumentIndex[x].id;\n    const oldInstrumentIndex = props.instruments.findIndex( instrument => instrumentID in instrument[1]);\n    const dstInstrumentIndex = y;\n    if( oldInstrumentIndex === dstInstrumentIndex )\n    {\n      return;\n    }\n    const oldInstrument = props.instruments[oldInstrumentIndex];\n    let replacedSrcInstrument = [\n      \"\",\n      {}\n    ];\n    if( oldInstrument != null )\n    {\n      replacedSrcInstrument[0] = oldInstrument[0];\n      for( const key of Object.keys(oldInstrument[1]) )\n      {\n        if( key !== instrumentID.toString() )\n        {\n          replacedSrcInstrument[1][key] = oldInstrument[1][key];\n        }\n      }\n    }\n    let dstInstrument = [\n      props.instruments[dstInstrumentIndex][0],\n      Object.assign({}, props.instruments[dstInstrumentIndex][1] )\n    ];\n    if(oldInstrument != null )\n    {\n      dstInstrument[1][instrumentID.toString()] = oldInstrument[1][instrumentID];\n    }\n    else\n    {\n      dstInstrument[1][instrumentID.toString()] = \"X\";\n    }\n\n    let replacedInstruments = [];\n\n    for(let instrumentIndex = 0; instrumentIndex < props.instruments.length; ++instrumentIndex)\n    {\n      if( instrumentIndex === oldInstrumentIndex )\n      {\n        replacedInstruments.push( replacedSrcInstrument );\n      }\n      else if( instrumentIndex === dstInstrumentIndex )\n      {\n        replacedInstruments.push( dstInstrument )\n      }\n      else\n      {\n        replacedInstruments.push( props.instruments[instrumentIndex] );\n      }\n    }\n    props.onChange(replacedInstruments);\n  };\n\n  const removeInstrument = (y) => \n  {\n    let replacedInstruments = props.instruments.slice(0,y).concat(props.instruments.slice(y+1));\n    props.onChange(replacedInstruments);\n  };\n\n  const [renamingInstrument, setRenamingInstrument] = React.useState(-1);\n  let [nameState, setNameState] = React.useState(\"\");\n\n  const createCell = (x,y) =>\n  {\n      return ( \n        <TableCell\n          align=\"center\"\n        >\n        <ThinFormControlLabel\n          control={<Checkbox checked={props.instrumentMask[x] === y} onChange={(e) => handleChange(x,y,e)} name={x + \",\" + y.toString()} />}\n        />\n        </TableCell>\n      );\n  }\n\n  const createMatchingRow = (y) =>\n  {\n    return (\n      <TableRow>\n        <TableCell component=\"th\" scope=\"row\">\n          <Typography>{props.instruments[y][0]}</Typography>\n          <InlinableIconButton onClick={(e)=>setRenamingInstrument(y)}><EditIcon fontSize=\"small\"/></InlinableIconButton>\n          <InlinableIconButton onClick={(e)=>{removeInstrument(y);}}><ClearIcon fontSize=\"small\"/></InlinableIconButton>\n        </TableCell>\n        {[...Array(props.instrumentIndex.length).keys()].map(x=>createCell(x,y))}\n      </TableRow>\n    );\n  };\n\n  const createEditRow = () =>\n  {\n    return (\n      <TableRow>\n        <TableCell component=\"th\" scope=\"row\"><IconButton onClick={(e)=>setRenamingInstrument(props.instruments.length)} aria-label=\"add\"><AddBoxIcon/></IconButton></TableCell>\n      </TableRow>\n    );\n  };\n\n  const renameInstrument = (e)  => \n  {\n    const instrumentName = nameState.trim();\n    if( instrumentName.length > 0 )\n    {\n      if( renamingInstrument === props.instruments.length )\n      {\n        const extraInstrument = [ instrumentName, {} ];\n        let replacedInstruments = Array.from( props.instruments );\n        replacedInstruments.push(extraInstrument);\n        props.onChange(replacedInstruments);\n      }\n      else\n      {\n        let replacedInstruments = Array.from( props.instruments );\n        replacedInstruments[renamingInstrument][0] = instrumentName;\n        props.onChange(replacedInstruments);\n      }\n    }\n    // we just ignore empty string\n    setRenamingInstrument(-1);\n    setNameState(\"\");\n  };\n\n  // todo: The text field is very slow\n  // that could be because the dialog and the table content are all one component\n  // I should try and fix that first\n  // otherwise, it's just that shoving react in the middle is too slow\n\n  const [editSymbol, setEditSymbol] = React.useState(-1);\n  let [editSymbolState, setEditSymbolState] = React.useState(\"\");\n\n  const startEditingSymbol = (x) =>\n  {\n    const instrumentID = props.instrumentIndex[x].id;\n    const instrumentIndex = props.instruments.findIndex( instrument => instrumentID in instrument[1]);\n    const currentSymbol = props.instruments[instrumentIndex][1][instrumentID];\n    setEditSymbolState(currentSymbol);\n    setEditSymbol(x);\n  };\n\n  const changeSymbol = (e) =>\n  {\n    const updatedSymbol = editSymbolState;\n    if(updatedSymbol.length===1)\n    {\n      const instrumentID = props.instrumentIndex[editSymbol].id;\n      const instrumentIndex = props.instruments.findIndex( instrument => instrumentID in instrument[1]);\n      let replacedInstruments = Array.from(props.instruments);\n      replacedInstruments[instrumentIndex][1][instrumentID] = editSymbolState;\n      props.onChange(replacedInstruments);\n    }\n    else\n    {\n      // todo: prettier error communication?\n      alert(\n        \"You selected an invalid symbol \\\"\" + updatedSymbol + \"\\\".\\n\" + \n        \"Symbols must be precisely 1 character.\"\n      );\n    }\n    setEditSymbol(-1);\n  };\n\n  return (\n    <React.Fragment>\n      <Dialog open={renamingInstrument >= 0} onClose={(e)=>setRenamingInstrument(-1)} aria-labelledby=\"form-dialog-title\">\n        <DialogTitle id=\"form-dialog-title\"></DialogTitle>\n        <DialogContent>\n          <DialogContentText>\n            Enter instrument name\n          </DialogContentText>\n          <TextField\n            autoFocus\n            margin=\"dense\"\n            id=\"name\"\n            fullWidth\n            value={nameState}\n            onChange={(e)=>setNameState(e.target.value)}\n          />\n        </DialogContent>\n        <DialogActions>\n          <Button onClick={(e)=>setRenamingInstrument(-1)} color=\"primary\">\n            Cancel\n          </Button>\n          <Button onClick={renameInstrument} color=\"primary\">\n            Confirm\n          </Button>\n        </DialogActions>\n      </Dialog>\n      <Dialog open={editSymbol >= 0} onClose={(e)=>setEditSymbol(-1)} aria-labelledby=\"form-dialog-title\">\n        <DialogTitle id=\"form-dialog-title\"></DialogTitle>\n        <DialogContent>\n          <DialogContentText>\n            Enter notation symbol\n          </DialogContentText>\n          <TextField\n            autoFocus\n            margin=\"dense\"\n            id=\"name\"\n            fullWidth\n            value={editSymbolState}\n            onChange={(e)=>setEditSymbolState(e.target.value)}\n          />\n        </DialogContent>\n        <DialogActions>\n          <Button onClick={(e)=>setEditSymbol(-1)} color=\"primary\">\n            Cancel\n          </Button>\n          <Button onClick={changeSymbol} color=\"primary\">\n            Confirm\n          </Button>\n        </DialogActions>\n      </Dialog>\n      <TableContainer>\n        <Table className={classes.table} aria-label=\"simple table\">\n          <TableHead>\n            <TableRow>\n              <TableCell> Instrument </TableCell>\n              {[...Array(props.instrumentIndex.length).keys()].map(x=><CenterTableCell><Typography>{props.instrumentIndex[x].name}</Typography><InlinableIconButton onClick={(e)=>startEditingSymbol(x)} ><EditIcon fontSize=\"small\"/></InlinableIconButton></CenterTableCell>)}\n            </TableRow>\n          </TableHead>\n          <TableBody>\n            {[...Array(props.instruments.length).keys()].map(y=>createMatchingRow(y))}\n            {createEditRow()}\n          </TableBody>\n        </Table>\n      </TableContainer>\n    </React.Fragment>\n  );\n}\n\nfunction createInstrumentMask(instrumentIndex, instruments)\n{\n  let instrumentMask = Array(instrumentIndex.length);\n  for( let baseInstrumentIndex = 0; baseInstrumentIndex < instrumentIndex.length; ++baseInstrumentIndex )\n  {\n    const baseInstrumentId = instrumentIndex[baseInstrumentIndex].id;\n    for( let targetInstrumentIndex = 0; targetInstrumentIndex < instruments.length; ++targetInstrumentIndex)\n    {\n      const target = instruments[targetInstrumentIndex];\n      if(baseInstrumentId.toString() in target[1])\n      {\n        instrumentMask[baseInstrumentIndex] = targetInstrumentIndex;\n      }\n    }\n  }\n  return instrumentMask;\n}\n\nexport { createInstrumentMask, InstrumentConfig };","import { calculateResolution } from \"./utilities\"\n\n// stolen from https://studymaths.co.uk/topics/findingHCFWithJavaScript.php\nfunction findHCF(x, y) {\n\n   // If the input numbers are less than 1 return an error message.\n   if (x < 1 || y < 1) {\n    throw new Error(\"x<1 || y<1\");\n      // return \"Please enter values greater than zero.\";\n   }\n\n   // Now apply Euclid's algorithm to the two numbers.\n   while (Math.max(x, y) % Math.min(x, y) !== 0) {\n      if (x > y) {\n         x %= y;\n      }\n      else {\n         y %= x;\n      }\n   }\n   \n   // When the while loop finishes the minimum of x and y is the HCF.\n   return Math.min(x, y);\n}\n\nclass track\n{\n  \n  constructor(patternArray, resolution)\n  {\n    if(patternArray.length === 0)\n    {\n      throw new Error(\"patternArray must not be zero length\");\n    }\n    this.rep = patternArray;\n    this.resolution = resolution;\n  }\n\n  length()\n  {\n    return this.rep.length * this.resolution;\n  }\n\n  empty()\n  {\n    return this.rep.reduce( (a,b) => ( a + b ) ) === 0;\n  }\n\n  _sumOverlapsOfArrays(a,b)\n  {\n    let count = 0;\n    for( let i = 0; i < a.length; ++i)\n    {\n      if(a[i] && b[i])\n      {\n        count++;\n      }\n    }\n    return count;\n  }\n\n  countOverlaps(other)\n  {\n    if( this.resolution === other.resolution )\n    {\n      return this._sumOverlapsOfArrays( this.rep, other.rep );\n    }\n    else\n    {\n      const hcf = findHCF(this.resolution, other.resolution);\n      const a = this.formatResolution( hcf );\n      const b = other.formatResolution( hcf );\n      return this._sumOverlapsOfArrays( a.rep, b.rep );\n    }\n  }\n\n  static representPoints(points, resolution, size)\n  {\n    if( size <= 0 )\n    {\n      throw new Error(\"size must be greater than zero\");\n    }\n    if( size < resolution || (size % resolution) !== 0)\n    {\n      throw new Error(\"resolution must be less than size and divide it evenly\");\n    }\n    let s = new Array(size / resolution).fill(0);\n    for( const p of points )\n    {\n      if( (p % resolution) !== 0)\n      {\n        throw new Error(\"Failed to represent point \" + p.toString() + \" at resolution \" + resolution.toString());\n      }\n      if (p >= size)\n      {\n        throw new Error(\"Failed to represent point \" + p.toString() + \" for invalid specified size \" + size.toString());\n      }\n      const arrayIndex = p / resolution;\n      s[arrayIndex] = 1;\n    }\n    return s;\n  }\n\n  format(formatResolution)\n  {\n    // formatResolution must cleanly divide for every hit & the length of the pattern\n\n    const totalLength = (this.resolution * this.rep.length);\n    const points = this.toPoints();\n    const rep = track.representPoints(points, formatResolution, totalLength);\n    if(!rep)\n    {\n      return null;\n    }\n    return new track(\n      rep,\n      formatResolution\n    );\n  }\n\n  toPoints()\n  {\n    let points = [];\n    for( const arrayIndex of Array(this.rep.length).keys() )\n    {\n      const indicator = this.rep[arrayIndex];\n      if(indicator)\n      {\n        points.push( this.resolution * arrayIndex )\n      }\n    }\n    return points;\n  }\n\n  static fromPositions(positions, size, resolution = null)\n  {\n    const resolutionToUse = resolution ?? calculateResolution( positions, size );\n    return new track( \n      track.representPoints(positions, resolutionToUse, size), \n      resolutionToUse\n    );\n  }\n}\n\nexport default track;","// utilities.js\n\nfunction calculateResolution(positions, size)\n{\n  // hydrogen treats 48 as a beat\n  const basesToTry = [\n    48, // beat\n    24, // 1/2 beat\n    16, // 1/3 beat\n    12, // 1/4\n    8, // 1/6 \n    6, // 1/8\n    4, // 1/12\n    3, // 1/16\n    2, // 1/24\n    1 // 1/48\n  ];\n\n  // note that, fundamentally the size of the pattern is a \"keypoint\"\n  // that needs to be properly recorded by the resolution\n  const implicitPositions = positions.concat( [size] );\n\n  for( const b of basesToTry )\n  {\n    let allNotesPass = true;\n    for( const p of implicitPositions )\n    {\n      if( (p % b) !== 0 )\n      {\n        allNotesPass = false;\n        break;\n      }\n    }\n    if(allNotesPass)\n    {\n      return b;\n    }\n  }\n  throw new Error(\"Failed to predict base\");\n}\n\nexport { calculateResolution };"],"sourceRoot":""}