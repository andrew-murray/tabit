{"version":3,"sources":["formatSettings.js","App.js","FileImport.js","Pattern.js","h2.js","Audio.js","AudioRequest.js","SoundBoard.js","serviceWorker.js","index.js","notation.js","instrumentation.js","instrumentConfig.js","track.js","utilities.js"],"names":["useStyles","makeStyles","theme","formControl","margin","spacing","minWidth","selectEmpty","marginTop","camelToReadable","s","spacedString","replace","toUpperCase","slice","FormatSettings","props","classes","useTheme","tokenStateToItem","value","tokenItemToState","handleOptionChange","name","updatedState","settings","onChange","handleCheckedChange","event","target","checked","createOptionMenu","options","itemToState","stateToItem","idString","variant","className","key","id","labelId","e","map","op","lineLengths","resolution","beatResolution","push","length","beatResolutions","c","pattern","root","notation","FORMAT_CONFIG_STRINGS","reduce","prev","curr","FORMAT_CONFIG_BOOLS","control","label","style","backgroundColor","color","palette","background","default","v","toString","parseInt","b","r","DefaultSettings","DEFAULT_FORMAT_CONFIG","createMuiTheme","type","primary","main","secondary","App","state","instruments","instrumentIndex","instrumentMask","patterns","formatSettings","Object","assign","patternSettings","loadedFile","selectedPattern","settingsOpen","patternsOpen","progress","this","destFilename","fileParts","split","join","js","JSON","stringify","getExportState","blob","Blob","saveAs","Array","from","p","guessPerPatternSettings","instrumentTracks","file","includes","h2","parseHydrogenPromise","content","then","h","assessedInstruments","figureInstruments","DEFAULT_INSTRUMENT_SYMBOLS","activeInstrumentation","setState","createInstrumentMask","figurePatternSettings","catch","error","alert","createTracks","patternData","replacedTracks","entries","trackData","track","rep","patternWithTracks","Promise","resolve","parse","prevState","patternIndex","resolvedSettings","Fragment","tracks","config","active","k","createObjects","kuva","userAgent","navigator","vendor","window","opera","some","toMatchItem","match","trackLength","t","Math","max","min","optionalAlert","severity","onClick","loadExample","bind","onImport","handleFileImport","accept","position","bottom","href","patternToRender","patternConfig","patternContent","renderPattern","ignoreEvent","handleDrawerOpen","handleDrawerClose","handlePatternsClose","handlePatternsOpen","iOS","process","browser","test","mobile","checkMobile","patternDetails","getTrackLength","instrumentConfigColumns","display","width","aria-label","edge","clsx","hide","flexGrow","container","item","xs","disableBackdropTransition","disableDiscovery","drawer","undefined","open","onOpen","onClose","drawerHeader","drawerContainer","index","button","selectPattern","anchor","paper","drawerPaper","existingPatternSettings","existingGlobalSettings","save","mainContent","renderMainContent","React","Component","FileImport","hiddenFileInput","createRef","fileObject","files","reader","FileReader","onload","loadEvent","result","readAsText","buttonProps","current","click","hidden","ref","Pattern","configOverride","page","instrumentName","instrument","notationString","fromInstrumentAndTrack","x","formatText","dangerouslySetInnerHTML","withStyles","fontFamily","textAlign","whiteSpace","calculatePatternResolution","size","positions","notes","note","calculateResolution","parseHydrogenJs","instrumentElements","song","instrumentList","instrumentArray","element","instrumentComponent","inst","parseFloat","volume","isMuted","gain","drumkit","layer","filename","patternElements","patternList","patternArray","noteElements","noteList","patternSize","noteElement","filter","n","patternsWithTracks","relevantNotes","relevantHits","fromPositions","virtualPatternList","virtualPatternGroups","patternToRelated","virtualGroup","rootPatternName","relatedPatterns","virtual","Set","iteration","expandedObject","objectHasExpanded","related","expandedNodeSet","node","Error","relatedPatternSet","rootPattern","find","patternToMergeName","patternToMerge","merged","aggregate","copiedTrack","format","xmlString","a","parser","xml2js","Parser","parseStringPromise","Audio","AudioContext","webkitAudioContext","minResolution","empty","combined","peakValue","channel","numberOfChannels","combinedChannel","getChannelData","sample","abs","peakAmplitude","context","sounds","tempo","determineTrackLength","trackLengthSamples","totalSamples","floor","samplesPerHydrogen","createBuffer","selected","audioBuffer","audioChannel","trackPoints","toPoints","sampleStart","normalizeAudioBuffer","buffer","source","createBufferSource","loop","playbackRate","connect","destination","AudioRequest","url","reject","request","XMLHttpRequest","responseType","status","response","statusText","onerror","send","decodeAudioData","err","DRUMKITS","SoundBoard","audioSource","soundsPopulated","audioContext","drumkit_name","toLowerCase","createWebContext","collatedPromises","selected_instrument","dest_url","actx","make","fail","console","log","relativeUrl","chooseAppropriateUrlForInstrument","board","all","createMasterTrack","determineMinResolution","stop","timeoutID","clearTimeout","playPos","prevProps","snapshot","tracksAreDifferent","playBuffer","populateSounds","createAudioSource","start","startTime","currentTime","onPlaybackPositionChange","updatePlayPos","duration","beatCount","currentBeat","round","nextBeatTime","setTimeout","Slider","defaultValue","step","valueLabelDisplay","IconButton","Boolean","location","hostname","ReactDOM","render","StrictMode","document","getElementById","serviceWorker","ready","registration","unregister","message","patternResolution","lineResolution","str","chunkSize","RegExp","numberRestMark","lineLength","ceil","numberMarkerArray","beat","line","asHTML","validateConfig","beatChunkSize","formatSymbol","symbol","numericPosition","formattedLine","charAt","lineWithBeats","showBeatMark","chunkString","beatMark","lineMark","trackDict","values","defaultLineResolution","formatConfig","keys","propName","hasOwnProperty","notationLength","fill","restMark","charIndex","trackID","trackSymbol","trackInstance","patternString","lineArray","formattedLineArray","showBeatNumbers","formatLineWithMarkers","createNumberMarker","i","normalizeInstrumentsForFiguring","nInst","manageAccentOrGhost","accentSymbol","ghostSymbol","outputInstruments","t0","t1","zeroLouder","mapping","activeInstruments","nonTrivialInstruments","instrumentID","add","has","defaultSymbolForSingleInstrument","symbolConfig","lowerName","instrumentsRaw","output","concat","worthwhileInstruments","relevantTracks","trackIsClick","tomIndex","bassIndex","collated","candidate","clickTrack","hitTrack","instrumentIsTom","rawInstrumentName","lastTrack","figureClickyInstruments","djembeTracks","slapArray","toneArray","bassArray","djembeMapping","figureDjembes","figureSnares","figureShakers","instrumentUsed","ThinFormControlLabel","marginLeft","marginRight","FormControlLabel","InlinableIconButton","padding","CenterTableCell","TableCell","InstrumentConfig","useState","renamingInstrument","setRenamingInstrument","nameState","setNameState","createCell","y","align","oldInstrumentIndex","findIndex","dstInstrumentIndex","oldInstrument","replacedSrcInstrument","dstInstrument","replacedInstruments","handleChange","createMatchingRow","component","scope","fontSize","removeInstrument","editSymbol","setEditSymbol","editSymbolState","setEditSymbolState","aria-labelledby","autoFocus","fullWidth","trim","extraInstrument","updatedSymbol","table","currentSymbol","startEditingSymbol","baseInstrumentIndex","baseInstrumentId","targetInstrumentIndex","findHCF","count","other","_sumOverlapsOfArrays","hcf","formatResolution","pat","totalLength","points","representPoints","arrayIndex","resolutionToUse","implicitPositions","allNotesPass"],"mappings":"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","file":"static/js/main.470ce38b.chunk.js","sourcesContent":["import React from 'react';\nimport { makeStyles, useTheme } from '@material-ui/core/styles';\nimport InputLabel from '@material-ui/core/InputLabel';\nimport MenuItem from '@material-ui/core/MenuItem';\nimport FormControl from '@material-ui/core/FormControl';\nimport FormGroup from '@material-ui/core/FormGroup';\nimport FormControlLabel from '@material-ui/core/FormControlLabel';\nimport Switch from '@material-ui/core/Switch';\nimport Select from '@material-ui/core/Select';\nimport notation from \"./notation\";\n\nconst useStyles = makeStyles((theme) => ({\n  formControl: {\n    margin: theme.spacing(1),\n    minWidth: 120,\n  },\n  selectEmpty: {\n    marginTop: theme.spacing(2),\n  },\n}));\n\nfunction camelToReadable(s)\n{\n  const spacedString = s.replace(/([A-Z])/g, ' $1');\n  return spacedString[0].toUpperCase() + spacedString.slice(1);\n}\n\nfunction FormatSettings(props) {\n  const classes = useStyles(props);\n  const theme = useTheme();\n  // todo: change to multiple useState calls?\n\n  function tokenStateToItem(value)\n  {\n    return value === \" \" ? \"space\" : value;\n  }\n\n  function tokenItemToState(value)\n  {\n    return value === \"space\" ? \" \" : value;\n  }\n\n  const handleOptionChange = (name, value) => {\n    const updatedState = {...props.settings, [name]: value};\n    props.onChange(updatedState);\n  };\n\n  const handleCheckedChange = (event) => {\n    const updatedState = {...props.settings, [event.target.name]: event.target.checked};\n    props.onChange(updatedState);\n  };\n\n  function createOptionMenu(\n    name,\n    options,\n    itemToState = tokenItemToState,\n    stateToItem = tokenStateToItem\n  )\n  {\n    const idString = \"form-control-\" + name + \"-id\";\n    return (\n      <FormControl variant=\"filled\" className={classes.formControl} key={idString} id={idString}>\n        <InputLabel id=\"settings-option-{name}\">{name}</InputLabel>\n        <Select\n          labelId={\"settings-option-\" + name + \"-labelID\"}\n          id={\"settings-option-\" + name + \"-id\"}\n          value={stateToItem(props.settings[name])}\n          name={name}\n          onChange={(e) => handleOptionChange( e.target.name, itemToState(e.target.value))}\n        >\n          {options.map((op) => <MenuItem key={\"settings-menu-item-\" + name + \"-\" + op} value={stateToItem(op)}>{stateToItem(op)}</MenuItem>)}\n        </Select>\n      </FormControl>\n    );\n  };\n\n  function createBoolControl(name)\n  {\n    return (\n      <FormControlLabel\n        control={<Switch checked={props.settings[name]} onChange={handleCheckedChange} name={name} />}\n        label={camelToReadable(name)}\n        key={\"switch-\"+name}\n      />\n    );\n  };\n\n  const resolutionToBeatString = (r) => ( r / props.settings.beatResolution ).toString();\n  const beatStringToResolution = (b) => props.settings.beatResolution * parseInt(b);\n  \n  const candidateLineLengths = [ 2, 3, 4, 5, 6, 7, 8 ];\n  let lineLengths = [];\n  for( const c of candidateLineLengths )\n  {\n    const resolution = c * 48;\n    if( (resolution % props.settings.beatResolution) === 0 )\n    {\n      lineLengths.push( resolution );\n    }\n    // we permit one-over, in case that's useful for an \"uneven\" pattern\n    if(resolution > props.settings.length)\n    {\n      break;\n    }\n  }\n\n  const candidateBeatResolutions = [24, 48, 96];\n  let beatResolutions = [];\n  for( const c of candidateBeatResolutions )\n  {\n    if( (c % props.pattern.resolution) === 0 )\n    {\n      beatResolutions.push( c );\n    }\n  }\n  return (\n    <FormGroup className={classes.root}>\n      {notation.FORMAT_CONFIG_STRINGS.map( op => createOptionMenu( op[0], op[1] ) ).reduce((prev, curr) => [prev, curr])}\n      {notation.FORMAT_CONFIG_BOOLS.map( op => createBoolControl( op )).reduce((prev, curr) => [prev, curr]) }\n      <div style={{backgroundColor : \"white\", color : theme.palette.background.default}}><p> {props.pattern.name + \" Options\"} </p></div>\n      {\n        createOptionMenu(\n          \"beatResolution\",\n          beatResolutions,\n          (v) => v.toString(), // stateToItem\n          (v) => parseInt(v) // itemToState\n        )\n      }\n      {createOptionMenu(\n        \"lineResolution\",\n        lineLengths,\n        beatStringToResolution,\n        resolutionToBeatString\n      )}\n    </FormGroup>\n  );\n}\n\nconst DefaultSettings = notation.DEFAULT_FORMAT_CONFIG; \n\n\nexport { FormatSettings, DefaultSettings }\nexport default FormatSettings;","import React from 'react';\nimport clsx from 'clsx';\nimport FileImport from \"./FileImport\";\nimport Pattern from \"./Pattern\";\nimport h2 from './h2';\nimport './App.css';\n\nimport { Alert } from '@material-ui/lab';\n\n// define mui theme, including responsiveFont\nimport { createMuiTheme, ThemeProvider } from '@material-ui/core/styles';\n\n// drawer\nimport SwipeableDrawer from '@material-ui/core/SwipeableDrawer';\nimport CssBaseline from '@material-ui/core/CssBaseline';\nimport List from '@material-ui/core/List';\nimport ListItem from '@material-ui/core/ListItem';\nimport ListItemText from '@material-ui/core/ListItemText';\n\nimport IconButton from '@material-ui/core/IconButton';\nimport Button from '@material-ui/core/Button';\nimport MenuIcon from '@material-ui/icons/Menu';\nimport ChevronLeftIcon from \"@material-ui/icons/ChevronLeft\";\nimport ChevronRightIcon from \"@material-ui/icons/ChevronRight\";\nimport Divider from \"@material-ui/core/Divider\";\n\n// notationSettings\n\nimport {FormatSettings, DefaultSettings} from \"./formatSettings\";\nimport {createInstrumentMask, InstrumentConfig} from \"./instrumentConfig\";\nimport { activeInstrumentation, figureInstruments, DEFAULT_INSTRUMENT_SYMBOLS } from \"./instrumentation\";\nimport notation from \"./notation\";\n\nimport Grid from '@material-ui/core/Grid';\n\n// load static data\nimport kuva from \"./kuva.json\";\nimport track from \"./track\";\n\nimport { saveAs } from 'file-saver';\n\nimport SoundBoard from \"./SoundBoard\";\n// mui theme config\nlet theme = createMuiTheme( { \n  palette: { \n    type: 'dark',\n    primary: { main: '#36d9be' },\n    secondary: { main: '#f50057' }\n   } \n} );\n\nclass App extends React.Component\n{\n  constructor(props) {\n    super(props);\n    this.state = {\n      // data\n      instruments : null,\n      instrumentIndex : null,\n      instrumentMask : null,\n      patterns : null,\n      formatSettings : Object.assign({}, DefaultSettings),\n      patternSettings : [],\n      // ui state\n      loadedFile : null,\n      selectedPattern : null,\n      settingsOpen : false,\n      patternsOpen : false,\n      progress : null\n    };\n  }\n\n\n  getExportState()\n  {\n    return {\n      instruments : this.state.instruments,\n      instrumentIndex : this.state.instrumentIndex,\n      patterns : this.state.patterns,\n      formatSettings: this.state.formatSettings,\n      patternSettings : this.state.patternSettings\n    }\n  }\n\n  save()\n  {\n    let destFilename = \"download.tabit\";\n    if(this.state.loadedFile)\n    {\n      const fileParts = this.state.loadedFile.split(\".\");\n      if( fileParts.length === 1 )\n      {\n        destFilename = fileParts[0] + \".tabit\";\n      }\n      else\n      {\n        destFilename = fileParts.slice(0, fileParts.length - 1).join(\".\") + \".tabit\";\n      }\n    }\n\n    const js = JSON.stringify(this.getExportState(), null, 4);\n    const blob = new Blob([js], {type: \"application/json\"});\n    saveAs(blob, destFilename);\n  }\n\n  figurePatternSettings(patterns)\n  {\n    return Array.from(\n      patterns,\n      (p) => notation.guessPerPatternSettings( p.instrumentTracks )\n    );\n  }\n\n\n  handleFileImport(e)\n  {\n    if( e.file.name.includes(\"h2song\") )\n    {\n      // e = { file : , content : }\n      h2.parseHydrogenPromise(e.content).then(h => {\n        const assessedInstruments = figureInstruments(h.instruments, DEFAULT_INSTRUMENT_SYMBOLS, h.patterns);\n        const instrumentIndex = activeInstrumentation(h.instruments, h.patterns);\n        this.setState({\n          // data\n          instrumentIndex : instrumentIndex,\n          instrumentMask : createInstrumentMask(instrumentIndex, assessedInstruments),\n          instruments : assessedInstruments,\n          patterns : h.patterns,\n          patternSettings : this.figurePatternSettings(h.patterns),\n          // general app state\n          loadedFile : e.file.name,\n          patternsOpen : true,\n          selectedPattern : h.patterns.length === 0 ? null : 0,\n        });\n      }).catch( (error)=>{ alert(\"Failed to load file \" + e.file.name  + \" with error \" + error); } );\n    }\n    else\n    {\n\n      const createTracks = (patternData) => \n      {\n        // the instruments currently work as simple objects\n        // we need to create tracks!\n        let patterns = [];\n        for( let pattern of patternData )\n        {\n          let replacedTracks = {};\n          // todo: find a more compact way of doing this\n          for( const [id, trackData] of Object.entries(pattern.instrumentTracks) )\n          {\n            replacedTracks[id] = new track( trackData.rep, trackData.resolution );\n          }\n          let patternWithTracks = Object.assign({}, pattern);\n          patternWithTracks.instrumentTracks = replacedTracks;\n          patterns.push(patternWithTracks);\n        }\n        return patterns;\n      }\n\n      // assume it's a tabit file!\n      Promise.resolve(e.content).then(JSON.parse).then( prevState => {\n        this.setState( {\n          instrumentIndex : prevState.instrumentIndex,\n          instrumentMask : createInstrumentMask(prevState.instrumentIndex, prevState.instruments),\n          instruments : prevState.instruments,\n          patterns : createTracks(prevState.patterns),\n          formatSettings : prevState.formatSettings,\n          patternSettings : prevState.patternSettings,\n          // general app state\n          loadedFile : e.file.name,\n          selectedPattern : prevState.patterns.length === 0 ? null : 0,\n          patternsOpen : prevState.patterns.length !== 0,\n        } );\n      }).catch( (error)=>{ alert(\"Failed to load file \" + e.file.name  + \" with error \" + error); } );\n    }\n  }\n\n  selectPattern(patternIndex)\n  {\n    this.setState( { selectedPattern: patternIndex } );\n  }\n\n  // todo: this is a separate component!\n  renderPattern(pattern, resolvedSettings)\n  {\n    return (\n      <React.Fragment>\n        <Pattern \n          instruments={this.state.instruments} \n          tracks={pattern.instrumentTracks}\n          config={resolvedSettings}\n          active={this.state.progress}\n        />\n        <SoundBoard \n          instruments={this.state.instruments} \n          instrumentIndex={this.state.instrumentIndex} \n          tracks={pattern.instrumentTracks}\n        />\n      </React.Fragment>\n    );\n  }\n\n\n\n  loadExample()\n  {\n    const createObjects = (state) => \n    {\n      // the instruments currently work as simple objects\n      // we need to create tracks!\n      for( let pattern of state.patterns )\n      {\n        let replacedTracks = {};\n        // todo: find a more compact way of doing this\n        for( const [id, trackData] of Object.entries(pattern.instrumentTracks) )\n        {\n          replacedTracks[id] = new track( trackData.rep, trackData.resolution );\n        }\n        pattern.instrumentTracks = replacedTracks;\n      }\n      return state;\n    }\n    const k = createObjects(kuva);\n    const assessedInstruments = figureInstruments(k.instruments, DEFAULT_INSTRUMENT_SYMBOLS, k.patterns);\n    const instrumentIndex = activeInstrumentation(k.instruments, k.patterns);\n    this.setState({\n      instrumentIndex : instrumentIndex,\n      instrumentMask : createInstrumentMask(instrumentIndex, assessedInstruments),\n      instruments : assessedInstruments,\n      patterns : k.patterns,\n      selectedPattern : k.patterns.length === 0 ? null : 0,\n      loadedFile : \"kuva.example\",\n      patternsOpen : true,\n      patternSettings : this.figurePatternSettings(k.patterns)\n    });\n  }\n\n  checkMobile()\n  {\n    // the simple version from\n    // https://stackoverflow.com/questions/11381673/detecting-a-mobile-browser\n    const userAgent = (navigator.userAgent||navigator.vendor||window.opera);\n    const toMatch = [\n        /Android/i,\n        /webOS/i,\n        /iPhone/i,\n        /iPad/i,\n        /iPod/i,\n        /BlackBerry/i,\n        /Windows Phone/i\n    ];\n\n    return toMatch.some((toMatchItem) => {\n        return userAgent.match(toMatchItem);\n    });\n  }\n\n\n  getTrackLength(pattern)\n  {\n    let trackLength = 48;\n    for(const [,t] of Object.entries(pattern.instrumentTracks))\n    {\n        trackLength = Math.max( trackLength, t.length() );\n    }\n    return trackLength;\n  }\n\n  getResolution(pattern)\n  {\n    let resolution = 48;\n    for(const [,t] of Object.entries(pattern.instrumentTracks))\n    {\n        resolution = Math.min( resolution, t.resolution );\n    }\n    return resolution;\n  }\n\n  // todo: this will go away eventually, once I choose how to load a file\n  // (though it should obviously be another component anyway)\n  renderMainContent()\n  {\n    if(this.state.patterns == null || this.state.patterns.length === 0)\n    {\n      const showAlert = this.state.patterns != null && this.state.patterns.length === 0;\n      const optionalAlert = showAlert ? ( <Alert severity=\"error\">{this.state.loadedFile} contained no patterns! Try another.</Alert> )\n                                      : \"\";\n      return (\n        <React.Fragment>\n        <div>\n          <h2>tabit</h2>\n          <p>I read .h2songs and write tab</p>\n          <Button variant=\"contained\" onClick={this.loadExample.bind(this)} style={{margin: \"1em\"}}>Load example</Button>\n          <FileImport\n            style={{margin: \"1em\"}}\n            variant=\"contained\"\n            onImport={this.handleFileImport.bind(this)}\n            accept=\".tabit,.h2song\"\n            />\n            {optionalAlert}\n        </div>\n        <div style={{ position:\"absolute\", bottom:0 }} >\n          <p>tabit relies on publicly available sound libraries listed at <a href=\"https://github.com/andrew-murray/tabit\">https://github.com/andrew-murray/tabit</a></p>\n        </div>\n        </React.Fragment>\n      );      \n    }\n    else\n    {\n      const patternToRender = this.state.patterns[this.state.selectedPattern];\n      const patternConfig = Object.assign(\n        Object.assign({}, this.state.formatSettings), // global settings\n        this.state.patternSettings[this.state.selectedPattern] // then apply per-pattern settings\n      );\n      const patternContent = this.renderPattern(patternToRender, patternConfig);\n       \n      const ignoreEvent = (event) => {\n        return event && event.type === 'keydown' && (event.key === 'Tab' || event.key === 'Shift');\n      };\n\n      const settingsChangeCallback = (config) => {\n        let existingPatternSettings = Array.from( this.state.patternSettings );\n        let existingGlobalSettings = Object.assign( {}, this.state.formatSettings );\n        for( let [k,v] of Object.entries(config) )\n        {\n          if( k in existingPatternSettings[this.state.selectedPattern] )\n          {\n            existingPatternSettings[this.state.selectedPattern][k] = v;\n          }\n          else\n          {\n            existingGlobalSettings[k] = v;\n          }\n        }\n        this.setState( { formatSettings: existingGlobalSettings, patternSettings : existingPatternSettings } );\n      };\n\n      const handleDrawerOpen = (e) => {\n        if( ignoreEvent(e) ){ return; }\n        this.setState( {settingsOpen : true} );\n      };\n\n      const handleDrawerClose = (e) => {\n        if( ignoreEvent(e) ){ return; }\n        this.setState( {settingsOpen : false} );\n      };\n\n      const handlePatternsClose = (e) => {\n        if( ignoreEvent(e) ){ return; }\n        this.setState( { patternsOpen : false } );\n      };\n      const handlePatternsOpen = (e) => {\n        if( ignoreEvent(e) ){ return; }\n        this.setState( { patternsOpen : true } );\n      };\n\n      const changeInstrumentsCallback = (instruments) => {\n        this.setState( {\n          instruments : instruments,\n          instrumentMask : createInstrumentMask(this.state.instrumentIndex, instruments)\n        } );\n      }\n\n      const classes = this.props;\n      const iOS = process.browser && /iPad|iPhone|iPod/.test(navigator.userAgent);\n      const mobile = this.checkMobile();\n\n      const patternDetails = { name : patternToRender.name, resolution : patternToRender.resolution, \"length\" : this.getTrackLength(patternToRender) };\n\n      const instrumentConfigColumns = mobile ? 12 : 8;\n\n\n      return (\n        <React.Fragment>\n          <div style={{display:\"flex\", width: \"95%\"}}> \n            <IconButton\n              color=\"inherit\"\n              aria-label=\"open drawer\"\n              edge=\"start\"\n              onClick={handlePatternsOpen}\n              className={clsx({\n                [classes.hide] : !this.state.patternsOpen\n              })}\n            >\n              <ChevronRightIcon />\n            </IconButton>\n            <div className=\"content-title\" style={{flexGrow:1}}>\n            </div>\n            <IconButton\n              color=\"inherit\"\n              aria-label=\"open drawer\"\n              edge=\"end\"\n              onClick={handleDrawerOpen}\n              className={clsx(this.state.settingsOpen && classes.hide)}\n            >\n              <MenuIcon />\n            </IconButton>\n          </div>\n          {patternContent}\n          <Grid container>\n          <Grid item xs={(12 - instrumentConfigColumns ) / 2} />\n          <Grid item xs={instrumentConfigColumns}>\n            <InstrumentConfig\n              instruments={this.state.instruments}\n              instrumentIndex={this.state.instrumentIndex}\n              instrumentMask={this.state.instrumentMask}\n              onChange={changeInstrumentsCallback}\n            />\n          </Grid>\n          <Grid item xs={(12 - instrumentConfigColumns ) / 2} />\n          </Grid>\n\n        <SwipeableDrawer disableBackdropTransition={!iOS} disableDiscovery={iOS}\n          className={classes.drawer}\n          variant={ mobile ? undefined : \"persistent\" }\n          open={this.state.patternsOpen}\n          onOpen={handlePatternsOpen}\n          onClose={handlePatternsClose}\n        >\n          <div className={classes.drawerHeader}>\n            <IconButton onClick={handlePatternsClose}>\n                <ChevronLeftIcon />\n            </IconButton>\n          </div>\n          <Divider />\n          <div className={classes.drawerContainer}>\n            <List>\n              {(this.state.patterns ?? []).map( (pattern, index) => (\n                <ListItem button key={\"drawer-pattern\" + index.toString()} onClick={() => this.selectPattern(index)}>\n                    <ListItemText primary={pattern.name} />\n                </ListItem>\n              ))}\n            </List>\n          </div>\n        </SwipeableDrawer>\n        <SwipeableDrawer disableBackdropTransition={!iOS} disableDiscovery={iOS}\n          className={classes.drawer}\n          variant={ mobile ? undefined : \"persistent\" }\n          anchor=\"right\"\n          open={this.state.settingsOpen}\n          onOpen={handleDrawerOpen}\n          onClose={handleDrawerClose}\n          classes={{\n            paper: classes.drawerPaper\n          }}\n        >\n          <div className={classes.drawerHeader}>\n            <IconButton onClick={handleDrawerClose}>\n                <ChevronRightIcon />\n            </IconButton>\n          </div>\n          <Divider />\n          <FormatSettings\n            onChange={settingsChangeCallback}\n            settings={patternConfig}\n            pattern={patternDetails}\n            />\n          <Button\n            style={{backgroundColor : \"white\", color : theme.palette.background.default}}\n            onClick={(e) => { this.save(); } }\n          >Download</Button>\n        </SwipeableDrawer>\n        </React.Fragment>\n      );\n    }\n  }\n\n  render() {\n    const mainContent = this.renderMainContent();\n    return (\n      <div className=\"App\">\n        <ThemeProvider theme={theme}>\n          <CssBaseline />\n          {mainContent}\n        </ThemeProvider>\n      </div>\n    );\n  }\n}\n\nexport default App;\n","// FileUpload.react.js\n\n// inspired by https://gist.github.com/AshikNesin/e44b1950f6a24cfcd85330ffc1713513\n// and https://stackoverflow.com/questions/55830414/how-to-read-text-file-in-react\n\nimport React from 'react'\nimport Button from '@material-ui/core/Button';\n\nclass FileImport extends React.Component {\n\n  constructor(props) {\n    super(props);\n    this.hiddenFileInput = React.createRef();\n  }\n\n  onChange(e) {\n    const fileObject = e.target.files[0]\n    const reader = new FileReader()\n    reader.onload = loadEvent => {\n      if( this.props.onImport )\n      {\n        this.props.onImport(\n          { file: fileObject, content : loadEvent.target.result}\n        );\n      }\n    }\n    reader.readAsText(fileObject);\n  }\n\n  render() {\n    const clickFile = (e) => {\n      this.hiddenFileInput.current.click();\n    }\n\n    const {onImport, accept, ...buttonProps} = {...this.props};\n    return (\n      <React.Fragment>\n        <Button onClick={clickFile} {...buttonProps}>Import File</Button>\n        <input\n          type=\"file\"\n          hidden\n          accept={accept}\n          onChange={(e) => this.onChange(e)} ref={this.hiddenFileInput}\n          />\n      </React.Fragment>\n   )\n  }\n}\n\nexport default FileImport;\n","import React from 'react';\nimport notation from \"./notation\"\nimport { withStyles } from '@material-ui/core/styles';\n\nconst useStyles = theme => ({\n  root: {\n    \"margin-bottom\": theme.spacing(2),\n    fontFamily: \"Roboto Mono\",\n    textAlign: \"left\",\n    whiteSpace:\"pre\",\n    \"& .activeNote\": {\n      color : theme.palette.secondary.main\n    }\n  },\n});\n\n// const classes = useStyles();\n\nclass Pattern extends React.Component\n{\n  constructor(props) {\n    super(props);\n    this.state = {\n    };\n  }\n\n  // remove me and relpace with me with something way better\n  // this is taken from the notation formatAsPage code\n  formatText(instruments)\n  {\n    let configOverride = this.props.config;\n    let page = [];\n    for( const [instrumentName, instrument] of instruments )\n    {\n      const asHTML = true;\n      const notationString = notation.fromInstrumentAndTrack(\n        instrument,\n        this.props.tracks,\n        asHTML,\n        configOverride\n      );\n      page.push(instrumentName);\n      for( const x of notationString.split(\"\\n\"))\n      {\n        page.push(x);\n      }\n    }\n    return page;\n  }  \n\n  render() {\n    const { classes } = this.props;\n    // todo: I think I need to turn the creation of the pattern text, into a react setting,\n    // so that I can add my light show\n    return (\n      <div className={classes.root} >\n        { this.formatText(this.props.instruments).map((x,index) => <p key={index.toString()} dangerouslySetInnerHTML={{\"__html\" : x}} />) }\n      </div>\n    );\n  }\n}\n\nexport default withStyles(useStyles)(Pattern);","// h2.js\n\nimport track from \"./track\";\nimport xml2js from \"xml2js\";\nimport { calculateResolution } from \"./utilities\";\n\n// TODO: This file was written with the hope that using xml2js would make things cleaner\n// it didn't, purely because xml2js is an okay library doing a difficult task\n// it ensures to produce a good json file but in doing so muddles the data a bit.\n// Should replace this with dom-parser and window.DOMParser\n\n// let's think about the data representation needed\n\nfunction calculatePatternResolution(pattern, size)\n{\n  const positions = Array.from(pattern.notes, note => note.position)\n  return calculateResolution(positions, size);\n}\n\nfunction parseHydrogenJs(result)\n{\n    // fixme:\n    // this parsing often assumes there's >=2 elements\n\n    // this \"zero\" here is presumably an artefact of xml --> json representation\n    const instrumentElements = result.song.instrumentList[0].instrument;\n\n    // instruments\n    // [  { id, name } ]\n    const instrumentArray = Array.from(\n      instrumentElements,\n      function(element){\n        const instrumentComponent = element.instrumentComponent[0];\n        let inst = {\n          \"id\" : parseInt(element.id), \n          \"name\" : element.name[0],\n           \"volume\" : parseFloat(element.volume), \n           \"muted\" : element.isMuted[0] === \"true\",\n           \"gain\" : parseFloat(element.gain),\n           \"drumkit\" : element.drumkit[0]\n        };\n        if( \"layer\" in instrumentComponent )\n        {\n          inst[\"filename\"] = instrumentComponent.layer[0].filename[0];\n        }\n        return inst;\n      }\n    );\n\n    const patternElements = result.song.patternList[0].pattern;\n    // patterns\n    // [  { name, size, notes } ]\n    const patternArray = Array.from(\n      patternElements,\n      function(element){\n        const noteElements = element.noteList[0].note;\n        const patternSize = parseInt(element.size);\n        let notes = [];\n        if( noteElements )\n        {\n          // notes \n          // [ {position, instrument(id}]\n          notes = Array.from(\n            noteElements,\n            function(noteElement){\n              return {\"position\" : parseInt(noteElement.position), \"instrument\" : parseInt(noteElement.instrument)};\n            }\n          );\n\n          // hydrogen permits you to have notes that reach past the pattern size, \n          // they then get revealed when you extend the pattern, \n          // here's an easy point to get rid of them, we don't want them to factor into any calculations\n          notes = notes.filter( n => n.position < patternSize );\n        }\n        return {\n          \"size\" : patternSize, \n          \"name\" : element.name[0],\n          \"notes\" : notes\n        };\n      }\n    );\n\n    // transform pattern to a managable data\n    const patternsWithTracks = Array.from(\n      patternArray,\n      function(pattern)\n      { \n        const resolution = calculatePatternResolution(pattern, pattern.size);\n        let instrumentTracks = {};\n        for( const instrument of instrumentArray )\n        {\n          const relevantNotes = pattern.notes.filter( \n            note => (note.instrument === instrument.id)\n          );\n          const relevantHits = Array.from(\n            relevantNotes,\n            note => note.position\n          );\n          instrumentTracks[ instrument.id.toString() ] = track.fromPositions( relevantHits, pattern.size, resolution);\n        }\n        pattern.resolution = resolution;\n        pattern.instrumentTracks = instrumentTracks;\n        return pattern;\n      }\n    );\n\n    // todo: refactor into (at least one) separate function\n    if(result.song.virtualPatternList)\n    {\n      // so unfortunately, virtualPatternGroup represents a directional graph and we have to build\n      // the tree of dependencies for each node, we implement this in a very simplistic way\n      // let's build a mapping( name -> [ names ] ) and continue to resolve it\n      // until we're done\n      const virtualPatternGroups = result.song.virtualPatternList[0].pattern;    \n      if( virtualPatternGroups )\n      {\n        // each element looks like\n        //\n        // <pattern>\n        // <name>p2-a-djembe</name>\n        // <virtual>p2-a-bass</virtual>\n        // <virtual>p2-snare</virtual>\n        // </pattern>\n\n        let patternToRelated = {};\n\n        // record initial relations\n        for( const virtualGroup of Array.from(virtualPatternGroups) )\n        {\n          const rootPatternName = virtualGroup.name[0];\n          const relatedPatterns = Array.from(virtualGroup.virtual);\n          patternToRelated[rootPatternName] = new Set(relatedPatterns);\n        }\n\n        // expand connections until our object stops changing, brute-force\n        // this is a relatively large limit but is better than the potential of an infinite loop\n        // I think 3 layers would be pushing this feature\n        const MAX_ITERATIONS = 20;\n        for(let iteration = 0; iteration < MAX_ITERATIONS; ++iteration)\n        {\n          let expandedObject = {};\n          // we could do a check at the end of each loop, but it's easier to track object equality this way\n          let objectHasExpanded = false;\n          for(const [root, related] of Object.entries(patternToRelated))\n          {\n            let expandedNodeSet = new Set(related);\n            for( const node of expandedNodeSet )\n            {\n              if( node in patternToRelated )\n              {\n                // set union\n                expandedNodeSet = new Set([...expandedNodeSet, ...patternToRelated[node]]);\n              }\n            }\n            objectHasExpanded = objectHasExpanded || ( expandedNodeSet.size !== related.size );\n            expandedObject[ root ] = expandedNodeSet;\n\n          }\n          // exit if no change\n          if(!objectHasExpanded)\n          {\n            break;\n          }\n          // throw if we've failed to resolve all the connections by now, morelikely something has gone wrong\n          if( iteration === MAX_ITERATIONS )\n          {\n            throw new Error(\"Reached max virtual_pattern recursion depth.\");\n          }\n          // otherwise update mapping and continue\n          patternToRelated = expandedObject;\n        }\n\n        for( const [rootPatternName, relatedPatternSet] of Object.entries(patternToRelated) )\n        {\n          // could do filter, and assert on length?\n          let rootPattern = patternsWithTracks.find(p => p.name === rootPatternName);\n          for( const patternToMergeName of relatedPatternSet )\n          {\n            const patternToMerge = patternsWithTracks.find(p => p.name === patternToMergeName );\n            for( const [id, t] of Object.entries(patternToMerge.instrumentTracks) )\n            {\n              if( id in rootPattern.instrumentTracks )\n              {\n                const merged = rootPattern.instrumentTracks[ id ].aggregate( t );\n                // we match hydrogen's implementation here and discard values past the length of the original track\n                merged.rep.length = rootPattern.size  / merged.resolution;\n                rootPattern.instrumentTracks[ id ] = merged; \n              }\n              else\n              {\n                // ensure track is the appropriate length & res\n                let copiedTrack = t.format(rootPattern.resolution);\n                copiedTrack.length = rootPattern.size  / rootPattern.resolution;\n                rootPattern.instrumentTracks[id] = copiedTrack;\n              }\n            }\n          }\n          // reassess resolution and apply to all tracks\n          // this may not be necessary but it's probably nice\n          const resolution = calculatePatternResolution(rootPattern, rootPattern.size);\n          rootPattern.resolution = resolution;\n          for( const [id, track] of Object.entries(rootPattern.instrumentTracks) )\n          {\n            // ensure that \n            rootPattern[id] = track.format( resolution );\n          }\n        }\n\n      }\n    }\n\n\n    return {\n      \"instruments\" : instrumentArray,\n      \"patterns\" : patternsWithTracks\n    }\n}\n\nasync function parseHydrogenPromise(xmlString)\n{\n  let parser = new xml2js.Parser();\n\n  return parser.parseStringPromise(xmlString).then(parseHydrogenJs);\n}\n\nexport default { parseHydrogenPromise };","class Audio\n{\n\n  // todo: we replace a valid audioContext with a blank object, so that we can run tests in node\n  //       this should probably be replaced by https://github.com/audiojs/web-audio-api \n  //       and a test-suite written\n  static createWebContext()\n  {\n    return new (window.AudioContext || window.webkitAudioContext || Object)();\n  }\n\n  static determineMinResolution(\n    instrumentIndex,\n    tracks\n  )\n  {\n      let minResolution = 48; \n      for(const [id,t] of Object.entries(tracks))\n      { \n        // the lookup and iteration shouldn't look like this\n        const selected =  instrumentIndex.filter(inst => inst.id.toString() === id);\n        if( \n          selected.length > 0 \n          && !t.empty()\n        )\n        {\n          minResolution = Math.min( minResolution, t.resolution );\n        }\n      }\n      return minResolution;\n  }\n\n  static determineTrackLength(\n    instrumentIndex,\n    tracks\n  )\n  {\n      let trackLength = 48;\n      for(const [id,t] of Object.entries(tracks))\n      { \n        // the lookup and iteration shouldn't look like this\n        const selected =  instrumentIndex.filter(inst => inst.id.toString() === id);\n        if( \n          selected.length > 0 \n          && !t.empty() \n        )\n        {\n          trackLength = Math.max( trackLength, t.length() );\n        }\n      }\n      return trackLength;\n  }\n\n  static peakAmplitude(\n    combined\n  )\n  {\n    let peakValue = 0.0;\n    for (let channel = 0; channel < combined.numberOfChannels; channel++) {\n      let combinedChannel = combined.getChannelData(channel);\n      for( let sample = 0; sample < combinedChannel.length; ++sample)\n      {\n        peakValue = Math.max( Math.abs(combinedChannel[sample]), peakValue );\n      }\n    }\n    return peakValue;\n  }\n\n  static normalizeAudioBuffer(\n    combined\n  )\n  {\n    const peakValue = Audio.peakAmplitude( combined );\n    if( peakValue > 1.0 )\n    {\n      for (let channel = 0; channel < combined.numberOfChannels; channel++) {\n        let combinedChannel = combined.getChannelData(channel);\n        for( let sample = 0; sample < combinedChannel.length; ++sample)\n        {\n          combinedChannel[sample] = combinedChannel[sample] / peakValue;\n        }\n      }\n    }\n    return combined;\n  }\n\n  static createMasterTrack(\n    context,\n    tracks,\n    instrumentIndex,\n    sounds,\n    tempo\n  )\n  {\n    const trackLength = Audio.determineTrackLength( instrumentIndex, tracks );\n\n\n    const beatTime =  (60.0 / tempo) * 1000;\n    const timePerHydrogen = beatTime / 48.0;\n\n\n    // let's assume we can do some simple things\n\n    const sampleRate = 44100;\n    const channels = 2;\n    const trackLengthMs = trackLength * timePerHydrogen;\n    const trackLengthSamples = trackLengthMs * sampleRate / 1000.0;\n    const totalSamples = Math.floor(trackLengthSamples);\n    const samplesPerHydrogen = Math.floor( totalSamples / trackLength );\n    const combined = context.createBuffer(channels, totalSamples, sampleRate);\n\n    // populate blank buffer with sounds\n    for (let channel = 0; channel < combined.numberOfChannels; channel++) {\n      let combinedChannel = combined.getChannelData(channel);\n      for(const [id,t] of Object.entries(tracks))\n      { \n        // the lookup and iteration shouldn't look like this\n        const selected =  instrumentIndex.filter(inst => inst.id.toString() === id);\n        if( \n          selected.length > 0 \n          && selected[0].id in sounds\n          && !t.empty()\n        )\n        {\n          const audioBuffer = sounds[selected[0].id];\n          // fallback to copying the mono buffer across both channels\n          const audioChannel = audioBuffer.numberOfChannels === 2 ? audioBuffer.getChannelData(channel) : audioBuffer.getChannelData(0);\n          const trackPoints = t.toPoints();\n          for( const noteStart of trackPoints )\n          {\n            const sampleStart = noteStart * samplesPerHydrogen;\n            // console.log(\"inserting sample at \" + sampleStart * (trackLengthBeats/trackLengthSamples));\n            for( let sample = 0; sample < audioBuffer.length; ++sample )\n            {\n              // add sample to mega track\n              combinedChannel[sampleStart + sample] = combinedChannel[sampleStart + sample] + audioChannel[sample];\n            }\n          }\n        }\n      }\n    }\n\n    return Audio.normalizeAudioBuffer( combined );\n  }\n\n  static createAudioSource(context, buffer, tempo)\n  {\n    var source = context.createBufferSource();\n    // set the buffer in the AudioBufferSourceNode\n    source.buffer = buffer;\n    source.loop=true;\n    if( tempo !== null )\n    {\n      source.playbackRate.value = tempo / 100.0;\n    }\n    // connect the AudioBufferSourceNode to the\n    // destination so we can hear the sound\n    source.connect(context.destination);\n    return source;\n  }\n}\n\nexport default Audio;","class AudioRequest {\n  static make(url) {\n    // Create new promise with the Promise() constructor;\n    // This has as its argument a function\n    // with two parameters, resolve and reject\n    return new Promise(function(resolve, reject) {\n      // Standard XHR \n      var request = new XMLHttpRequest();\n      request.open('GET', url);\n      request.responseType = \"arraybuffer\";\n      // When the request loads, check whether it was successful\n      request.onload = function() {\n        if (request.status === 200) {\n        // If successful, resolve the promise by passing back the request response\n          resolve(request.response);\n        } else {\n        // If it fails, reject the promise with a error message\n          reject(Error('Buffer didn\\'t load successfully; error code:' + request.statusText));\n        }\n      };\n      request.onerror = function() {\n      // Also deal with the case when the entire request fails to begin with\n      // This is probably a network error, so reject the promise with an appropriate message\n          reject(Error('There was a network error.'));\n      };\n      // Send the request\n      request.send();\n    });\n  }\n\n  static parse(context, response)\n  {\n    return new Promise(function(resolve,reject) {\n      // Asynchronously decode the audio file data in request.response\n      context.decodeAudioData(\n        response,\n        (buffer) => { \n          if(buffer){ resolve(buffer); }\n          else{ reject( \"buffer null\" ); }\n        },\n        (err) => { reject(err); }\n      );\n    });\n  }\n};\n\nexport default AudioRequest;","import React from 'react';\nimport Audio from \"./Audio\"\nimport AudioRequest from \"./AudioRequest\";\n\nimport IconButton from '@material-ui/core/IconButton';\nimport PlayArrowIcon from '@material-ui/icons/PlayArrow';\nimport StopIcon from '@material-ui/icons/Stop';\nimport Slider from '@material-ui/core/Slider';\n\n// these are the hydrogen drumkits available by GPL/CC\n\nconst DRUMKITS = [\n  \"circAfrique v4\",\n  \"DeathMetal\",\n  \"The Black Pearl 1.0\",\n  \"GMRockKit\",\n  \"TR808EmulationKit\"\n];\n\n// TODO: This is very much not a react component, as it stands\n//   \n\nclass SoundBoard extends React.Component\n{\n\n  constructor(props) {\n    super(props);\n    this.state = {\n      audioBuffer : null,\n      audioSource : null,\n      soundsPopulated : false,\n      tempo : 100.0\n    }\n    this.sounds = {};\n    this.audioContext = null;\n  }\n\n\n\n  chooseAppropriateUrlForInstrument(drumkit_name, instrumentName)\n  {\n    const name = instrumentName.toLowerCase();\n    // this is currently very basic\n    if(name.includes(\"kick\"))\n    {\n        return \"The Black Pearl 1.0/PearlKick-Hard.wav\";\n    }\n    else if(name.includes(\"stick\"))\n    {\n        return \"DeathMetal/16297_ltibbits_sticks_low_pitch.wav\";\n    }\n    else if(name.includes(\"tom\"))\n    {\n        return \"TR808EmulationKit/808_Tom_Mid.wav\"\n    }\n    else if(name.includes(\"clap\"))\n    {\n        return \"TR808EmulationKit/808_Clap.wav\";\n    }\n    else if(name.includes(\"snare\"))\n    {\n      return \"GMRockKit/Snare-Soft.wav\";\n    }\n    else\n    {\n      // todo: snare, cymbals\n      return null;\n    }\n  }\n\n  populateSounds()\n  {\n    if( this.audioContext === null )\n    {\n      // don't do this when creating components\n      // https://developers.google.com/web/updates/2017/09/autoplay-policy-changes#webaudio\n      this.audioContext = Audio.createWebContext();\n    }\n    let collatedPromises = []; \n    for(const [id,] of Object.entries(this.props.tracks))\n    {\n      const selected = this.props.instrumentIndex.filter(inst => inst.id.toString() === id);\n      if( selected.length > 0)\n      {\n        const selected_instrument = selected[0];\n        // todo: many hydrogen drumkits are unsupported\n        //       we should fallback to sensible defaults when the drumkit is not available\n        //       rules for {tom, stick, shaker, kick, bass}\n        if( \n          \"drumkit\" in selected_instrument && \n          \"filename\" in selected_instrument &&\n          DRUMKITS.includes(selected_instrument.drumkit) )\n        {\n\n          const filename = selected_instrument.filename.replace(\".flac\", \".wav\");\n          if(!(selected_instrument.id in this.sounds))\n          {\n            const dest_url = process.env.PUBLIC_URL + \"/wav/\" + selected_instrument.drumkit + \"/\" + filename;\n            const actx = this.audioContext;\n            let sounds = this.sounds;\n            collatedPromises.push( \n              AudioRequest.make( dest_url )\n              .then( (response) =>{ return AudioRequest.parse(actx, response); } )\n              .then( (buffer) => { sounds[selected_instrument.id] = buffer } )\n              .catch( (fail) => { console.log(fail); })\n            );\n          }\n        }\n        else if( \"drumkit\" in selected_instrument )\n        {\n          // it's not a drumkit we support, try and guess a matching instrument\n          const relativeUrl = this.chooseAppropriateUrlForInstrument( selected_instrument.drumkit, selected_instrument.name);\n          if(relativeUrl === null )\n          {\n            console.log(\"didn't load anything for \" + selected_instrument.name);\n            continue;\n          }\n          const dest_url = process.env.PUBLIC_URL + \"/wav/\" + relativeUrl;\n          const actx = this.audioContext;\n          let sounds = this.sounds;\n          collatedPromises.push(\n            AudioRequest.make( dest_url )\n            .then( (response) =>{ return AudioRequest.parse(actx, response); } )\n            .then( (buffer) => { sounds[selected_instrument.id] = buffer } )\n            .catch( (fail) => { console.log(fail); })\n          );\n        }\n      }\n    }\n\n    const sounds = this.sounds;\n    const instrumentIndex = this.props.instrumentIndex;\n    const tracks = this.props.tracks;\n    let board = this;\n\n    Promise.all(collatedPromises).then( () => {\n      const b = Audio.createMasterTrack(\n        board.audioContext,\n        tracks,\n        instrumentIndex,\n        sounds,\n        100 // hardcoded tempo\n      );\n\n      // todo: this could happen before componentDidMount!!\n      board.setState( { \n        audioBuffer : b, \n        resolution : Audio.determineMinResolution(instrumentIndex, tracks ),\n        length : Audio.determineTrackLength(instrumentIndex, tracks ),\n        soundsPopulated : true \n      } );\n    });\n  }\n\n  stop()\n  {\n    // if playing, stop\n    if(this.state.audioSource){\n      this.state.audioSource.stop(); \n      if( this.timeoutID != null )\n      {\n        clearTimeout(this.timeoutID);\n        this.timeoutID = null;\n      }\n      this.playPos = 0;\n      this.setState( { audioSource : null } );\n    }\n  }\n\n  componentDidUpdate(prevProps, prevState, snapshot)\n  {\n    // theoretically we should be evaluating a rougher equality on the tracks here\n    // but ... as is !== will never be wrong here, and our linter warns if we don't use it \n    const tracksAreDifferent = prevProps.tracks !== this.props.tracks;\n    if( tracksAreDifferent )\n    {\n      this.stop();\n    }\n\n    if( tracksAreDifferent && this.state.soundsPopulated)\n    {\n      // if( !this.state.soundsPopulated ) then we already have a task in flight to do this\n      const b = Audio.createMasterTrack(\n        this.audioContext,\n        this.props.tracks,\n        this.props.instrumentIndex,\n        this.sounds,\n        100 // hardcoded tempo\n      );\n\n      this.setState({\n        audioBuffer: b,\n        resolution : Audio.determineMinResolution(this.props.instrumentIndex, this.props.tracks ),\n        length : Audio.determineTrackLength(this.props.instrumentIndex, this.props.tracks )\n      });\n\n      // we were playing\n      if( prevState.audioSource )\n      {\n        this.playBuffer( b );\n      }\n    }\n  }\n\n  componentDidMount()\n  {\n    this.populateSounds();\n  }\n\n  playBuffer( b )\n  {\n\n    const source = Audio.createAudioSource( this.audioContext, b, this.state.tempo );\n\n    // kick it off immediately\n    source.start();\n    this.startTime = this.audioContext.currentTime;\n\n\n    const tempo = 100.0;\n    const beatTime =  (60.0 / tempo) / 4.0;\n\n    \n    const updatePlayPos = () => {\n      const currentTime = this.audioContext.currentTime;\n      const playPos = ( ( currentTime - this.startTime )  / this.state.audioBuffer.duration ) % 1.0;\n\n      const beatCount = ( currentTime - this.startTime ) / beatTime;\n      const currentBeat = Math.round(beatCount);\n      const nextBeatTime = this.startTime + beatTime * ( currentBeat + 1 );\n\n      this.timeoutID = setTimeout(\n        updatePlayPos,\n        Math.floor( ( nextBeatTime - Audio.context.currentTime ) * 1000 )\n      );\n      if( this.props.onPlaybackPositionChange  )\n      {\n        this.props.onPlaybackPositionChange( playPos );\n      }\n    };\n\n    if( this.props.onPlaybackPositionChange )\n    {\n      updatePlayPos();\n    }\n    \n    this.setState( { audioSource : source} );\n  }\n  \n  tempoControl()\n  {\n    const onTempoChange = (event, tempo) => {\n      if( this.state.audioSource )\n      {\n        // const playbackRate = tempo / 100.0;\n        // fixme: avoid manipulating the state in place\n        // this.state.audioSource.playbackRate.value = playbackRate;\n      }\n    };\n    return (\n      <Slider\n        defaultValue={this.state.tempo}\n        min={60}\n        step={1}\n        max={180}\n        onChange={onTempoChange}\n        valueLabelDisplay=\"auto\"\n      />\n    );\n\n  }\n\n  render() {\n\n    const play = (e) => {\n      // if not playing, but buffer is ready\n      if(!this.state.audioSource && this.state.audioBuffer)\n      {\n        this.playBuffer(this.state.audioBuffer);\n      }\n    };\n\n    return (\n      <React.Fragment>\n        <div>\n          <IconButton\n            color=\"primary\"\n            aria-label=\"play\"\n            onClick={play}\n          >\n            <PlayArrowIcon />\n          </IconButton>\n\n          <IconButton\n            color=\"secondary\"\n            aria-label=\"stop\"\n            onClick={(e)=>{this.stop();}}\n          >\n            <StopIcon />\n          </IconButton>\n        </div>\n        { // don't offer tempo controls yet, because it changes the pitch!\n          false && this.tempoControl()\n        }\n      </React.Fragment>\n   );\n  }\n};\n\nexport default SoundBoard;","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' },\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n","\nclass notation\n{\n\n  static DEFAULT_FORMAT_CONFIG = {\n    \"restMark\" : \"-\",\n    \"beatMark\" : \"|\",\n    \"lineMark\" : \"|\",\n    \"numberRestMark\" : \"-\",\n    \"beatResolution\" : 48,\n    \"showBeatMark\" : true,\n    \"showBeatNumbers\" : true,\n    // lineResolution is typically determined on a per-pattern basis\n    // however it used to be in here, and some tests still rely on this\n    \"lineResolution\" : 48 * 8\n  };\n\n  static FORMAT_CONFIG_STRINGS = [\n    [\"restMark\",[\"-\", \".\", \" \"]],\n    [\"numberRestMark\",[\"-\", \".\", \" \"]]\n  ];\n\n  static FORMAT_CONFIG_BOOLS = [\n    \"showBeatMark\",\n    \"showBeatNumbers\"\n  ];\n\n  static validateConfig(config, patternResolution) {\n    if( patternResolution != null && ( config.beatResolution % patternResolution ) !== 0 )\n    {\n      throw new Error(\"patternResolution doesn't divide beatResolution\");\n    }\n    if( config.lineResolution <= 0 )\n    {\n      throw new Error(\"config.lineResolution must be greater than zero\");\n    }\n  }\n\n  static chunkString(str, chunkSize) {\n    if( chunkSize <= 0 )\n    {\n      throw new Error(\"chunkSize must be > 0\")\n    }\n    return str.match(new RegExp('.{1,' + chunkSize + '}', 'g'));\n  }\n\n  static createNumberMarker(numberRestMark, beatResolution, patternResolution, lineLength)\n  {\n    if( lineLength <= 0 )\n    {\n      throw new Error(\"lineLength <= 0\");\n    }\n\n    if( ( beatResolution % patternResolution ) !== 0)\n    {\n      throw new Error(\"patternResolution \" + patternResolution.toString() + \" does not divide beatResolution \" + beatResolution.toString());\n    }\n\n    let beatCount = Math.ceil(lineLength / beatResolution);\n    let numberMarkerArray = Array.from( Array(lineLength / patternResolution), e => numberRestMark );\n\n    for( let beat = 0; beat < beatCount; beat++ )\n    {\n      numberMarkerArray[ beat * ( beatResolution / patternResolution ) ] = ( (beat+1) % 10 ).toString();\n    }\n    return numberMarkerArray.join(\"\");\n  }\n\n  static formatLineWithMarkers(config, line, patternResolution, asHTML)\n  {\n    notation.validateConfig(config);\n\n    const beatChunkSize = config.beatResolution / patternResolution;\n\n    const padZero = (n, width) => {\n      n = n + '';\n      return n.length >= width ? n : new Array(width - n.length + 1).join('0') + n;\n    };\n    const formatSymbolAsSpans = (symbol, numericPosition) => {\n      return \"<span class='note-\" + padZero(numericPosition, 4) + \"'>\" +  symbol + \"</span>\";\n    };\n\n    const formatSymbol = asHTML ? formatSymbolAsSpans : (symbol, numericPosition) => symbol;\n\n    let formattedLine = \"\";\n    for( let index = 0; index < line.length; ++ index )\n    {\n      const numericPosition = patternResolution * index;\n      formattedLine += formatSymbol(line.charAt(index), numericPosition);\n    }\n\n\n    const lineWithBeats = config.showBeatMark ? notation.chunkString(formattedLine, beatChunkSize * formatSymbol(\"X\", 0).length).join(config.beatMark) : formattedLine;\n    // note: we choose to always show the lineMarker even if it doesn't match the line resolution\n    return config.lineMark + lineWithBeats + config.lineMark;\n  }\n\n  static defaultLineResolution(\n    trackDict,\n    beatResolution\n  )\n  {\n    const instrumentTracks = Object.values(trackDict);\n    if(instrumentTracks.length === 0)\n    {\n      return 48 * 8;\n    }\n    const trackLength = instrumentTracks[0].length();\n    const beatCount = trackLength / beatResolution;\n    if( beatCount <= 12 )\n    {\n      return trackLength;\n    }\n    else if( beatCount > 32 )\n    {\n      return 48 * 16; // let's just be laazeee\n    }\n    else\n    {\n      // let's just apply a simple mapping, rather than think through logics\n      const mapping = [\n        trackLength, // 13 \n        trackLength / 2, // 14\n        trackLength / 3, // 15\n        trackLength / 2, // 16\n        trackLength, // 17\n        trackLength / 3, // 18\n        trackLength, // 19\n        trackLength / 4, // 20\n        trackLength / 3, // 21\n        trackLength / 2, // 22\n        trackLength, // 23\n        trackLength / 3, // 24\n        trackLength / 5, // 25\n        trackLength, // 26\n        trackLength / 3, // 27\n        trackLength / 4, // 28\n        trackLength, // 29\n        trackLength / 6, // 30\n        trackLength, // 31\n        trackLength / 4, // 32\n      ];\n      return mapping[ beatCount - 13 ];\n    }\n  }\n\n  static guessPerPatternSettings(\n    trackDict\n  )\n  {\n    return {\n      \"lineResolution\" : notation.defaultLineResolution(trackDict, 48), // beatResolution (default)\n      \"beatResolution\" : 48 // should cover all the cases hopefully\n    };\n  }\n\n  static fromInstrumentAndTrack(\n    instrument,\n    trackDict,\n    asHTML,\n    formatConfig = {}\n  )\n  {\n    for( const propName of Object.keys(formatConfig))\n    {\n      if(!notation.DEFAULT_FORMAT_CONFIG.hasOwnProperty(propName))\n      {\n        throw new Error(\"passed unrecognised property \" + propName);\n      }\n    }\n\n    let config = Object.assign( Object.assign({}, notation.DEFAULT_FORMAT_CONFIG), formatConfig );\n\n    let instrumentTracks = Object.values(trackDict);\n    if(instrumentTracks.length === 0)\n    {\n      return \"\";\n    }\n\n    // turn the tracks, into one char string\n\n    const patternSize = instrumentTracks[0].length();\n    const patternResolution = instrumentTracks[0].resolution;\n    const notationLength = instrumentTracks[0].length() / instrumentTracks[0].resolution;\n    // we only format tracks to the correct resolution\n    let patternArray = Array(notationLength).fill(config.restMark);\n    for( let charIndex = 0; charIndex < patternArray.length; ++charIndex)\n    {\n      // todo: handle collisions\n      for( const [trackID, trackSymbol] of Object.entries(instrument) )\n      {\n        const trackInstance = trackDict[trackID];\n        if( trackInstance != null && trackInstance.rep[charIndex] === 1 )\n        {\n          patternArray[charIndex] = trackSymbol;\n        }\n      }\n    }\n    const patternString = patternArray.join(\"\");\n\n    // handle lines and beatMarkers\n    let lineArray = notation.chunkString( patternString, config.lineResolution / patternResolution );\n\n    let formattedLineArray = [];\n    // add numbers on the first line\n    if( config.showBeatNumbers )\n    {\n      formattedLineArray.push( notation.formatLineWithMarkers( \n        config, \n        notation.createNumberMarker(config.numberRestMark, config.beatResolution, patternResolution, Math.min(config.lineResolution, patternSize)), \n        patternResolution,\n        asHTML\n      ) );\n    }\n    for( let i = 0; i < lineArray.length; ++i )\n    {\n      formattedLineArray.push( notation.formatLineWithMarkers( config, lineArray[i], patternResolution, asHTML ) );\n    }\n\n    return formattedLineArray.join(\"\\n\");\n  }\n};\n\nexport default notation;","const DEFAULT_INSTRUMENT_SYMBOLS = {\n  \"Djembe Slap\" : \"S\",\n  \"Djembe Tone\" : \"t\",\n  \"Djembe Bass\" : \"O\",\n  \"Snare Ghost\" : \"x\",\n  \"Snare Accent\" : \"X\",\n  \"Shaker Ghost\" : \"x\",\n  \"Shaker Accent\" : \"X\",\n  \"Click\" : \"X\",\n  \"Bass\" : \"O\",\n  \"Tom\" : \"O\",\n  \"Default\" : \"X\"\n};\n\nfunction normalizeInstrumentsForFiguring(instruments)\n{\n  let n = [];\n  for(const inst of instruments)\n  {\n    let nInst = Object.assign({}, inst);\n    // for some reason these instruments are one-size arrays, and one id ... the track id from hydrogen\n    // this should be fixed, this doesn't make sense\n    nInst.name = nInst.name.toLowerCase();\n    n.push( nInst );\n  }\n  return n;\n}\n\nfunction figureDjembes(instrumentsRaw, symbolConfig)\n{\n  const instruments = normalizeInstrumentsForFiguring(instrumentsRaw);\n  const djembeTracks = instruments.filter( (inst) => inst.name.includes(\"djembe\") );\n  if(djembeTracks.length === 0)\n  {\n    return [];\n  }\n  else if(djembeTracks.length <= 3)\n  {\n    // let's lazily assume we have a slap, tone, bass\n    const slapArray = Array.from( djembeTracks, (inst) => inst.name.includes(\"slap\") );\n    const toneArray = Array.from( djembeTracks, (inst) => inst.name.includes(\"tone\") );\n    const bassArray = Array.from( djembeTracks, (inst) => inst.name.includes(\"bass\") );\n    for( let i = 0; i < djembeTracks.length; ++i )\n    {\n      let parityCheck = slapArray[i] + toneArray[i] + bassArray[i];\n      // failed to figure out how djembes work return empty array\n      if(parityCheck !== 1)\n      {\n        return [];\n      }\n    }\n    let djembeMapping = {};\n    for( let i = 0; i < djembeTracks.length; ++i )\n    {\n      if( slapArray[i] )\n      {\n        djembeMapping[ djembeTracks[i].id.toString() ] = symbolConfig[\"Djembe Slap\"];\n      }\n      else if( toneArray[i] )\n      {\n        djembeMapping[ djembeTracks[i].id.toString() ] = symbolConfig[\"Djembe Tone\"];\n      }\n      else if( bassArray[i] )\n      {\n        djembeMapping[ djembeTracks[i].id.toString() ] = symbolConfig[\"Djembe Bass\"];\n      }\n    }\n    return [ [ \"Djembe\", djembeMapping ] ];\n  }\n  else\n  {\n    // TODO: support more than one djembe\n    return []\n  }\n}\n\n// used by snare/shaker\nfunction manageAccentOrGhost(instrumentTracks, instrumentName, accentSymbol, ghostSymbol)\n{\n  let outputInstruments = [];\n  if(instrumentTracks.length === 2)\n  {\n    const t0 = instrumentTracks[0];\n    const t1 = instrumentTracks[1];\n    // attempt to determine ghost/accent\n    const zeroLouder = t0.volume > t1.volume || (t0.volume === t1.volume && t0.gain > t1.gain);\n    let mapping = {};\n    mapping[ t0.id.toString() ] = zeroLouder ? accentSymbol : ghostSymbol;\n    mapping[ t1.id.toString() ] = zeroLouder ? ghostSymbol : accentSymbol;\n    outputInstruments.push([instrumentName, mapping] );  \n  }\n  else // if 1 it must be an accent, if >= 3 ... I don't want to try and assign ghosts/accents\n  {\n    // I don't want to support ghost/accent here right now\n    for( const track of instrumentTracks )\n    {\n      let mapping = {};\n      mapping[ track.id.toString() ] = accentSymbol;\n      outputInstruments.push([instrumentName, mapping] );  \n    }\n  }\n  return outputInstruments;\n\n}\n\nfunction figureShakers(instrumentsRaw, symbolConfig)\n{\n  const instruments = normalizeInstrumentsForFiguring(instrumentsRaw);\n  // todo: support common alternative shakers? Tambourine?\n  const shakerTracks = instruments.filter( (inst) => ( inst.name.includes(\"shaker\") ) );\n  return manageAccentOrGhost( \n    shakerTracks, \n    \"Shaker\", \n    symbolConfig[\"Shaker Accent\"],\n    symbolConfig[\"Shaker Ghost\"]\n  );\n}\n\nfunction figureSnares(instrumentsRaw, symbolConfig)\n{\n  const instruments = normalizeInstrumentsForFiguring(instrumentsRaw);\n  const snareTracks = instruments.filter( (inst) => ( inst.name.includes(\"snare\") ) );\n  // todo: we currently assume 2 snares is accent/ghost ... but I think it's relatively\n  // common to be 2 snare parts too, I think the algorithm here is check patterns to\n  // see if they overlap ... if the \"ghosts\" overlap the \"hits\" sometimes, assume 2 parts\n  return manageAccentOrGhost( \n    snareTracks, \n    \"Snare\", \n    symbolConfig[\"Snare Accent\"],\n    symbolConfig[\"Snare Ghost\"]\n  );\n}\n\n\nfunction activeInstruments(patterns)\n{\n  let nonTrivialInstruments = new Set();\n  for( const p of patterns )\n  {\n    for(const [instrumentID, part] of Object.entries(p.instrumentTracks))\n    {\n      if( !part.empty() )\n      {\n        nonTrivialInstruments.add(parseInt(instrumentID));\n      }\n    }\n  }\n  return nonTrivialInstruments;\n}\n\nfunction activeInstrumentation(instrumentIndex, patterns)\n{\n  const active = activeInstruments(patterns);\n  let nonTrivialInstruments = [];\n  for( const inst of instrumentIndex)\n  {\n    if( active.has(inst.id) )\n    {\n      nonTrivialInstruments.push( inst );\n    }\n  }\n  return nonTrivialInstruments;\n}\n\nfunction figureClickyInstruments(instrumentsRaw, symbolConfig, patterns)\n{\n  const instruments = normalizeInstrumentsForFiguring(instrumentsRaw);\n  const worthwhileInstruments = activeInstruments(patterns);\n  const relevantTracks = instruments.filter( (inst) => ( worthwhileInstruments.has(inst.id) &&\n    !inst.name.includes(\"djembe\") &&\n    ( inst.name.includes(\"click\") || \n    inst.name.includes(\"stick\") || \n    inst.name.includes(\"tom\") || \n    inst.name.includes(\"bass\") ||\n    inst.name.includes(\"kick\") )\n  ) );\n\n  const trackIsClick = Array.from(\n    relevantTracks,\n    (t) => t.name.includes(\"click\") || t.name.includes(\"stick\")\n  );\n  // we prioritise the early tracks\n  // and hope for the best\n\n  let tomIndex = 1;\n  let bassIndex = 1;\n  let collated = [];\n  for( let candidate = 0; candidate < Math.floor(relevantTracks.length/2); ++candidate )\n  {\n    if( trackIsClick[candidate*2] !== trackIsClick[candidate*2+1] )\n    {\n      const clickTrack = trackIsClick[candidate*2] ? relevantTracks[candidate*2] : relevantTracks[candidate*2+1];\n      const hitTrack = trackIsClick[candidate*2] ? relevantTracks[candidate*2+1] : relevantTracks[candidate*2];\n      const instrumentIsTom = hitTrack.name.includes(\"tom\");\n      let rawInstrumentName = instrumentIsTom ? \"Tom\" : \"Bass\";\n      let instrumentName = \"\"\n      if( instrumentIsTom )\n      {\n        instrumentName = rawInstrumentName + ( (tomIndex >= 2) ? \" \" + tomIndex.toString() : \"\" );\n        tomIndex = tomIndex + 1;\n      }\n      else\n      {\n        instrumentName = rawInstrumentName + ( (bassIndex >= 2) ? \" \" + bassIndex.toString() : \"\" );\n        bassIndex = bassIndex + 1;\n      }\n      let mapping = {};\n      mapping[hitTrack.id.toString()] = symbolConfig[rawInstrumentName];\n      mapping[clickTrack.id.toString()] = symbolConfig[\"Click\"];\n      collated.push([instrumentName, mapping] );  \n    }\n  }\n\n  // If there's a remainder instrument and there's no click\n  if( ((relevantTracks.length % 2 ) !== 0) && !trackIsClick[ relevantTracks.length - 1 ] )\n  {\n    const lastTrack = relevantTracks[relevantTracks.length - 1];\n    const instrumentIsTom = lastTrack.name.includes(\"tom\");\n    let rawInstrumentName = instrumentIsTom ? \"Tom\" : \"Bass\";\n    let instrumentName = \"\"\n    if( instrumentIsTom )\n    {\n      instrumentName = rawInstrumentName + ( (tomIndex >= 2) ? \" \" + tomIndex.toString() : \"\" );\n      tomIndex = tomIndex + 1;\n    }\n    else\n    {\n      instrumentName = rawInstrumentName + ( (bassIndex >= 2) ? \" \" + bassIndex.toString() : \"\" );\n      bassIndex = bassIndex + 1;\n    }\n    let mapping = {};\n    mapping[lastTrack.id.toString()] = symbolConfig[rawInstrumentName];\n    collated.push([instrumentName, mapping] );  \n  }\n  return collated;\n}\n\nfunction defaultSymbolForSingleInstrument(symbolConfig, name)\n{\n  // we expect these keys\n  /*\n    \"Djembe Slap\" : \"S\",\n    \"Djembe Tone\" : \"t\",\n    \"Djembe Bass\" : \"O\",\n    \"Snare Ghost\" : \"-\",\n    \"Snare Accent\" : \"X\",\n    \"Shaker Ghost\" : \"x\",\n    \"Shaker Accent\" : \"X\",\n    \"Click\" : \"X\",\n    \"Bass\" : \"O\",\n    \"Tom\" : \"O\",\n    \"Default\" : \"X\"\n  */\n  const lowerName = name.toLowerCase();\n  if( lowerName.includes(\"click\") || lowerName.includes(\"stick\") )\n  {\n    return symbolConfig[\"Click\"];\n  }  \n  else if( lowerName.includes(\"bass\") || lowerName.includes(\"kick\") )\n  {\n    return symbolConfig[\"Bass\"]\n  }\n  else if( lowerName.includes(\"snare\") )\n  {\n    return symbolConfig[\"Snare Accent\"];\n  }\n  else if( lowerName.includes(\"shaker\") )\n  {\n    return symbolConfig[\"Shaker\"];\n  }\n  else if( lowerName.includes(\"tom\") )\n  {\n    return symbolConfig[\"Tom\"];\n  }\n  else if( lowerName.includes(\"djembe\") )\n  {\n    if( lowerName.includes(\"slap\") )\n    {\n      return symbolConfig[\"Djembe Slap\"];\n    }\n    else if( lowerName.includes(\"tone\") )\n    {\n      return symbolConfig[\"Djembe Tone\"];\n    }\n    else\n    {\n      return symbolConfig[\"Djembe Bass\"];\n    }\n  }\n  return symbolConfig[\"Default\"];\n}\n\nfunction figureInstruments(instrumentsRaw, symbolConfig, patterns)\n{\n  let output = [];\n  output = output.concat( figureClickyInstruments( instrumentsRaw, symbolConfig, patterns ) );\n  output = output.concat( figureDjembes( instrumentsRaw, symbolConfig ) );\n  output = output.concat( figureSnares( instrumentsRaw, symbolConfig ) );\n  output = output.concat( figureShakers( instrumentsRaw, symbolConfig ) );\n\n  // we ignore track used by multiple instruments\n\n  // but attempt to cover \"instrument not recognised anywhere\"\n\n  const worthwhileInstruments = activeInstruments(patterns);\n\n  for(const inst of instrumentsRaw)\n  {\n    if( !worthwhileInstruments.has(inst.id) )\n    {\n      continue;\n    }\n    let instrumentUsed = false;\n    for( const op of output)\n    {\n      if( inst.id.toString() in op[1] ) \n      {\n        instrumentUsed = true;\n      }\n    }\n    if(instrumentUsed === false)\n    {\n      let mapping = {};\n      mapping[ inst.id.toString() ] = defaultSymbolForSingleInstrument( symbolConfig, inst.name );\n      output.push( [inst.name, mapping] );\n    }\n  }\n  \n  return output; \n}\n\nexport { activeInstrumentation, DEFAULT_INSTRUMENT_SYMBOLS, figureClickyInstruments, figureDjembes, figureShakers, figureSnares, figureInstruments };","import React from 'react';\nimport { makeStyles } from '@material-ui/core/styles';\nimport FormControlLabel from '@material-ui/core/FormControlLabel';\nimport Checkbox from '@material-ui/core/Checkbox';\n\n// table\nimport Table from '@material-ui/core/Table';\nimport TableBody from '@material-ui/core/TableBody';\nimport TableCell from '@material-ui/core/TableCell';\nimport TableContainer from '@material-ui/core/TableContainer';\nimport TableHead from '@material-ui/core/TableHead';\nimport TableRow from '@material-ui/core/TableRow';\n\nimport AddBoxIcon from '@material-ui/icons/AddBox';\nimport EditIcon from '@material-ui/icons/Edit';\nimport Button from '@material-ui/core/Button';\nimport IconButton from '@material-ui/core/IconButton';\nimport ClearIcon from '@material-ui/icons/Clear';\n\nimport TextField from '@material-ui/core/TextField';\nimport Dialog from '@material-ui/core/Dialog';\nimport DialogActions from '@material-ui/core/DialogActions';\nimport DialogContent from '@material-ui/core/DialogContent';\nimport DialogContentText from '@material-ui/core/DialogContentText';\nimport DialogTitle from '@material-ui/core/DialogTitle';\nimport { withStyles } from '@material-ui/core/styles';\nimport Typography from '@material-ui/core/Typography';\n\nconst useStyles = makeStyles((theme) => ({\n  root: {\n    display: 'flex',\n  }\n}));\n\nconst ThinFormControlLabel = withStyles({\n  root: {\n    marginLeft: 0,\n    marginRight: 0\n  }\n})(FormControlLabel);\n\nconst InlinableIconButton = withStyles({\n  root: {\n    padding: 2\n  }\n})(IconButton);\n\nconst CenterTableCell = withStyles({\n  root: {\n    textAlign: \"center\"\n  }\n})(TableCell);\n\nfunction InstrumentConfig(props) {\n  const classes = useStyles();\n\n  const handleChange = (x,y, event) => {\n    const instrumentID = props.instrumentIndex[x].id;\n    const oldInstrumentIndex = props.instruments.findIndex( instrument => instrumentID in instrument[1]);\n    const dstInstrumentIndex = y;\n    if( oldInstrumentIndex === dstInstrumentIndex )\n    {\n      return;\n    }\n    const oldInstrument = props.instruments[oldInstrumentIndex];\n    let replacedSrcInstrument = [\n      \"\",\n      {}\n    ];\n    if( oldInstrument != null )\n    {\n      replacedSrcInstrument[0] = oldInstrument[0];\n      for( const key of Object.keys(oldInstrument[1]) )\n      {\n        if( key !== instrumentID.toString() )\n        {\n          replacedSrcInstrument[1][key] = oldInstrument[1][key];\n        }\n      }\n    }\n    let dstInstrument = [\n      props.instruments[dstInstrumentIndex][0],\n      Object.assign({}, props.instruments[dstInstrumentIndex][1] )\n    ];\n    if(oldInstrument != null )\n    {\n      dstInstrument[1][instrumentID.toString()] = oldInstrument[1][instrumentID];\n    }\n    else\n    {\n      dstInstrument[1][instrumentID.toString()] = \"X\";\n    }\n\n    let replacedInstruments = [];\n\n    for(let instrumentIndex = 0; instrumentIndex < props.instruments.length; ++instrumentIndex)\n    {\n      if( instrumentIndex === oldInstrumentIndex )\n      {\n        replacedInstruments.push( replacedSrcInstrument );\n      }\n      else if( instrumentIndex === dstInstrumentIndex )\n      {\n        replacedInstruments.push( dstInstrument )\n      }\n      else\n      {\n        replacedInstruments.push( props.instruments[instrumentIndex] );\n      }\n    }\n    props.onChange(replacedInstruments);\n  };\n\n  const removeInstrument = (y) => \n  {\n    let replacedInstruments = props.instruments.slice(0,y).concat(props.instruments.slice(y+1));\n    props.onChange(replacedInstruments);\n  };\n\n  const [renamingInstrument, setRenamingInstrument] = React.useState(-1);\n  let [nameState, setNameState] = React.useState(\"\");\n\n  const createCell = (x,y) =>\n  {\n      return ( \n        <TableCell\n          align=\"center\"\n          key={\"instrumentPanel-cell-\" + y.toString() + \"-\" + x.toString()}\n        >\n        <ThinFormControlLabel\n          control={<Checkbox checked={props.instrumentMask[x] === y} onChange={(e) => handleChange(x,y,e)} name={x + \",\" + y.toString()} />}\n        />\n        </TableCell>\n      );\n  }\n\n  const createMatchingRow = (y) =>\n  {\n    return (\n      <TableRow key={\"instrumentPanel-row-\" + y.toString()}>\n        <TableCell component=\"th\" scope=\"row\" key={\"instrumentPanel-row-\" + y.toString() + \"-name\"}> \n          <Typography>{props.instruments[y][0]}</Typography>\n          <InlinableIconButton onClick={(e)=>setRenamingInstrument(y)}><EditIcon fontSize=\"small\"/></InlinableIconButton>\n          <InlinableIconButton onClick={(e)=>{removeInstrument(y);}}><ClearIcon fontSize=\"small\"/></InlinableIconButton>\n        </TableCell>\n        {[...Array(props.instrumentIndex.length).keys()].map(x=>createCell(x,y))}\n      </TableRow>\n    );\n  };\n\n  const createEditRow = () =>\n  {\n    return (\n      <TableRow key={\"instrumentPanel-row-edit\"}>\n        <TableCell component=\"th\" scope=\"row\" key={\"instrumentPanel-row-edit-cell\"}>\n          <IconButton onClick={(e)=>setRenamingInstrument(props.instruments.length)} aria-label=\"add\">\n            <AddBoxIcon/>\n          </IconButton>\n        </TableCell>\n      </TableRow>\n    );\n  };\n\n  const renameInstrument = (e)  => \n  {\n    const instrumentName = nameState.trim();\n    if( instrumentName.length > 0 )\n    {\n      if( renamingInstrument === props.instruments.length )\n      {\n        const extraInstrument = [ instrumentName, {} ];\n        let replacedInstruments = Array.from( props.instruments );\n        replacedInstruments.push(extraInstrument);\n        props.onChange(replacedInstruments);\n      }\n      else\n      {\n        let replacedInstruments = Array.from( props.instruments );\n        replacedInstruments[renamingInstrument][0] = instrumentName;\n        props.onChange(replacedInstruments);\n      }\n    }\n    // we just ignore empty string\n    setRenamingInstrument(-1);\n    setNameState(\"\");\n  };\n\n  // todo: The text field is very slow\n  // that could be because the dialog and the table content are all one component\n  // I should try and fix that first\n  // otherwise, it's just that shoving react in the middle is too slow\n\n  const [editSymbol, setEditSymbol] = React.useState(-1);\n  let [editSymbolState, setEditSymbolState] = React.useState(\"\");\n\n  const startEditingSymbol = (x) =>\n  {\n    const instrumentID = props.instrumentIndex[x].id;\n    const instrumentIndex = props.instruments.findIndex( instrument => instrumentID in instrument[1]);\n    const currentSymbol = props.instruments[instrumentIndex][1][instrumentID];\n    setEditSymbolState(currentSymbol);\n    setEditSymbol(x);\n  };\n\n  const changeSymbol = (e) =>\n  {\n    const updatedSymbol = editSymbolState;\n    if(updatedSymbol.length===1)\n    {\n      const instrumentID = props.instrumentIndex[editSymbol].id;\n      const instrumentIndex = props.instruments.findIndex( instrument => instrumentID in instrument[1]);\n      let replacedInstruments = Array.from(props.instruments);\n      replacedInstruments[instrumentIndex][1][instrumentID] = editSymbolState;\n      props.onChange(replacedInstruments);\n    }\n    else\n    {\n      // todo: prettier error communication?\n      alert(\n        \"You selected an invalid symbol \\\"\" + updatedSymbol + \"\\\".\\n\" + \n        \"Symbols must be precisely 1 character.\"\n      );\n    }\n    setEditSymbol(-1);\n  };\n\n  return (\n    <React.Fragment>\n      <Dialog open={renamingInstrument >= 0} onClose={(e)=>setRenamingInstrument(-1)} aria-labelledby=\"form-dialog-title\">\n        <DialogTitle id=\"form-dialog-title\"></DialogTitle>\n        <DialogContent>\n          <DialogContentText>\n            Enter instrument name\n          </DialogContentText>\n          <TextField\n            autoFocus\n            margin=\"dense\"\n            id=\"name\"\n            fullWidth\n            value={nameState}\n            onChange={(e)=>setNameState(e.target.value)}\n          />\n        </DialogContent>\n        <DialogActions>\n          <Button onClick={(e)=>setRenamingInstrument(-1)} color=\"primary\">\n            Cancel\n          </Button>\n          <Button onClick={renameInstrument} color=\"primary\">\n            Confirm\n          </Button>\n        </DialogActions>\n      </Dialog>\n      <Dialog open={editSymbol >= 0} onClose={(e)=>setEditSymbol(-1)} aria-labelledby=\"form-dialog-title\">\n        <DialogTitle id=\"form-dialog-title\"></DialogTitle>\n        <DialogContent>\n          <DialogContentText>\n            Enter notation symbol\n          </DialogContentText>\n          <TextField\n            autoFocus\n            margin=\"dense\"\n            id=\"name\"\n            fullWidth\n            value={editSymbolState}\n            onChange={(e)=>setEditSymbolState(e.target.value)}\n          />\n        </DialogContent>\n        <DialogActions>\n          <Button onClick={(e)=>setEditSymbol(-1)} color=\"primary\">\n            Cancel\n          </Button>\n          <Button onClick={changeSymbol} color=\"primary\">\n            Confirm\n          </Button>\n        </DialogActions>\n      </Dialog>\n      <TableContainer>\n        <Table className={classes.table} aria-label=\"simple table\">\n          <TableHead>\n            <TableRow key={\"instrumentPanel-row-header\"}>\n              <TableCell key={\"instrumentPanel-row-instrument\"}> Instrument </TableCell>\n              {[...Array(props.instrumentIndex.length).keys()].map(x=><CenterTableCell key={\"instrumentPanel-row-header-cell-\" + x.toString()}><Typography>{props.instrumentIndex[x].name}</Typography><InlinableIconButton onClick={(e)=>startEditingSymbol(x)} ><EditIcon fontSize=\"small\"/></InlinableIconButton></CenterTableCell>)}\n            </TableRow>\n          </TableHead>\n          <TableBody>\n\n            {[...Array(props.instruments.length).keys()].map(y=>createMatchingRow(y))}\n            {createEditRow()}\n          </TableBody>\n        </Table>\n      </TableContainer>\n    </React.Fragment>\n  );\n}\n\nfunction createInstrumentMask(instrumentIndex, instruments)\n{\n  let instrumentMask = Array(instrumentIndex.length);\n  for( let baseInstrumentIndex = 0; baseInstrumentIndex < instrumentIndex.length; ++baseInstrumentIndex )\n  {\n    const baseInstrumentId = instrumentIndex[baseInstrumentIndex].id;\n    for( let targetInstrumentIndex = 0; targetInstrumentIndex < instruments.length; ++targetInstrumentIndex)\n    {\n      const target = instruments[targetInstrumentIndex];\n      if(baseInstrumentId.toString() in target[1])\n      {\n        instrumentMask[baseInstrumentIndex] = targetInstrumentIndex;\n      }\n    }\n  }\n  return instrumentMask;\n}\n\nexport { createInstrumentMask, InstrumentConfig };","import { calculateResolution } from \"./utilities\"\n\n// stolen from https://studymaths.co.uk/topics/findingHCFWithJavaScript.php\nfunction findHCF(x, y) {\n\n   // If the input numbers are less than 1 return an error message.\n   if (x < 1 || y < 1) {\n    throw new Error(\"x<1 || y<1\");\n      // return \"Please enter values greater than zero.\";\n   }\n\n   // Now apply Euclid's algorithm to the two numbers.\n   while (Math.max(x, y) % Math.min(x, y) !== 0) {\n      if (x > y) {\n         x %= y;\n      }\n      else {\n         y %= x;\n      }\n   }\n   \n   // When the while loop finishes the minimum of x and y is the HCF.\n   return Math.min(x, y);\n}\n\nclass track\n{\n  \n  constructor(patternArray, resolution)\n  {\n    if(patternArray.length === 0)\n    {\n      throw new Error(\"patternArray must not be zero length\");\n    }\n    this.rep = patternArray;\n    this.resolution = resolution;\n  }\n\n  length()\n  {\n    return this.rep.length * this.resolution;\n  }\n\n  empty()\n  {\n    return this.rep.reduce( (a,b) => ( a + b ) ) === 0;\n  }\n\n  _sumOverlapsOfArrays(a,b)\n  {\n    let count = 0;\n    for( let i = 0; i < a.length; ++i)\n    {\n      if(a[i] && b[i])\n      {\n        count++;\n      }\n    }\n    return count;\n  }\n\n  countOverlaps(other)\n  {\n    if( this.resolution === other.resolution )\n    {\n      return this._sumOverlapsOfArrays( this.rep, other.rep );\n    }\n    else\n    {\n      const hcf = findHCF(this.resolution, other.resolution);\n      const a = this.formatResolution( hcf );\n      const b = other.formatResolution( hcf );\n      return this._sumOverlapsOfArrays( a.rep, b.rep );\n    }\n  }\n\n  aggregate(other)\n  {\n\n    if( this.resolution === other.resolution )\n    {\n      // when we aggregate, we specifically\n      const length = Math.max( this.rep.length, other.rep.length );\n      const pat = new Array(length).fill(0);\n      for(let index = 0; index < pat.length; ++index)\n      {\n        pat[index] = ( ( index < this.rep.length ) ? this.rep[index] : 0 )\n                  || ( ( index < other.rep.length ) ? other.rep[index] : 0 );\n      }\n      return new track( pat, this.resolution );\n    }\n    else\n    {\n      const hcf = findHCF(this.resolution, other.resolution);\n      const a = this.formatResolution( hcf );\n      const b = other.formatResolution( hcf );\n      return a.aggregate(b);\n    }\n  }\n\n  static representPoints(points, resolution, size)\n  {\n    if( size <= 0 )\n    {\n      throw new Error(\"size must be greater than zero\");\n    }\n    if( size < resolution || (size % resolution) !== 0)\n    {\n      throw new Error(\"resolution must be less than size and divide it evenly\");\n    }\n    let s = new Array(size / resolution).fill(0);\n    for( const p of points )\n    {\n      if( (p % resolution) !== 0)\n      {\n        throw new Error(\"Failed to represent point \" + p.toString() + \" at resolution \" + resolution.toString());\n      }\n      if (p >= size)\n      {\n        throw new Error(\"Failed to represent point \" + p.toString() + \" for invalid specified size \" + size.toString());\n      }\n      const arrayIndex = p / resolution;\n      s[arrayIndex] = 1;\n    }\n    return s;\n  }\n\n  format(formatResolution)\n  {\n    // formatResolution must cleanly divide for every hit & the length of the pattern\n\n    const totalLength = (this.resolution * this.rep.length);\n    const points = this.toPoints();\n    const rep = track.representPoints(points, formatResolution, totalLength);\n    if(!rep)\n    {\n      return null;\n    }\n    return new track(\n      rep,\n      formatResolution\n    );\n  }\n\n  toPoints()\n  {\n    let points = [];\n    for( const arrayIndex of Array(this.rep.length).keys() )\n    {\n      const indicator = this.rep[arrayIndex];\n      if(indicator)\n      {\n        points.push( this.resolution * arrayIndex )\n      }\n    }\n    return points;\n  }\n\n  static fromPositions(positions, size, resolution = null)\n  {\n    const resolutionToUse = resolution ?? calculateResolution( positions, size );\n    return new track( \n      track.representPoints(positions, resolutionToUse, size), \n      resolutionToUse\n    );\n  }\n}\n\nexport default track;","// utilities.js\n\nfunction calculateResolution(positions, size)\n{\n  // hydrogen treats 48 as a beat\n  const basesToTry = [\n    48, // beat\n    24, // 1/2 beat\n    16, // 1/3 beat\n    12, // 1/4\n    8, // 1/6 \n    6, // 1/8\n    4, // 1/12\n    3, // 1/16\n    2, // 1/24\n    1 // 1/48\n  ];\n\n  // note that, fundamentally the size of the pattern is a \"keypoint\"\n  // that needs to be properly recorded by the resolution\n  const implicitPositions = positions.concat( [size] );\n\n  for( const b of basesToTry )\n  {\n    let allNotesPass = true;\n    for( const p of implicitPositions )\n    {\n      if( (p % b) !== 0 )\n      {\n        allNotesPass = false;\n        break;\n      }\n    }\n    if(allNotesPass)\n    {\n      return b;\n    }\n  }\n  throw new Error(\"Failed to predict base\");\n}\n\nexport { calculateResolution };"],"sourceRoot":""}