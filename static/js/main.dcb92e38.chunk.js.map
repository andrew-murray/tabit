{"version":3,"sources":["track.js","utilities.js","TabitBar.js","Audio.js","ToneController.js","App.js","formatSettings.js","FileImport.js","h2.js","PlaybackControls.js","History.js","Part.js","PartWithTitle.js","Pattern.js","Routes.js","serviceWorker.js","index.js","notation.js","Mobile.js","instrumentation.js","instrumentConfig.js"],"names":["findHCF","x","y","Error","Math","max","min","track","patternArray","resolution","length","this","rep","reduce","a","b","count","i","other","_sumOverlapsOfArrays","hcf","formatResolution","pat","Array","fill","index","aggregate","totalLength","points","toPoints","representPoints","keys","arrayIndex","push","size","s","p","toString","positions","resolutionToUse","calculateResolution","implicitPositions","concat","allNotesPass","useStyles","makeStyles","theme","root","zIndex","drawer","backgroundColor","color","TabitBar","props","classes","placeholder","variant","position","className","aria-label","edge","onClick","patternsToggle","component","Link","to","noWrap","style","title","settingsToggle","Audio","window","AudioContext","webkitAudioContext","Object","instrumentIndex","tracks","minResolution","id","t","filter","inst","empty","entries","trackLength","combined","peakValue","channel","numberOfChannels","combinedChannel","getChannelData","sample","abs","peakAmplitude","context","sounds","tempo","determineTrackLength","trackLengthSamples","totalSamples","floor","samplesPerHydrogen","createBuffer","selected","audioBuffer","audioChannel","trackPoints","sampleStart","normalizeAudioBuffer","buffer","source","createBufferSource","loop","playbackRate","value","connect","destination","AUDIO_DELAY","DRUMKITS","convertNormalToAudible","pow","ToneController","patterns","onTimeChange","latencyHint","Tone","samples","currentPattern","gain","toDestination","onPatternTimeChange","bpm","sampleCount","expectedSampleCount","patternDetails","failures","name","determineMinResolution","instrumentTracks","pattern","populateSamples","currentPatternName","message","sortedFailures","drumkit","noMatch","otherDrumkit","otherName","sort","createSortedUnique","join","alert","stop","cancel","selectedInstrument","clampedVolume","volume","includes","filename","replace","player","process","mute","muted","relativeUrl","drumkitName","instrumentName","toLowerCase","chooseAppropriateUrlForInstrument","patternResolution","patternLength","callback","sampleSource","samplesReady","time","indexFromStart","sampleData","undefined","start","schedule","state","notePosition","createSequenceCallback","seq","_part","sequences","createSequenceForPattern","patternName","oldPatternName","oldLength","timeFromBarEnd","loopEnd","toSeconds","queueTransition","nextSequence","enableNewTrack","sequence","setLoopPoints","scheduleOnce","then","now","instrumentID","set","responsiveFontSizes","createMuiTheme","palette","type","primary","main","secondary","ignoreEvent","event","key","getJsonStorageUrl","slug","getJsonDestinationUrl","licenseBannerStyles","bottom","modalStyles","modal","display","alignItems","justifyContent","paper","background","border","boxShadow","shadows","padding","spacing","App","previousHistory","localStorage","getItem","instruments","instrumentMask","formatSettings","assign","DefaultSettings","patternSettings","loadedFile","selectedPattern","settingsOpen","patternsOpen","progress","showSharingDialog","showTitleOptions","match","params","song","songName","permanentUrl","history","JSON","parse","date","React","createRef","document","app","exportState","getExportState","stateToShare","encodeState","stateHash","hash","from","relevantHistory","Date","historyEntry","content","restrictedHistory","slice","setState","setItem","stringify","songID","songTitle","fetch","response","json","js","decodedState","decodeState","handleJson","catch","e","inputSong","Promise","resolve","err","fetchSong","audio","teardown","version","destFilename","fileParts","split","blob","Blob","saveAs","zlib","deflateSync","binaryBuffer","Buffer","decompressedString","inflateSync","uploadUrl","metadata","method","headers","body","origin","notation","guessPerPatternSettings","prevState","createInstrumentMask","patternData","replacedTracks","trackData","patternWithTracks","createTracks","songNameFromFile","isMobile","setActivePattern","recordSongVisited","file","h2","parseHydrogenPromise","h","assessedInstruments","figureInstruments","DEFAULT_INSTRUMENT_SYMBOLS","activeInstrumentation","figurePatternSettings","error","k","createObjects","kuva","patternIndex","resolvedSettings","Fragment","config","active","ref","onPlay","play","onStop","onTempoChange","setTempo","current","optionalAlert","severity","controls","loadExample","bind","margin","onImport","handleFileImport","accept","waitingMessage","data","piece","loadLocalSong","href","iOS","mobile","handlePatternsToggle","disableBackdropTransition","disableDiscovery","open","onOpen","onClose","overflow","map","button","selectPattern","patternConfig","handleSettingsToggle","patternToRender","getTrackLength","anchor","drawerPaper","onChange","existingPatternSettings","existingGlobalSettings","v","settings","default","save","share","aria-labelledby","aria-describedby","copy","renderTitlePage","patternContent","renderPattern","browser","test","navigator","userAgent","instrumentConfigColumns","renderSharingDialog","container","item","xs","onVolumeEvent","instrument","setVolumeForInstrument","setMutedForInstrument","renderPatternDrawer","renderSettingsDrawer","mainContent","renderMainContent","Component","withStyles","withRouter","formControl","minWidth","camelToReadable","spacedString","toUpperCase","FormatSettings","useTheme","tokenStateToItem","tokenItemToState","handleOptionChange","updatedState","handleCheckedChange","target","checked","createOptionMenu","options","itemToState","stateToItem","idString","labelId","op","lineLengths","beatResolution","beatResolutions","c","lineResolution","FORMAT_CONFIG_STRINGS","prev","curr","FORMAT_CONFIG_BOOLS","control","label","parseInt","r","DEFAULT_FORMAT_CONFIG","FileImport","hiddenFileInput","fileObject","files","reader","FileReader","onload","loadEvent","result","readAsText","buttonProps","click","hidden","calculatePatternResolution","notes","note","parseHydrogenJs","instrumentElements","instrumentList","instrumentArray","element","instrumentComponent","parseFloat","isMuted","layer","patternElements","patternList","noteElements","noteList","patternSize","noteElement","n","patternsWithTracks","relevantNotes","relevantHits","fromPositions","virtualPatternList","virtualPatternGroups","patternToRelated","virtualGroup","rootPatternName","relatedPatterns","virtual","Set","iteration","expandedObject","objectHasExpanded","related","expandedNodeSet","node","relatedPatternSet","rootPattern","find","patternToMergeName","patternToMerge","merged","copiedTrack","format","xmlString","parser","xml2js","Parser","parseStringPromise","moduleExports","PlaybackControls","defaultValue","step","valueLabelDisplay","width","height","maxWidth","demoData","History","items","maxHeight","toLocaleDateString","renderRow","styles","whiteSpace","fontFamily","fontSize","PreTypography","Typography","Part","values","formatPatternString","restMark","patternLines","chunkArray","beatsPerLine","beatChunkSize","linesWithBeats","line","lineIndices","formatLine","startBeat","beats","lineMark","beat","activeNote","showBeatMark","beatMark","numberLine","createNumberMarker","numberRestMark","beatChunks","showBeatNumbers","lineIndex","PartWithTitle","Title","headingLevel","defaultLevel","safeHeading","getTitleType","Pattern","patternTime","instrumentIndices","textAlign","Routes","basename","path","Boolean","location","hostname","ReactDOM","render","StrictMode","getElementById","serviceWorker","ready","registration","unregister","console","formatConfig","propName","hasOwnProperty","str","chunkSize","RegExp","chunks","lineLength","beatCount","ceil","numberMarkerArray","asHTML","validateConfig","formatSymbol","symbol","numericPosition","formattedLine","charAt","lineWithBeats","chunkString","trackDict","defaultLineResolution","charIndex","trackID","trackSymbol","trackInstance","resolveConfig","patternString","lineArray","formattedLineArray","formatLineWithMarkers","vendor","opera","some","toMatchItem","normalizeInstrumentsForFiguring","nInst","manageAccentOrGhost","accentSymbol","ghostSymbol","outputInstruments","t0","t1","zeroLouder","mapping","activeInstruments","nonTrivialInstruments","add","has","defaultSymbolForSingleInstrument","symbolConfig","lowerName","instrumentsRaw","output","worthwhileInstruments","relevantTracks","trackIsClick","tomIndex","bassIndex","collated","candidate","clickTrack","hitTrack","instrumentIsTom","rawInstrumentName","lastTrack","figureClickyInstruments","djembeTracks","slapArray","toneArray","bassArray","djembeMapping","figureDjembes","figureSnares","figureShakers","instrumentUsed","ThinFormControlLabel","marginLeft","marginRight","FormControlLabel","InlinableIconButton","IconButton","NoDividerCenterTableCell","borderBottom","paddingBottom","TableCell","CenterTableCell","VolumeWidget","useState","setActive","sliderValue","setSliderValue","setMuted","sliderRef","useRef","FixedHeightStylings","top","SliderStyles","paddingLeft","IconStyles","onClickNHold","dispatchEvent","nativeEvent","onEnd","disableRipple","disableFocusRipple","onMuteEvent","orientation","setVolume","RawInstrumentEditDialog","currentSymbol","onCancel","confirm","autoFocus","fullWidth","onKeyDown","keyCode","preventDefault","InstrumentRenameDialog","currentName","trim","InstrumentTable","createCell","align","oldInstrumentIndex","findIndex","dstInstrumentIndex","oldInstrument","replacedSrcInstrument","dstInstrument","replacedInstruments","handleChange","createMatchingRow","scope","onEditRow","editRow","onRemoveRow","removeRow","table","onEditColumn","editColumn","onAddRow","InstrumentConfig","editingSymbol","setEditingSymbol","renamingInstrument","setRenamingInstrument","endEditingSymbol","resolvedSymbol","extraInstrument","renameInstrument","getSymbol","removeInstrument","baseInstrumentIndex","baseInstrumentId","targetInstrumentIndex"],"mappings":"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","file":"static/js/main.dcb92e38.chunk.js","sourcesContent":["import { calculateResolution } from \"./utilities\"\n\n// stolen from https://studymaths.co.uk/topics/findingHCFWithJavaScript.php\nfunction findHCF(x, y) {\n\n   // If the input numbers are less than 1 return an error message.\n   if (x < 1 || y < 1) {\n    throw new Error(\"x<1 || y<1\");\n      // return \"Please enter values greater than zero.\";\n   }\n\n   // Now apply Euclid's algorithm to the two numbers.\n   while (Math.max(x, y) % Math.min(x, y) !== 0) {\n      if (x > y) {\n         x %= y;\n      }\n      else {\n         y %= x;\n      }\n   }\n\n   // When the while loop finishes the minimum of x and y is the HCF.\n   return Math.min(x, y);\n}\n\nclass track\n{\n\n  constructor(patternArray, resolution)\n  {\n    if(patternArray.length === 0)\n    {\n      throw new Error(\"patternArray must not be zero length\");\n    }\n    this.rep = patternArray;\n    this.resolution = resolution;\n  }\n\n  length()\n  {\n    return this.rep.length * this.resolution;\n  }\n\n  empty()\n  {\n    return this.rep.reduce( (a,b) => ( a + b ) ) === 0;\n  }\n\n  _sumOverlapsOfArrays(a,b)\n  {\n    let count = 0;\n    for( let i = 0; i < a.length; ++i)\n    {\n      if(a[i] && b[i])\n      {\n        count++;\n      }\n    }\n    return count;\n  }\n\n  countOverlaps(other)\n  {\n    if( this.resolution === other.resolution )\n    {\n      return this._sumOverlapsOfArrays( this.rep, other.rep );\n    }\n    else\n    {\n      const hcf = findHCF(this.resolution, other.resolution);\n      const a = this.formatResolution( hcf );\n      const b = other.formatResolution( hcf );\n      return this._sumOverlapsOfArrays( a.rep, b.rep );\n    }\n  }\n\n  aggregate(other)\n  {\n\n    if( this.resolution === other.resolution )\n    {\n      // when we aggregate, we specifically\n      const length = Math.max( this.rep.length, other.rep.length );\n      const pat = new Array(length).fill(0);\n      for(let index = 0; index < pat.length; ++index)\n      {\n        pat[index] = ( ( index < this.rep.length ) ? this.rep[index] : 0 )\n                  || ( ( index < other.rep.length ) ? other.rep[index] : 0 );\n      }\n      return new track( pat, this.resolution );\n    }\n    else\n    {\n      const hcf = findHCF(this.resolution, other.resolution);\n      const a = this.formatResolution( hcf );\n      const b = other.formatResolution( hcf );\n      return a.aggregate(b);\n    }\n  }\n\n  static representPoints(points, resolution, size)\n  {\n    if( size <= 0 )\n    {\n      throw new Error(\"size must be greater than zero\");\n    }\n    if( size < resolution || (size % resolution) !== 0)\n    {\n      throw new Error(\"resolution must be less than size and divide it evenly\");\n    }\n    let s = new Array(size / resolution).fill(0);\n    for( const p of points )\n    {\n      if( (p % resolution) !== 0)\n      {\n        throw new Error(\"Failed to represent point \" + p.toString() + \" at resolution \" + resolution.toString());\n      }\n      if (p >= size)\n      {\n        throw new Error(\"Failed to represent point \" + p.toString() + \" for invalid specified size \" + size.toString());\n      }\n      const arrayIndex = p / resolution;\n      s[arrayIndex] = 1;\n    }\n    return s;\n  }\n\n  format(formatResolution)\n  {\n    // formatResolution must cleanly divide for every hit & the length of the pattern\n\n    const totalLength = (this.resolution * this.rep.length);\n    const points = this.toPoints();\n    const rep = track.representPoints(points, formatResolution, totalLength);\n    if(!rep)\n    {\n      return null;\n    }\n    return new track(\n      rep,\n      formatResolution\n    );\n  }\n\n  toPoints()\n  {\n    let points = [];\n    for( const arrayIndex of Array(this.rep.length).keys() )\n    {\n      const indicator = this.rep[arrayIndex];\n      if(indicator)\n      {\n        points.push( this.resolution * arrayIndex )\n      }\n    }\n    return points;\n  }\n\n  static fromPositions(positions, size, resolution = null)\n  {\n    const resolutionToUse = resolution ?? calculateResolution( positions, size );\n    return new track(\n      track.representPoints(positions, resolutionToUse, size),\n      resolutionToUse\n    );\n  }\n}\n\nexport default track;","// utilities.js\n\nfunction calculateResolution(positions, size)\n{\n  // hydrogen treats 48 as a beat\n  const basesToTry = [\n    48, // beat\n    24, // 1/2 beat\n    16, // 1/3 beat\n    12, // 1/4\n    8, // 1/6\n    6, // 1/8\n    4, // 1/12\n    3, // 1/16\n    2, // 1/24\n    1 // 1/48\n  ];\n\n  // note that, fundamentally the size of the pattern is a \"keypoint\"\n  // that needs to be properly recorded by the resolution\n  const implicitPositions = positions.concat( [size] );\n\n  for( const b of basesToTry )\n  {\n    let allNotesPass = true;\n    for( const p of implicitPositions )\n    {\n      if( (p % b) !== 0 )\n      {\n        allNotesPass = false;\n        break;\n      }\n    }\n    if(allNotesPass)\n    {\n      return b;\n    }\n  }\n  throw new Error(\"Failed to predict base\");\n}\n\nexport { calculateResolution };","import React from 'react';\nimport Toolbar from '@material-ui/core/Toolbar';\nimport AppBar from '@material-ui/core/AppBar';\nimport { makeStyles } from '@material-ui/core/styles';\n\n\nimport IconButton from '@material-ui/core/IconButton';\nimport MenuIcon from '@material-ui/icons/Menu';\nimport HomeIcon from '@material-ui/icons/Home';\nimport { Link } from 'react-router-dom';\nimport Typography from '@material-ui/core/Typography';\nimport SettingsIcon from \"@material-ui/icons/Settings\";\n\nconst useStyles = makeStyles((theme) => ({\n  root: {\n    zIndex: theme.zIndex.drawer + 1,\n    backgroundColor: \"#0077b6\",\n    color: \"white\"\n  }\n}));\n\nfunction TabitBar(props) {\n  const classes = useStyles(props);\n  // we need to render \"null\" appbars for spacing purposes\n  // support them here, so that we can maintain layout parity in one place\n  if(props.placeholder)\n  {\n\n    return (\n\n      // <AppBar position=\"fixed\" // todo: I'd like to include the AppBar,\n      // className={classes.root}> // but it doesn't have the correct effect#\n        <Toolbar variant=\"dense\">\n        </Toolbar>\n      // </AppBar>\n    );\n  }\n\n  return (\n    <AppBar position=\"fixed\"\n      className={classes.root}\n    >\n\n      <Toolbar variant=\"dense\">\n        <IconButton\n          color=\"inherit\"\n          aria-label=\"open pattern list\"\n          edge=\"start\"\n          onClick={props.patternsToggle}\n          >\n          <MenuIcon />\n        </IconButton>\n        <IconButton\n          color=\"inherit\"\n          aria-label=\"home\"\n          edge=\"start\"\n          component={Link}\n          to='/'\n          >\n          <HomeIcon />\n        </IconButton>\n        <Typography variant=\"h6\" color=\"inherit\" noWrap style={{\"flexGrow\": 1, \"textOverflow\": \"ellipsis\"}}>\n          {props.title}\n        </Typography>\n        <IconButton\n          color=\"inherit\"\n          aria-label=\"open settings\"\n          edge=\"end\"\n          onClick={props.settingsToggle}\n        >\n          <SettingsIcon />\n        </IconButton>\n      </Toolbar>\n    </AppBar>\n  );\n}\n\nexport default TabitBar;","class Audio\n{\n\n  // todo: we replace a valid audioContext with a blank object, so that we can run tests in node\n  //       this should probably be replaced by https://github.com/audiojs/web-audio-api\n  //       and a test-suite written\n  static createWebContext()\n  {\n    return new (window.AudioContext || window.webkitAudioContext || Object)();\n  }\n\n  static determineMinResolution(\n    instrumentIndex,\n    tracks\n  )\n  {\n      let minResolution = 48;\n      for(const [id,t] of Object.entries(tracks))\n      {\n        // the lookup and iteration shouldn't look like this\n        const selected =  instrumentIndex.filter(inst => inst.id.toString() === id);\n        if(\n          selected.length > 0\n          && !t.empty()\n        )\n        {\n          minResolution = Math.min( minResolution, t.resolution );\n        }\n      }\n      return minResolution;\n  }\n\n  static determineTrackLength(\n    instrumentIndex,\n    tracks\n  )\n  {\n      let trackLength = 48;\n      for(const [id,t] of Object.entries(tracks))\n      {\n        // the lookup and iteration shouldn't look like this\n        const selected =  instrumentIndex.filter(inst => inst.id.toString() === id);\n        if(\n          selected.length > 0\n          && !t.empty()\n        )\n        {\n          trackLength = Math.max( trackLength, t.length() );\n        }\n      }\n      return trackLength;\n  }\n\n  static peakAmplitude(\n    combined\n  )\n  {\n    let peakValue = 0.0;\n    for (let channel = 0; channel < combined.numberOfChannels; channel++) {\n      let combinedChannel = combined.getChannelData(channel);\n      for( let sample = 0; sample < combinedChannel.length; ++sample)\n      {\n        peakValue = Math.max( Math.abs(combinedChannel[sample]), peakValue );\n      }\n    }\n    return peakValue;\n  }\n\n  static normalizeAudioBuffer(\n    combined\n  )\n  {\n    const peakValue = Audio.peakAmplitude( combined );\n    if( peakValue > 1.0 )\n    {\n      for (let channel = 0; channel < combined.numberOfChannels; channel++) {\n        let combinedChannel = combined.getChannelData(channel);\n        for( let sample = 0; sample < combinedChannel.length; ++sample)\n        {\n          combinedChannel[sample] = combinedChannel[sample] / peakValue;\n        }\n      }\n    }\n    return combined;\n  }\n\n  static createMasterTrack(\n    context,\n    tracks,\n    instrumentIndex,\n    sounds,\n    tempo\n  )\n  {\n    const trackLength = Audio.determineTrackLength( instrumentIndex, tracks );\n\n\n    const beatTime =  (60.0 / tempo) * 1000;\n    const timePerHydrogen = beatTime / 48.0;\n\n\n    // let's assume we can do some simple things\n\n    const sampleRate = 44100;\n    const channels = 2;\n    const trackLengthMs = trackLength * timePerHydrogen;\n    const trackLengthSamples = trackLengthMs * sampleRate / 1000.0;\n    const totalSamples = Math.floor(trackLengthSamples);\n    const samplesPerHydrogen = Math.floor( totalSamples / trackLength );\n    const combined = context.createBuffer(channels, totalSamples, sampleRate);\n\n    // populate blank buffer with sounds\n    for (let channel = 0; channel < combined.numberOfChannels; channel++) {\n      let combinedChannel = combined.getChannelData(channel);\n      for(const [id,t] of Object.entries(tracks))\n      {\n        // the lookup and iteration shouldn't look like this\n        const selected =  instrumentIndex.filter(inst => inst.id.toString() === id);\n        if(\n          selected.length > 0\n          && selected[0].id in sounds\n          && !t.empty()\n        )\n        {\n          const audioBuffer = sounds[selected[0].id];\n          // fallback to copying the mono buffer across both channels\n          const audioChannel = audioBuffer.numberOfChannels === 2 ? audioBuffer.getChannelData(channel) : audioBuffer.getChannelData(0);\n          const trackPoints = t.toPoints();\n          for( const noteStart of trackPoints )\n          {\n            const sampleStart = noteStart * samplesPerHydrogen;\n            for( let sample = 0; sample < audioBuffer.length; ++sample )\n            {\n              // add sample to mega track\n              combinedChannel[sampleStart + sample] = combinedChannel[sampleStart + sample] + audioChannel[sample];\n            }\n          }\n        }\n      }\n    }\n\n    return Audio.normalizeAudioBuffer( combined );\n  }\n\n  static createAudioSource(context, buffer, tempo)\n  {\n    var source = context.createBufferSource();\n    // set the buffer in the AudioBufferSourceNode\n    source.buffer = buffer;\n    source.loop=true;\n    if( tempo !== null )\n    {\n      source.playbackRate.value = tempo / 100.0;\n    }\n    // connect the AudioBufferSourceNode to the\n    // destination so we can hear the sound\n    source.connect(context.destination);\n    return source;\n  }\n  static createOneShotAudioSource(context, buffer, tempo)\n  {\n    var source = context.createBufferSource();\n    // set the buffer in the AudioBufferSourceNode\n    source.buffer = buffer;\n    source.loop=false;\n    if( tempo !== null )\n    {\n      source.playbackRate.value = tempo / 100.0;\n    }\n    // connect the AudioBufferSourceNode to the\n    // destination so we can hear the sound\n    source.connect(context.destination);\n    return source;\n  }\n}\n\nexport default Audio;","\nimport Audio from \"./Audio\"\nimport * as Tone from \"tone\";\n\n// we schedule for a delay of 120ms to allow the audio context to catch up\nconst AUDIO_DELAY = 0.12;\n\n// these are the hydrogen drumkits available by GPL/CC\n\nconst DRUMKITS = [\n  \"circAfrique v4\",\n  \"DeathMetal\",\n  \"The Black Pearl 1.0\",\n  \"GMRockKit\",\n  \"TR808EmulationKit\"\n];\n\nconst convertNormalToAudible = (value) => {\n  // add an intuitive feel to gain values, perception of sound is non-linear\n  // https://www.dr-lex.be/info-stuff/volumecontrols.html\n  // note: I tried x^4 and I tried using tone's DB directly but neither felt very good.\n  return Math.pow(value, 2.5);\n};\n\nconst chooseAppropriateUrlForInstrument = (drumkitName, instrumentName) =>\n{\n  const name = instrumentName.toLowerCase();\n  // this is currently very basic\n  if(name.includes(\"kick\"))\n  {\n      return \"The Black Pearl 1.0/PearlKick-Hard.wav\";\n  }\n  else if(name.includes(\"stick\"))\n  {\n      return \"DeathMetal/16297_ltibbits_sticks_low_pitch.wav\";\n  }\n  else if(name.includes(\"tom\"))\n  {\n      return \"TR808EmulationKit/808_Tom_Mid.wav\"\n  }\n  else if(name.includes(\"clap\"))\n  {\n      return \"TR808EmulationKit/808_Clap.wav\";\n  }\n  else if(name.includes(\"snare\"))\n  {\n    return \"GMRockKit/Snare-Soft.wav\";\n  }\n  else if(name.includes(\"cowbell\"))\n  {\n    return \"GMRockKit/Cowbell-Softest.wav\";\n  }\n  else\n  {\n    // todo: snare, cymbals\n    return null;\n  }\n}\n\nconst createSequenceCallback = (pattern, sampleSource) =>\n{\n  let samplesReady = sampleSource.samplesReady();\n  const sequenceCallback = (time, indexFromStart) =>\n  {\n    // if we don't know samples are ready,\n    if(!samplesReady)\n    {\n      // update our knowledge, and early out if needed\n      samplesReady = sampleSource.samplesReady();\n      if(!samplesReady){ return; }\n    }\n    const trackLengthRes = ( pattern.length / pattern.resolution );\n    const index = indexFromStart % trackLengthRes;\n    for(const [id,t] of Object.entries(pattern.tracks))\n    {\n        if( t.rep[index] )\n        {\n          const sampleData = sampleSource.samples[id];\n          if( sampleData !== undefined )\n          {\n            sampleData.player.start(time + AUDIO_DELAY);\n          }\n        }\n    }\n    if(sampleSource.onPatternTimeChange)\n    {\n      Tone.Draw.schedule(\n        ()=>{\n          if(Tone.getTransport().state === \"started\")\n          {\n            const notePosition = (index * pattern.resolution) % pattern.length;\n            sampleSource.onPatternTimeChange(notePosition);\n          }\n        },\n        time + AUDIO_DELAY\n      );\n    }\n  };\n  return sequenceCallback;\n};\n\nconst createSortedUnique = (failures) =>\n{\n  let sortedFailures = [];\n  for( const [drumkit, name] of failures )\n  {\n    let noMatch = true;\n    for( const [otherDrumkit, otherName] of sortedFailures )\n    {\n      if( drumkit === otherDrumkit && name === otherName )\n      {\n        noMatch = false;\n        break;\n      }\n    }\n    if( noMatch )\n    {\n      sortedFailures.push( [drumkit, name] );\n    }\n  }\n  sortedFailures.sort();\n  return sortedFailures;\n}\n\nclass ToneController\n{\n  constructor(\n    instrumentIndex,\n    patterns,\n    tempo,\n    onTimeChange,\n    latencyHint\n  )\n  {\n\n    if(latencyHint && Tone.context.latencyHint !== latencyHint)\n    {\n      let context = new Tone.Context({latencyHint: latencyHint});\n      Tone.setContext(context);\n    }\n\n    // this thing has a lot of state, eh?\n    // would love if this state was a bit more structured\n    this.samples = {};\n    this.currentPattern = null;\n    this.gain = new Tone.Gain();\n    this.gain.toDestination();\n    this.onPatternTimeChange = onTimeChange;\n    Tone.getTransport().bpm.value = tempo;\n    Tone.getTransport().loop = true;\n\n    this.sampleCount = 0;\n    this.expectedSampleCount = 0;\n    this.patternDetails = {};\n    let failures = []\n    for( let p of patterns )\n    {\n      this.patternDetails[p.name] = {\n        resolution: Audio.determineMinResolution(instrumentIndex, p.instrumentTracks ),\n        length : Audio.determineTrackLength(instrumentIndex, p.instrumentTracks ),\n        name: p.name,\n        tracks: p.instrumentTracks,\n        pattern: p\n      };\n      this.populateSamples(instrumentIndex, p.instrumentTracks, failures);\n    }\n    this.currentPatternName = null;\n    this.instrumentIndex = instrumentIndex;\n\n    if(failures.length > 0)\n    {\n      let message = \"Failed to load samples for instruments:\\n\";\n      let sortedFailures = createSortedUnique(failures);\n      for( const [drumkit, name] of sortedFailures )\n      {\n        message += \"    -\" + name;\n        if( drumkit !== \"\" ){ message += \" (\" + drumkit + \")\"; }\n        message += \"\\n\";\n      }\n      message += \"This is typically because they belong to commercial sound libraries. \" +\n       \"tabit's supported drumkits are\\n\" + DRUMKITS.join( \", \" ) + \".\";\n\n      alert(message);\n    }\n  }\n\n  teardown()\n  {\n    this.stop();\n    // cancel all future events\n    // note: it's unclear if this will appropriately dispose of all sequences & samples\n    // so this may be a performance problem in the long term\n    Tone.getTransport().cancel();\n  }\n\n  samplesReady()\n  {\n    return this.sampleCount === this.expectedSampleCount;\n  }\n\n  populateSamples(instrumentIndex, tracks, failures)\n  {\n    this.sampleCount = 0;\n    for(const [id,] of Object.entries(tracks))\n    {\n      const selected = instrumentIndex.filter(inst => inst.id.toString() === id);\n      if( selected.length > 0)\n      {\n        const selectedInstrument = selected[0];\n        const clampedVolume = convertNormalToAudible( Math.min( Math.max( 0.0 , selectedInstrument.volume ), 1.0 ) );\n        if( selectedInstrument.id in this.samples )\n        {\n          continue;\n        }\n        if(\n          \"drumkit\" in selectedInstrument &&\n          \"filename\" in selectedInstrument &&\n          DRUMKITS.includes(selectedInstrument.drumkit) )\n        {\n          const filename = selectedInstrument.filename.replace(\".flac\", \".wav\");\n          let player = new Tone.Player(\n            process.env.PUBLIC_URL + \"/wav/\" + selectedInstrument.drumkit + \"/\" + filename,\n            () => { this.sampleCount++; }\n          );\n          player.mute = selectedInstrument.muted;\n          player.name = selectedInstrument.name;\n          const gain = new Tone.Gain(clampedVolume, \"normalRange\");\n          player.connect(gain)\n          gain.connect(this.gain);\n          this.samples[selectedInstrument.id] = { player : player, gain : gain }\n          this.expectedSampleCount++;\n        }\n        else if( \"drumkit\" in selectedInstrument )\n        {\n          const relativeUrl = chooseAppropriateUrlForInstrument( selectedInstrument.drumkit, selectedInstrument.name );\n          if(relativeUrl !== null)\n          {\n            let player = new Tone.Player(\n              process.env.PUBLIC_URL + \"/wav/\" + relativeUrl,\n              () => { this.sampleCount++; }\n            );\n            player.mute = selectedInstrument.muted;\n            player.name = selectedInstrument.name;\n            const gain = new Tone.Gain(clampedVolume, \"normalRange\");\n            player.connect(gain);\n            gain.connect(this.gain);\n            this.samples[selectedInstrument.id] = { player : player, gain : gain }\n            this.expectedSampleCount++;\n          }\n          else\n          {\n            failures.push( [selectedInstrument.drumkit, selectedInstrument.name] );\n          }\n        }\n        else\n        {\n            failures.push( [\"\", selectedInstrument.name] );\n        }\n      }\n    }\n  }\n\n  createSequenceForPattern(instrumentIndex, pattern)\n  {\n      const patternResolution = this.patternDetails[pattern.name].resolution;\n      const patternLength = this.patternDetails[pattern.name].length;\n      const callback = createSequenceCallback(\n        this.patternDetails[pattern.name],\n        this\n      );\n      let seq = new Tone.Sequence(\n        callback,\n        [...Array(patternLength / patternResolution).keys()],\n        Tone.Time(\"4n\") * ( patternResolution / 48.0 )\n      );\n      // start the sequence, but the ticks won't be triggered when muted\n      // note: setting mute on the sequence directly seems to have no effect\n      seq._part.mute = true;\n      seq.start(0);\n      return seq;\n  }\n\n  createSequences(instrumentIndex, patterns)\n  {\n    let sequences = {};\n    for( let p of patterns )\n    {\n      sequences[p.name] = this.createSequenceForPattern(instrumentIndex, p);\n    }\n    return sequences;\n  }\n\n  setActivePattern( patternName )\n  {\n    const oldPatternName = this.currentPatternName !== null ? this.currentPatternName : null;\n    const length = this.patternDetails[patternName].length;\n    const oldLength = oldPatternName !== null ? this.patternDetails[oldPatternName] : null\n\n    // TODO: Since introducing a scheduling delay, this fudge factor is less reliable\n    // Particularly, the transition gets queued but the first beat is a little sloppy\n    // it's possible the whole transition functor needs to be faster\n\n    // we have a little fudge in here... if we're transitioning from a 4 beat loop\n    // to an 8 beat pattern ... we probably really wanted to hit the start of that pattern,\n    // not to transition at 3.75 beats and play the latter half\n    const timeFromBarEnd = Tone.getTransport().loopEnd - ( Tone.getTransport().toSeconds(Tone.getTransport().position) - AUDIO_DELAY );\n\n    const queueTransition = oldPatternName !== null\n    && Tone.getTransport().state === \"started\"\n    && ( timeFromBarEnd > 0 && timeFromBarEnd < Tone.getTransport().toSeconds(Tone.Time(\"8n\")));\n\n    // create this before starting the \"transaction\"\n    const nextSequence = this.createSequenceForPattern(this.instrumentIndex, this.patternDetails[patternName].pattern);\n\n    const enableNewTrack = (time) => {\n      if(oldPatternName !== null)\n      {\n        // note: setting mute on the sequence directly seems to have no effect\n        this.sequence._part.mute = true;\n      }\n      if(oldPatternName === null || oldLength !== length )\n      {\n\n        Tone.getTransport().setLoopPoints(0, Tone.Time(\"4n\") * (length / 48.0));\n      }\n      this.sequence = nextSequence;\n      this.sequence._part.mute = false;\n      this.currentPatternName = patternName;\n    };\n\n    if( queueTransition ) {\n      Tone.getTransport().scheduleOnce(\n        enableNewTrack,\n        Tone.Time(\"0\")\n      );\n    }\n    else\n    {\n      enableNewTrack();\n    }\n  }\n\n  play()\n  {\n    // Tone.start is needed to be triggered from a user interaction\n    // (web-audio-context policy of not playing until a user interaction)\n    Tone.start().then(()=>{Tone.getTransport().start();});\n  }\n\n  stop()\n  {\n    // it's slightly unclear what the synchronisation semantics of this Tone.getTransport().stop() call are.\n    // If a tick is currently in flight on Tone.getTransport() we have to ensure that\n    // the reset of patternTime occurs *afterwards*.\n    // The below calls seem to work for this, but I couldn't tell you why.\n    if( Tone.getTransport().state === \"started\")\n    {\n      Tone.getTransport().stop();\n      if( this.onPatternTimeChange )\n      {\n        Tone.Draw.schedule(\n          ()=>{\n            this.onPatternTimeChange( null );\n          },\n          Tone.getTransport().now()\n        );\n      }\n    }\n  }\n\n  setMutedForInstrument(instrumentID, muted)\n  {\n    this.samples[instrumentID].player.mute = muted;\n  }\n\n  setVolumeForInstrument(instrumentID, volume)\n  {\n    this.samples[instrumentID].gain.set( {gain : convertNormalToAudible(volume) } );\n  }\n\n  setTempo(tempo)\n  {\n    Tone.getTransport().bpm.value = tempo;\n  }\n};\n\n\n\nexport default ToneController;","import React from 'react';\nimport FileImport from \"./FileImport\";\nimport Pattern from \"./Pattern\";\nimport h2 from './h2';\nimport './App.css';\n\nimport { Alert } from '@material-ui/lab';\nimport CircularProgress from '@material-ui/core/CircularProgress';\n\n// define mui theme, including responsiveFont\nimport { createMuiTheme, ThemeProvider, responsiveFontSizes } from '@material-ui/core/styles';\n\n// drawer\nimport SwipeableDrawer from '@material-ui/core/SwipeableDrawer';\nimport CssBaseline from '@material-ui/core/CssBaseline';\nimport List from '@material-ui/core/List';\nimport ListItem from '@material-ui/core/ListItem';\nimport ListItemText from '@material-ui/core/ListItemText';\n\nimport IconButton from '@material-ui/core/IconButton';\nimport Button from '@material-ui/core/Button';\nimport Divider from \"@material-ui/core/Divider\";\nimport Dialog from '@material-ui/core/Dialog';\nimport DialogActions from '@material-ui/core/DialogActions';\nimport DialogContent from '@material-ui/core/DialogContent';\nimport DialogContentText from '@material-ui/core/DialogContentText';\nimport { withStyles } from '@material-ui/core/styles';\nimport FileCopyIcon from '@material-ui/icons/FileCopy';\nimport Toolbar from '@material-ui/core/Toolbar';\n\n// notationSettings\n\nimport {FormatSettings, DefaultSettings} from \"./formatSettings\";\nimport {createInstrumentMask, InstrumentConfig} from \"./instrumentConfig\";\nimport { activeInstrumentation, figureInstruments, DEFAULT_INSTRUMENT_SYMBOLS } from \"./instrumentation\";\nimport notation from \"./notation\";\n\nimport Grid from '@material-ui/core/Grid';\n\n// load static data\nimport kuva from \"./kuva.json\";\nimport track from \"./track\";\n\nimport { saveAs } from 'file-saver';\n\nimport ToneController from \"./ToneController\";\nimport PlaybackControls from \"./PlaybackControls\";\nimport { withRouter } from \"react-router-dom\";\n\nimport hash from \"object-hash\";\nimport zlib from \"zlib\";\nimport copy from \"copy-to-clipboard\";\n\nimport { isMobile } from \"./Mobile\";\n\nimport History from \"./History\";\nimport TabitBar from \"./TabitBar\";\n\n// mui theme config\nlet theme = responsiveFontSizes( createMuiTheme( {\n  palette: {\n    type: 'dark',\n    primary: { main: '#36d9be' },\n    secondary: { main: '#f50057' }\n   }\n} ) );\n\nconst ignoreEvent = (event) => {\n  return event && event.type === 'keydown' && (event.key === 'Tab' || event.key === 'Shift');\n};\n\nconst getJsonDestinationUrl = (slug) => {\n  const jsonbase_url = \"https://jsonbase.com/tabit-song/\" + slug;\n  return jsonbase_url;\n}\n\nconst getJsonStorageUrl = (slug) => {\n  // jsonbase doesn't give cross-origin headers,\n  // so we use cors-anywhere to add them\n\n  // this is obviously a hack, but it enables us to use jsonbase\n  // as a transitive (semi-permanent) database, on a static site!\n  const cors_url = \"https://cors-anywhere.herokuapp.com/\";\n  return cors_url + getJsonDestinationUrl(slug);\n}\n\nconst licenseBannerStyles = {\n  position:\"absolute\",\n  bottom:0,\n  \"width\": \"95%\",\n  \"textAlign\": \"center\",\n  \"backgroundColor\" : \"#282c34\", // same background color as app\n  \"zIndex\" : theme.zIndex.drawer\n};\n\nconst modalStyles = {\n  modal: {\n    display: 'flex',\n    alignItems: 'center',\n    justifyContent: 'center',\n  },\n  paper: {\n    backgroundColor: theme.palette.background.paper,\n    border: '2px solid #000',\n    boxShadow: theme.shadows[5],\n    padding: theme.spacing(2, 4, 3),\n  }\n};\n\nclass App extends React.Component\n{\n  constructor(props) {\n    super(props);\n    const previousHistory = localStorage.getItem(\"tabit-history\");\n    this.state = {\n      // data\n      instruments : null,\n      instrumentIndex : null,\n      instrumentMask : null,\n      patterns : null,\n      formatSettings : Object.assign({}, DefaultSettings),\n      patternSettings : [],\n      // ui state\n      loadedFile : null,\n      selectedPattern : null,\n      settingsOpen : false,\n      patternsOpen : false,\n      progress : null,\n      showSharingDialog : false,\n      showTitleOptions : this.props.match.params.song === undefined,\n      songName: null,\n      permanentUrl : \"\",\n      history: previousHistory ? JSON.parse(previousHistory).sort( (a,b) =>(b.date - a.date) ) : []\n    };\n    this.pattern = React.createRef();\n    document.app = this;\n  }\n\n  recordSongVisited()\n  {\n    // require { id, name, content?? }\n    const exportState = this.getExportState();\n    const stateToShare = this.encodeState(exportState);\n    const stateHash = hash(stateToShare);\n\n    const history = Array.from(this.state.history);\n    const relevantHistory = history.filter( song => ( song.id === stateHash && song.name === exportState.songName ) );\n    if( relevantHistory.length !== 0 )\n    {\n\n      // found at least one history entry that matches our constraints ... let's update the most recent one\n      relevantHistory[0].date = Date.now();\n    }\n    else\n    {\n      // add history entry\n      const historyEntry = {\n        name: exportState.songName,\n        id: stateHash,\n        date: Date.now(),\n        content: stateToShare\n      };\n      history.push(historyEntry);\n    }\n    // cap how many files we remember\n    const restrictedHistory = history.sort( (a,b) =>(b.date - a.date)  ).slice(0, 10);\n    this.setState(\n      { history : restrictedHistory },\n      () => {\n        localStorage.setItem(\"tabit-history\", JSON.stringify(restrictedHistory));\n      }\n    );\n  }\n\n  fetchSong(songID, songTitle)\n  {\n    fetch(getJsonStorageUrl(songID))\n    .then( response => { return response.json(); } )\n    .then( js => {\n      const decodedState = this.decodeState(js);\n      const stateHash = hash(js);\n      if( stateHash !== songID )\n      {\n        throw new Error(\"Hash did not match\");\n      }\n      this.handleJson(songTitle, decodedState);\n    }).catch( (e) => {\n      this.setState({showTitleOptions : true});\n      alert(\"Song \" + (songTitle ?? songID) + \" could not be found.\" );\n    } );\n  }\n\n  loadLocalSong(inputSong)\n  {\n    const resolveSong = (song) => {\n      const decodedState = this.decodeState(song.content);\n      const stateHash = hash(song.content);\n      if( stateHash !== song.id )\n      {\n        throw new Error(\"Hash did not match\");\n      }\n      this.handleJson(song.name, decodedState);\n    };\n\n    const displayError = (err) => {\n      this.setState({showTitleOptions : true});\n      alert(\"Failed to load song \" + inputSong.name + \". Encountered error \" + err.toString() );\n    };\n\n    this.setState(\n      {showTitleOptions : false }\n    );\n    Promise.resolve(inputSong)\n      .then(resolveSong)\n      .catch( displayError );\n  }\n\n  componentDidMount()\n  {\n    if( this.props.match.params.song )\n    {\n      this.fetchSong(this.props.match.params.song);\n    }\n  }\n\n  componentWillUnmount()\n  {\n    if( this.audio )\n    {\n      this.audio.teardown();\n      delete this.audio;\n    }\n  }\n\n  getExportState()\n  {\n    return {\n      instruments : this.state.instruments,\n      instrumentIndex : this.state.instrumentIndex,\n      patterns : this.state.patterns,\n      formatSettings: this.state.formatSettings,\n      patternSettings : this.state.patternSettings,\n      songName: this.state.songName,\n      version: \"1.1.0\"\n    }\n  }\n\n  save()\n  {\n    let destFilename = \"download.tabit\";\n    if(this.state.loadedFile)\n    {\n      const fileParts = this.state.loadedFile.split(\".\");\n      if( fileParts.length === 1 )\n      {\n        destFilename = fileParts[0] + \".tabit\";\n      }\n      else\n      {\n        destFilename = fileParts.slice(0, fileParts.length - 1).join(\".\") + \".tabit\";\n      }\n    }\n\n    const js = JSON.stringify(this.getExportState(), null, 4);\n    const blob = new Blob([js], {type: \"application/json\"});\n    saveAs(blob, destFilename);\n  }\n\n  encodeState(state)\n  {\n    // json\n    const js = JSON.stringify(this.getExportState());\n    // compress\n    const compressedState = zlib.deflateSync(js).toString(\"base64\");\n    return { state : compressedState };\n  }\n\n  decodeState(state)\n  {\n    const binaryBuffer = new Buffer(state.state, \"base64\");\n    const decompressedString = zlib.inflateSync(binaryBuffer);\n    return JSON.parse(decompressedString);\n  }\n\n  share()\n  {\n    const stateToShare = this.encodeState(this.getExportState());\n    const stateHash = hash(stateToShare);\n    const uploadUrl = getJsonStorageUrl(stateHash);\n\n    const metadata = {\n      method: \"PUT\",\n      headers: { 'Content-Type': 'application/json' },\n      body: JSON.stringify(stateToShare)\n    };\n\n    const permanentUrl = window.origin + process.env.PUBLIC_URL + \"/song/\" + stateHash;\n    fetch(uploadUrl, metadata).then(\n      e => {\n        this.setState({permanentUrl : permanentUrl, showSharingDialog: true})\n      }\n    ).catch(err => { alert(\"Couldn't upload song at this time. Sorry for any inconvenience.\"); });\n  }\n\n  figurePatternSettings(patterns)\n  {\n    return Array.from(\n      patterns,\n      (p) => notation.guessPerPatternSettings( p.instrumentTracks )\n    );\n  }\n\n  songNameFromFile(filename)\n  {\n    if(filename === null || filename === undefined)\n    {\n      return null;\n    }\n    if( filename.includes(\".\") )\n    {\n      const songTitle = filename.split('.').slice(0, -1).join('.');\n      return songTitle;\n    }\n    else\n    {\n      return filename;\n    }\n  }\n\n  handleJson(title, prevState)\n  {\n    const createTracks = (patternData) =>\n    {\n      // the instruments currently work as simple objects\n      // we need to create tracks!\n      let patterns = [];\n      for( let pattern of patternData )\n      {\n        let replacedTracks = {};\n        // todo: find a more compact way of doing this\n        for( const [id, trackData] of Object.entries(pattern.instrumentTracks) )\n        {\n          replacedTracks[id] = new track( trackData.rep, trackData.resolution );\n        }\n        let patternWithTracks = Object.assign({}, pattern);\n        patternWithTracks.instrumentTracks = replacedTracks;\n        patterns.push(patternWithTracks);\n      }\n      return patterns;\n    }\n\n    this.setState(\n      {\n        instrumentIndex : prevState.instrumentIndex,\n        instrumentMask : createInstrumentMask(prevState.instrumentIndex, prevState.instruments),\n        instruments : prevState.instruments,\n        patterns : createTracks(prevState.patterns),\n        formatSettings : prevState.formatSettings,\n        patternSettings : prevState.patternSettings,\n        // general app state\n        loadedFile : title ?? prevState.loadedFile,\n        selectedPattern : prevState.patterns.length === 0 ? null : 0,\n        patternsOpen : prevState.patterns.length !== 0,\n        songName: title ?? ( prevState.songName ?? ( prevState.loadedFile ? this.songNameFromFile(prevState.loadedFile) : \"untitled\" ) )\n      },\n      () => {\n        // if mobile prioritise smooth playback\n        const latencyHint = isMobile() ? \"playback\" : null;\n        // always default tempo to 100bpm for now\n        this.audio = new ToneController(\n          this.state.instrumentIndex,\n          this.state.patterns,\n          100.0,\n          (time)=>{this.onPatternTimeChange(time);},\n          latencyHint\n        );\n        this.audio.setActivePattern( this.state.patterns[this.state.selectedPattern].name );\n        this.recordSongVisited();\n      }\n    );\n  }\n\n  handleFileImport(e)\n  {\n    if( e.file.name.includes(\"h2song\") )\n    {\n      // e = { file : , content : }\n      h2.parseHydrogenPromise(e.content).then(h => {\n        const assessedInstruments = figureInstruments(h.instruments, DEFAULT_INSTRUMENT_SYMBOLS, h.patterns);\n        const instrumentIndex = activeInstrumentation(h.instruments, h.patterns);\n\n        // fixme: convert hydrogen volume/gain to normal values, somewhere\n        for( let instrument of instrumentIndex )\n        {\n          instrument.volume = 0.5;\n        }\n\n        this.setState(\n          {\n            // data\n            instrumentIndex : instrumentIndex,\n            instrumentMask : createInstrumentMask(instrumentIndex, assessedInstruments),\n            instruments : assessedInstruments,\n            patterns : h.patterns,\n            patternSettings : this.figurePatternSettings(h.patterns),\n            // general app state\n            loadedFile : e.file.name,\n            patternsOpen : true,\n            selectedPattern : h.patterns.length === 0 ? null : 0,\n            songName: this.songNameFromFile(e.file.name)\n          },\n          ()=>{\n            // if mobile prioritise smooth playback\n            const latencyHint = isMobile() ? \"playback\" : null;\n            // always default tempo to 100bpm for now\n            this.audio = new ToneController(\n              this.state.instrumentIndex,\n              this.state.patterns,\n              100.0,\n              (time)=>{this.onPatternTimeChange(time);},\n              latencyHint\n            );\n            this.audio.setActivePattern( this.state.patterns[this.state.selectedPattern].name );\n            this.recordSongVisited();\n          }\n        );\n      }).catch( (error)=>{ alert(\"Failed to load file \" + e.file.name  + \" with error \" + error); } );\n    }\n    else\n    {\n\n      // assume it's a tabit file!\n      Promise.resolve(e.content)\n        .then(JSON.parse)\n        .then( prevState => { this.handleJson(this.songNameFromFile(e.file.name),prevState); } )\n        .catch( (error)=>{ alert(\"Failed to load file \" + e.file.name  + \" with error \" + error); } );\n    }\n  }\n\n  loadExample()\n  {\n    const createObjects = (state) =>\n    {\n      // the instruments currently work as simple objects\n      // we need to create tracks!\n      for( let pattern of state.patterns )\n      {\n        let replacedTracks = {};\n        // todo: find a more compact way of doing this\n        for( const [id, trackData] of Object.entries(pattern.instrumentTracks) )\n        {\n          replacedTracks[id] = new track( trackData.rep, trackData.resolution );\n        }\n        pattern.instrumentTracks = replacedTracks;\n      }\n      return state;\n    }\n    const k = createObjects(kuva);\n    const assessedInstruments = figureInstruments(k.instruments, DEFAULT_INSTRUMENT_SYMBOLS, k.patterns);\n    const instrumentIndex = activeInstrumentation(k.instruments, k.patterns);\n\n    // fixme: convert hydrogen volume/gain to normal values, somewhere\n    for( let instrument of instrumentIndex )\n    {\n      instrument.volume = 0.5;\n    }\n\n    this.setState(\n      {\n        instrumentIndex : instrumentIndex,\n        instrumentMask : createInstrumentMask(instrumentIndex, assessedInstruments),\n        instruments : assessedInstruments,\n        patterns : k.patterns,\n        selectedPattern : k.patterns.length === 0 ? null : 0,\n        loadedFile : \"kuva.example\",\n        patternsOpen : true,\n        patternSettings : this.figurePatternSettings(k.patterns),\n        songName : \"kuva\"\n      },\n      () => {\n        // if mobile prioritise smooth playback\n        const latencyHint = isMobile() ? \"playback\" : null;\n        // always default tempo to 100bpm for now\n        this.audio = new ToneController(\n          this.state.instrumentIndex,\n          this.state.patterns,\n          100.0,\n          (time)=>{this.onPatternTimeChange(time);},\n          latencyHint\n        );\n        this.audio.setActivePattern( this.state.patterns[this.state.selectedPattern].name );\n        // no need to record the example, it's embedded into the website anyway\n        // this.recordSongVisited();\n      }\n    );\n  }\n\n  selectPattern(patternIndex)\n  {\n    // it's important to do this before we re-render components\n    this.audio.setActivePattern(\n      this.state.patterns[patternIndex].name\n    );\n\n    this.setState(\n      { selectedPattern: patternIndex }\n    );\n  }\n\n  // todo: this is a separate component!\n  renderPattern(pattern, resolvedSettings)\n  {\n    return (\n      <React.Fragment>\n        <Pattern\n          instruments={this.state.instruments}\n          tracks={pattern.instrumentTracks}\n          config={resolvedSettings}\n          active={this.state.progress}\n          ref={this.pattern}\n        />\n        <PlaybackControls\n          onPlay={()=>{if(this.audio){this.audio.play();}}}\n          onStop={()=>{if(this.audio){this.audio.stop();}}}\n          onTempoChange={(tempo)=>{if(this.audio){this.audio.setTempo(tempo);}}}\n        />\n      </React.Fragment>\n    );\n  }\n\n  onPatternTimeChange(time)\n  {\n    // this only needs to be checked at teardown I believe\n    if(this.pattern.current)\n    {\n      this.pattern.current.onPatternTimeChange(time);\n    }\n  }\n\n  getTrackLength(pattern)\n  {\n    let trackLength = 48;\n    for(const [,t] of Object.entries(pattern.instrumentTracks))\n    {\n        trackLength = Math.max( trackLength, t.length() );\n    }\n    return trackLength;\n  }\n\n  getResolution(pattern)\n  {\n    let resolution = 48;\n    for(const [,t] of Object.entries(pattern.instrumentTracks))\n    {\n        resolution = Math.min( resolution, t.resolution );\n    }\n    return resolution;\n  }\n\n  renderTitlePage()\n  {\n    const showAlert = this.state.patterns != null && this.state.patterns.length === 0;\n    const optionalAlert = showAlert ? ( <Alert severity=\"error\">{this.state.loadedFile} contained no patterns! Try another.</Alert> )\n                                    : \"\";\n    // if a load of a song is in flight don't show file open buttons\n    const controls = (\n      <React.Fragment>\n        <Button variant=\"contained\" onClick={this.loadExample.bind(this)} style={{margin: \"1em\"}}>Load example</Button>\n        <FileImport\n          style={{margin: \"1em\"}}\n          variant=\"contained\"\n          onImport={this.handleFileImport.bind(this)}\n          accept=\".tabit,.h2song\"\n          />\n          {optionalAlert}\n      </React.Fragment>\n    );\n    const waitingMessage = (<React.Fragment>\n        <p> Loading song... </p>\n        <CircularProgress />\n      </React.Fragment>\n    );\n    return (\n      <React.Fragment>\n      <div>\n        <h2>tabit</h2>\n        <p>I read .h2songs and write tab</p>\n        {this.state.showTitleOptions ? controls : waitingMessage}\n      </div>\n      <div style={{\"marginLeft\" : \"auto\", \"marginRight\": \"auto\"}}>\n      { this.state.history.length > 0 ? <History data={this.state.history} onClick={(piece)=>{this.loadLocalSong(piece);}}/> : \"\" }\n      </div>\n      <div style={licenseBannerStyles} >\n        <p>tabit relies on publicly available sound libraries listed at <a href=\"https://github.com/andrew-murray/tabit\">https://github.com/andrew-murray/tabit</a></p>\n      </div>\n      </React.Fragment>\n    );\n  }\n\n  renderPatternDrawer(iOS, mobile)\n  {\n    const handlePatternsToggle = (e) => {\n      if( ignoreEvent(e) ){ return; }\n      this.setState( { patternsOpen : !this.state.patternsOpen } );\n    };\n\n    // SwipableDawer has undesirable behaviour,\n    // (a) persistent isn't handled properly\n    // (b) onOpen of swipable drawer, is only called on swipe events\n    // I can't find convenient callbacks to hook into that are called \"when the component exists\"\n    // (components are deleted when the swipable drawer is closed)\n    // I think my approach would have to involve modifying the content in the swipeable drawer in\n    // a somewhat complex way sadly - not yet\n\n    return (\n      <SwipeableDrawer disableBackdropTransition={!iOS} disableDiscovery={iOS}\n      variant={mobile ? undefined : \"persistent\"}\n      open={this.state.patternsOpen}\n      onOpen={handlePatternsToggle}\n      onClose={handlePatternsToggle}\n      >\n        {!mobile ? <TabitBar placeholder /> : null }\n        <div\n          style={{overflow: \"auto\"}}\n        >\n          <List>\n            {(this.state.patterns ?? []).map( (pattern, index) => (\n              <ListItem button key={\"drawer-pattern\" + index.toString()} onClick={() => this.selectPattern(index)}>\n                  <ListItemText primary={pattern.name} />\n              </ListItem>\n            ))}\n          </List>\n        </div>\n      </SwipeableDrawer>\n    );\n  }\n\n\n\n  renderSettingsDrawer(iOS, mobile, patternConfig)\n  {\n    const classes = this.props;\n    const settingsChangeCallback = (config) => {\n      let existingPatternSettings = Array.from( this.state.patternSettings );\n      let existingGlobalSettings = Object.assign( {}, this.state.formatSettings );\n      for( let [k,v] of Object.entries(config) )\n      {\n        if( k in existingPatternSettings[this.state.selectedPattern] )\n        {\n          existingPatternSettings[this.state.selectedPattern][k] = v;\n        }\n        else\n        {\n          existingGlobalSettings[k] = v;\n        }\n      }\n      this.setState( { formatSettings: existingGlobalSettings, patternSettings : existingPatternSettings } );\n    };\n\n    const handleSettingsToggle = (e) => {\n      if( ignoreEvent(e) ){ return; }\n      this.setState( {settingsOpen : !this.state.settingsOpen} );\n    };\n\n    const patternToRender = this.state.patterns[this.state.selectedPattern];\n\n    const patternDetails = {\n      name : patternToRender.name,\n      resolution : patternToRender.resolution,\n      \"length\" : this.getTrackLength(patternToRender)\n    };\n\n    return (\n      <SwipeableDrawer disableBackdropTransition={!iOS} disableDiscovery={iOS}\n        className={classes.drawer}\n        variant={ mobile ? undefined : \"persistent\" }\n        anchor=\"right\"\n        open={this.state.settingsOpen}\n        onOpen={handleSettingsToggle}\n        onClose={handleSettingsToggle}\n        classes={{\n          paper: classes.drawerPaper\n        }}\n      >\n        {!mobile ? <TabitBar placeholder /> : null }\n        <FormatSettings\n          onChange={settingsChangeCallback}\n          settings={patternConfig}\n          pattern={patternDetails}\n          />\n        <Button\n          style={{backgroundColor : \"white\", color : theme.palette.background.default}}\n          onClick={(e) => { this.save(); } }\n        >Download</Button>\n        <Divider />\n        <Button\n          style={{backgroundColor : \"white\", color : theme.palette.background.default}}\n          onClick={(e) => { this.share(); } }\n        >Share</Button>\n      </SwipeableDrawer>\n    );\n  }\n\n  renderSharingDialog()\n  {\n    return (\n      <Dialog\n        open={this.state.showSharingDialog}\n        onClose={(e)=>{this.setState({showSharingDialog: false});}}\n        aria-labelledby=\"alert-dialog-title\"\n        aria-describedby=\"alert-dialog-description\"\n      >\n        <DialogContent>\n          <DialogContentText id=\"alert-dialog-description\">\n          Your song is available at\n          </DialogContentText>\n          <DialogContentText>\n          {this.state.permanentUrl}\n          <IconButton onClick={(e)=>{ copy(this.state.permanentUrl); }}>\n            <FileCopyIcon />\n          </IconButton>\n          </DialogContentText>\n          <DialogActions>\n            <Button onClick={(e)=>{this.setState({showSharingDialog: false})}}>\n              Close\n            </Button>\n          </DialogActions>\n        </DialogContent>\n      </Dialog>\n    );\n  }\n\n  renderMainContent()\n  {\n    if(this.state.patterns == null || this.state.patterns.length === 0)\n    {\n      return this.renderTitlePage();\n    }\n    else\n    {\n      const patternToRender = this.state.patterns[this.state.selectedPattern];\n      const patternConfig = Object.assign(\n        Object.assign({}, this.state.formatSettings), // global settings\n        this.state.patternSettings[this.state.selectedPattern] // then apply per-pattern settings\n      );\n      const patternContent = this.renderPattern(patternToRender, patternConfig);\n\n\n      const changeInstrumentsCallback = (instruments) => {\n        this.setState( {\n          instruments : instruments,\n          instrumentMask : createInstrumentMask(this.state.instrumentIndex, instruments)\n        } );\n      }\n\n      const iOS = process.browser && /iPad|iPhone|iPod/.test(navigator.userAgent);\n      const mobile = isMobile();\n\n      const instrumentConfigColumns = mobile ? 12 : 8;\n\n      const sendVolumeEvent = (event) =>\n      {\n        if(\"volume\" in event)\n        {\n          const instrumentID = this.state.instrumentIndex[ event.instrument ].id;\n          this.audio.setVolumeForInstrument( instrumentID, event.volume );\n        }\n        else if(\"muted\" in event)\n        {\n          const instrumentID = this.state.instrumentIndex[ event.instrument ].id;\n          this.audio.setMutedForInstrument( instrumentID, event.muted );\n        }\n      };\n\n      return (\n        <React.Fragment>\n          <Toolbar variant=\"dense\"/>\n          {this.renderSharingDialog()}\n          <TabitBar\n            title={this.state.songName}\n            settingsToggle={(e)=>{this.setState({settingsOpen: !this.state.settingsOpen})}}\n            patternsToggle={(e)=>{this.setState({patternsOpen: !this.state.patternsOpen})}}\n          />\n          {patternContent}\n          <Grid container>\n          {instrumentConfigColumns < 12 ? <Grid item xs={(12 - instrumentConfigColumns) / 2} /> : null}\n          <Grid item xs={instrumentConfigColumns}>\n          <InstrumentConfig\n              instruments={this.state.instruments}\n              instrumentIndex={this.state.instrumentIndex}\n              instrumentMask={this.state.instrumentMask}\n              onChange={changeInstrumentsCallback}\n              onVolumeEvent={sendVolumeEvent}\n            />\n          </Grid>\n          {instrumentConfigColumns < 12 ? <Grid item xs={(12 - instrumentConfigColumns) / 2} /> : null}\n          </Grid>\n          {this.renderPatternDrawer(iOS,mobile)}\n          {this.renderSettingsDrawer(iOS,mobile, patternConfig)}\n        </React.Fragment>\n      );\n    }\n  }\n\n  render() {\n    const mainContent = this.renderMainContent();\n    return (\n      <div className=\"App\">\n        <ThemeProvider theme={theme}>\n          <CssBaseline />\n          {mainContent}\n        </ThemeProvider>\n      </div>\n    );\n  }\n}\n\nexport default withStyles(modalStyles)(withRouter(App));\n","import React from 'react';\nimport { makeStyles, useTheme } from '@material-ui/core/styles';\nimport InputLabel from '@material-ui/core/InputLabel';\nimport MenuItem from '@material-ui/core/MenuItem';\nimport FormControl from '@material-ui/core/FormControl';\nimport FormGroup from '@material-ui/core/FormGroup';\nimport FormControlLabel from '@material-ui/core/FormControlLabel';\nimport Switch from '@material-ui/core/Switch';\nimport Select from '@material-ui/core/Select';\nimport notation from \"./notation\";\n\nconst useStyles = makeStyles((theme) => ({\n  formControl: {\n    margin: theme.spacing(1),\n    minWidth: 120,\n  }\n}));\n\nfunction camelToReadable(s)\n{\n  const spacedString = s.replace(/([A-Z])/g, ' $1');\n  return spacedString[0].toUpperCase() + spacedString.slice(1);\n}\n\nfunction FormatSettings(props) {\n  const classes = useStyles(props);\n  const theme = useTheme();\n  // todo: change to multiple useState calls?\n\n  function tokenStateToItem(value)\n  {\n    return value === \" \" ? \"space\" : value;\n  }\n\n  function tokenItemToState(value)\n  {\n    return value === \"space\" ? \" \" : value;\n  }\n\n  const handleOptionChange = (name, value) => {\n    const updatedState = {...props.settings, [name]: value};\n    props.onChange(updatedState);\n  };\n\n  const handleCheckedChange = (event) => {\n    const updatedState = {...props.settings, [event.target.name]: event.target.checked};\n    props.onChange(updatedState);\n  };\n\n  function createOptionMenu(\n    name,\n    options,\n    itemToState = tokenItemToState,\n    stateToItem = tokenStateToItem\n  )\n  {\n    const idString = \"form-control-\" + name + \"-id\";\n    return (\n      <FormControl variant=\"filled\" className={classes.formControl} key={idString} id={idString}>\n        <InputLabel id=\"settings-option-{name}\">{name}</InputLabel>\n        <Select\n          labelId={\"settings-option-\" + name + \"-labelID\"}\n          id={\"settings-option-\" + name + \"-id\"}\n          value={stateToItem(props.settings[name])}\n          name={name}\n          onChange={(e) => handleOptionChange( e.target.name, itemToState(e.target.value))}\n        >\n          {options.map((op) => <MenuItem key={\"settings-menu-item-\" + name + \"-\" + op} value={stateToItem(op)}>{stateToItem(op)}</MenuItem>)}\n        </Select>\n      </FormControl>\n    );\n  };\n\n  function createBoolControl(name)\n  {\n    return (\n      <FormControlLabel\n        control={<Switch checked={props.settings[name]} onChange={handleCheckedChange} name={name} />}\n        label={camelToReadable(name)}\n        key={\"switch-\"+name}\n      />\n    );\n  };\n\n  const resolutionToBeatString = (r) => ( r / props.settings.beatResolution ).toString();\n  const beatStringToResolution = (b) => props.settings.beatResolution * parseInt(b);\n\n  const candidateLineLengths = [ 2, 3, 4, 5, 6, 7, 8, 14, 16, 32 ];\n  let lineLengths = [];\n  for( const c of candidateLineLengths )\n  {\n    const resolution = c * 48;\n    if( (resolution % props.settings.beatResolution) === 0\n      && (resolution <= props.pattern.length)\n     )\n    {\n      lineLengths.push( resolution );\n    }\n  }\n\n  if( !lineLengths.includes( props.pattern.length ) )\n  {\n    lineLengths.push( props.pattern.length );\n    lineLengths.sort();\n  }\n\n  const candidateBeatResolutions = [24, 36, 48, 72, 96];\n  let beatResolutions = [];\n  for( const c of candidateBeatResolutions )\n  {\n    if( (c % props.pattern.resolution) === 0 && ( props.settings.lineResolution % c ) === 0)\n    {\n      beatResolutions.push( c );\n    }\n  }\n  return (\n    <FormGroup className={classes.root}>\n      {notation.FORMAT_CONFIG_STRINGS.map( op => createOptionMenu( op[0], op[1] ) ).reduce((prev, curr) => [prev, curr])}\n      {notation.FORMAT_CONFIG_BOOLS.map( op => createBoolControl( op )).reduce((prev, curr) => [prev, curr]) }\n      <div style={{backgroundColor : \"white\", color : theme.palette.background.default}}><p> {props.pattern.name + \" Options\"} </p></div>\n      {\n        createOptionMenu(\n          \"beatResolution\",\n          beatResolutions,\n          (v) => v.toString(), // stateToItem\n          (v) => parseInt(v) // itemToState\n        )\n      }\n      {createOptionMenu(\n        \"lineResolution\",\n        lineLengths,\n        beatStringToResolution,\n        resolutionToBeatString\n      )}\n    </FormGroup>\n  );\n}\n\nconst DefaultSettings = notation.DEFAULT_FORMAT_CONFIG;\n\n\nexport { FormatSettings, DefaultSettings }\nexport default FormatSettings;","// FileUpload.react.js\n\n// inspired by https://gist.github.com/AshikNesin/e44b1950f6a24cfcd85330ffc1713513\n// and https://stackoverflow.com/questions/55830414/how-to-read-text-file-in-react\n\nimport React from 'react'\nimport Button from '@material-ui/core/Button';\n\nclass FileImport extends React.Component {\n\n  constructor(props) {\n    super(props);\n    this.hiddenFileInput = React.createRef();\n  }\n\n  onChange(e) {\n    const fileObject = e.target.files[0]\n    const reader = new FileReader()\n    reader.onload = loadEvent => {\n      if( this.props.onImport )\n      {\n        this.props.onImport(\n          { file: fileObject, content : loadEvent.target.result}\n        );\n      }\n    }\n    reader.readAsText(fileObject);\n  }\n\n  render() {\n    const clickFile = (e) => {\n      this.hiddenFileInput.current.click();\n    }\n\n    const {onImport, accept, ...buttonProps} = {...this.props};\n    return (\n      <React.Fragment>\n        <Button onClick={clickFile} {...buttonProps}>Import File</Button>\n        <input\n          type=\"file\"\n          hidden\n          accept={accept}\n          onChange={(e) => this.onChange(e)} ref={this.hiddenFileInput}\n          />\n      </React.Fragment>\n   )\n  }\n}\n\nexport default FileImport;\n","// h2.js\n\nimport track from \"./track\";\nimport xml2js from \"xml2js\";\nimport { calculateResolution } from \"./utilities\";\n\n// TODO: This file was written with the hope that using xml2js would make things cleaner\n// it didn't, purely because xml2js is an okay library doing a difficult task\n// it ensures to produce a good json file but in doing so muddles the data a bit.\n// Should replace this with dom-parser and window.DOMParser\n\n// let's think about the data representation needed\n\nfunction calculatePatternResolution(pattern, size)\n{\n  const positions = Array.from(pattern.notes, note => note.position)\n  return calculateResolution(positions, size);\n}\n\nfunction parseHydrogenJs(result)\n{\n    // fixme:\n    // this parsing often assumes there's >=2 elements\n\n    // this \"zero\" here is presumably an artefact of xml --> json representation\n    const instrumentElements = result.song.instrumentList[0].instrument;\n\n    // instruments\n    // [  { id, name } ]\n    const instrumentArray = Array.from(\n      instrumentElements,\n      function(element){\n        const instrumentComponent = element.instrumentComponent[0];\n        let inst = {\n          \"id\" : parseInt(element.id),\n          \"name\" : element.name[0],\n           \"volume\" : parseFloat(element.volume),\n           \"muted\" : element.isMuted[0] === \"true\",\n           \"gain\" : parseFloat(element.gain),\n           \"drumkit\" : element.drumkit[0]\n        };\n        if( \"layer\" in instrumentComponent )\n        {\n          inst[\"filename\"] = instrumentComponent.layer[0].filename[0];\n        }\n        return inst;\n      }\n    );\n\n    const patternElements = result.song.patternList[0].pattern;\n    // patterns\n    // [  { name, size, notes } ]\n    const patternArray = Array.from(\n      patternElements,\n      function(element){\n        const noteElements = element.noteList[0].note;\n        const patternSize = parseInt(element.size);\n        let notes = [];\n        if( noteElements )\n        {\n          // notes\n          // [ {position, instrument(id}]\n          notes = Array.from(\n            noteElements,\n            function(noteElement){\n              return {\"position\" : parseInt(noteElement.position), \"instrument\" : parseInt(noteElement.instrument)};\n            }\n          );\n\n          // hydrogen permits you to have notes that reach past the pattern size,\n          // they then get revealed when you extend the pattern,\n          // here's an easy point to get rid of them, we don't want them to factor into any calculations\n          notes = notes.filter( n => n.position < patternSize );\n        }\n        return {\n          \"size\" : patternSize,\n          \"name\" : element.name[0],\n          \"notes\" : notes\n        };\n      }\n    );\n\n    // transform pattern to a managable data\n    const patternsWithTracks = Array.from(\n      patternArray,\n      function(pattern)\n      {\n        const resolution = calculatePatternResolution(pattern, pattern.size);\n        let instrumentTracks = {};\n        for( const instrument of instrumentArray )\n        {\n          const relevantNotes = pattern.notes.filter(\n            note => (note.instrument === instrument.id)\n          );\n          const relevantHits = Array.from(\n            relevantNotes,\n            note => note.position\n          );\n          instrumentTracks[ instrument.id.toString() ] = track.fromPositions( relevantHits, pattern.size, resolution);\n        }\n        pattern.resolution = resolution;\n        pattern.instrumentTracks = instrumentTracks;\n        return pattern;\n      }\n    );\n\n    // todo: refactor into (at least one) separate function\n    if(result.song.virtualPatternList)\n    {\n      // so unfortunately, virtualPatternGroup represents a directional graph and we have to build\n      // the tree of dependencies for each node, we implement this in a very simplistic way\n      // let's build a mapping( name -> [ names ] ) and continue to resolve it\n      // until we're done\n      const virtualPatternGroups = result.song.virtualPatternList[0].pattern;\n      if( virtualPatternGroups )\n      {\n        // each element looks like\n        //\n        // <pattern>\n        // <name>p2-a-djembe</name>\n        // <virtual>p2-a-bass</virtual>\n        // <virtual>p2-snare</virtual>\n        // </pattern>\n\n        let patternToRelated = {};\n\n        // record initial relations\n        for( const virtualGroup of Array.from(virtualPatternGroups) )\n        {\n          const rootPatternName = virtualGroup.name[0];\n          const relatedPatterns = Array.from(virtualGroup.virtual);\n          patternToRelated[rootPatternName] = new Set(relatedPatterns);\n        }\n\n        // expand connections until our object stops changing, brute-force\n        // this is a relatively large limit but is better than the potential of an infinite loop\n        // I think 3 layers would be pushing this feature\n        const MAX_ITERATIONS = 20;\n        for(let iteration = 0; iteration < MAX_ITERATIONS; ++iteration)\n        {\n          let expandedObject = {};\n          // we could do a check at the end of each loop, but it's easier to track object equality this way\n          let objectHasExpanded = false;\n          for(const [root, related] of Object.entries(patternToRelated))\n          {\n            let expandedNodeSet = new Set(related);\n            for( const node of expandedNodeSet )\n            {\n              if( node in patternToRelated )\n              {\n                // set union\n                expandedNodeSet = new Set([...expandedNodeSet, ...patternToRelated[node]]);\n              }\n            }\n            objectHasExpanded = objectHasExpanded || ( expandedNodeSet.size !== related.size );\n            expandedObject[ root ] = expandedNodeSet;\n\n          }\n          // exit if no change\n          if(!objectHasExpanded)\n          {\n            break;\n          }\n          // throw if we've failed to resolve all the connections by now, morelikely something has gone wrong\n          if( iteration === MAX_ITERATIONS )\n          {\n            throw new Error(\"Reached max virtual_pattern recursion depth.\");\n          }\n          // otherwise update mapping and continue\n          patternToRelated = expandedObject;\n        }\n\n        for( const [rootPatternName, relatedPatternSet] of Object.entries(patternToRelated) )\n        {\n          // could do filter, and assert on length?\n          let rootPattern = patternsWithTracks.find(p => p.name === rootPatternName);\n          for( const patternToMergeName of relatedPatternSet )\n          {\n            const patternToMerge = patternsWithTracks.find(p => p.name === patternToMergeName );\n            for( const [id, t] of Object.entries(patternToMerge.instrumentTracks) )\n            {\n              if( id in rootPattern.instrumentTracks )\n              {\n                const merged = rootPattern.instrumentTracks[ id ].aggregate( t );\n                // we match hydrogen's implementation here and discard values past the length of the original track\n                merged.rep.length = rootPattern.size  / merged.resolution;\n                rootPattern.instrumentTracks[ id ] = merged;\n              }\n              else\n              {\n                // ensure track is the appropriate length & res\n                let copiedTrack = t.format(rootPattern.resolution);\n                copiedTrack.length = rootPattern.size  / rootPattern.resolution;\n                rootPattern.instrumentTracks[id] = copiedTrack;\n              }\n            }\n          }\n          // reassess resolution and apply to all tracks\n          // this may not be necessary but it's probably nice\n          const resolution = calculatePatternResolution(rootPattern, rootPattern.size);\n          rootPattern.resolution = resolution;\n          for( const [id, track] of Object.entries(rootPattern.instrumentTracks) )\n          {\n            // ensure that\n            rootPattern[id] = track.format( resolution );\n          }\n        }\n\n      }\n    }\n\n\n    return {\n      \"instruments\" : instrumentArray,\n      \"patterns\" : patternsWithTracks\n    }\n}\n\nasync function parseHydrogenPromise(xmlString)\n{\n  let parser = new xml2js.Parser();\n\n  return parser.parseStringPromise(xmlString).then(parseHydrogenJs);\n}\n\nconst moduleExports = { parseHydrogenPromise };\n\nexport default moduleExports;","import React from 'react';\nimport IconButton from '@material-ui/core/IconButton';\nimport PlayArrowIcon from '@material-ui/icons/PlayArrow';\nimport StopIcon from '@material-ui/icons/Stop';\nimport Slider from '@material-ui/core/Slider';\nimport Grid from '@material-ui/core/Grid';\n\nfunction PlaybackControls(props)\n{\n  const tempoControlColumns = 4;\n\n  const onPlay = ()=>{ if(props.onPlay){ props.onPlay(); }; };\n  const onStop = ()=>{ if(props.onStop){ props.onStop(); }; };\n  const onSetTempo = (event, tempo)=>{ if(props.onTempoChange){ props.onTempoChange(tempo); } };\n\n  return (\n      <React.Fragment>\n        <div>\n          <IconButton\n            color=\"primary\"\n            aria-label=\"play\"\n            onClick={onPlay}\n          >\n            <PlayArrowIcon />\n          </IconButton>\n          <IconButton\n            color=\"secondary\"\n            aria-label=\"stop\"\n            onClick={onStop}\n          >\n            <StopIcon />\n          </IconButton>\n        </div>\n\n        <Grid container>\n        <Grid item xs={(12 - tempoControlColumns) / 2} />\n        <Grid item xs={tempoControlColumns}>\n        <Slider\n          defaultValue={100}\n          min={60}\n          step={1}\n          max={180}\n          onChange={onSetTempo}\n          valueLabelDisplay=\"auto\"\n        />\n        </Grid>\n        <Grid item xs={(12 - tempoControlColumns ) / 2} />\n        </Grid>\n\n      </React.Fragment>\n   );\n};\n\nexport default PlaybackControls;","// History.js\n\nimport React from 'react'\nimport { makeStyles } from '@material-ui/core/styles';\nimport List from '@material-ui/core/List';\nimport ListItem from '@material-ui/core/ListItem';\nimport ListItemText from '@material-ui/core/ListItemText';\n\nconst useStyles = makeStyles((theme) => ({\n  root: {\n    width: '100%',\n    height: 400,\n    maxWidth: 300,\n    backgroundColor: theme.palette.background.paper,\n  },\n}));\n\n\nfunction renderRow(props) {\n  return (\n    <ListItem button style={props.style} key={props.index} onClick={props.onClick}>\n      <ListItemText primary={props.name} secondary={new Date(props.date).toLocaleDateString()}/>\n    </ListItem>\n  );\n}\n\nconst demoData = [\n  {name: \"roudesann\", id: \"3b415c320894e531f4daa93711949e78c0aef281\", \"date\": Date.now()},\n  {name: \"groovy\", id: \"f23c52481af0c08f5037d820a0cf33e886061ffc\", \"date\": Date.now()},\n  {name: \"too_much\", id: \"e7db6989c558e201bceff225d796f0d6073047a9\", \"date\": Date.now()}\n];\n\nfunction History(props)\n{\n  const classes = useStyles();\n  const items = props.data ?? demoData;\n  return (\n    <div style={{maxHeight: 200, overflow: 'auto'}} className={classes.root}>\n      <div>Recently viewed</div>\n      <List>\n            {[...items.keys()].map ( x => renderRow({\n              index : x,\n              name: items[x].name,\n              id: items[x].id,\n              date: items[x].date,\n              onClick: ()=>{if(props.onClick){props.onClick(items[x]);}}\n            }))}\n      </List>\n    </div>\n  );\n};\n\nexport default History;\n","import React from 'react';\nimport notation from \"./notation\"\nimport Typography from '@material-ui/core/Typography';\nimport { withStyles } from '@material-ui/core/styles';\n\nconst styles = (theme)=>({\n  root: {\n    whiteSpace: \"pre\",\n    fontFamily: \"Roboto Mono\",\n    fontSize: '0.8rem',\n    '@media (min-width:800px)': {\n      fontSize: '1rem',\n    },\n  }\n});\nconst PreTypography = withStyles(styles)(Typography);\n\nclass Part extends React.Component\n{\n  constructor(props) {\n    super(props);\n    this.state = {\n    };\n  }\n\n  render() {\n    const tracks = Object.values(this.props.tracks);\n    if(tracks.length === 0 )\n    {\n      return <React.Fragment />\n    }\n    const patternArray = notation.formatPatternString(\n      this.props.instrument,\n      this.props.tracks,\n      this.props.config.restMark\n    );\n    // don't support a multi-line pattern, that doesn't divide the beatResolution\n    // because it's a nightmare!\n    const patternResolution = tracks[0].resolution;\n    if( (this.props.config.lineResolution % this.props.config.beatResolution) !== 0\n        && ( patternArray.length * patternResolution > this.props.config.lineResolution ) )\n    {\n      throw new Error(\"This code only supports a beatResolution that divides the lineResolution\");\n    }\n    // this code has got very convoluted\n    const patternLines = notation.chunkArray(patternArray, this.props.config.lineResolution / patternResolution, 0);\n    const beatsPerLine = this.props.config.lineResolution / this.props.config.beatResolution;\n    const beatChunkSize = this.props.config.beatResolution / patternResolution;\n    const linesWithBeats = patternLines.map(\n      line => notation.chunkArray( line, beatChunkSize )\n    );\n    const lineIndices = [...patternLines.keys()];\n    const formatLine = (key, line, startBeat)=>{\n      const beats = [...line.keys()];\n      return (\n        <PreTypography key={\"pattern-line-\" + key}>\n          <PreTypography variant=\"subtitle1\" component=\"span\" key={\"line-start-\" + key}>{this.props.config.lineMark}</PreTypography>\n          {\n            beats.map( beat => <React.Fragment key={\"fragment-beat-\"+ (beat + startBeat).toString()}>\n              <PreTypography variant=\"subtitle1\" component=\"span\" key={\"span-beat-\" + (beat + startBeat).toString()} className={(beat + startBeat) === this.props.activeNote ? \"activeNote\" : \"\"}>{line[beat].join(\"\")}</PreTypography>\n              <PreTypography variant=\"subtitle1\" component=\"span\" key={\"span-beat-marker-\" + (beat + startBeat).toString()}>{(this.props.config.showBeatMark && beat !== beats[beats.length-1]) ? this.props.config.beatMark : \"\"}</PreTypography>\n            </React.Fragment>\n            )\n          }\n          <PreTypography variant=\"subtitle1\" component=\"span\" key={\"line-end-\" + key}>{this.props.config.lineMark}</PreTypography>\n        </PreTypography>\n      );\n    };\n\n    const numberLine = notation.createNumberMarker(\n      this.props.config.numberRestMark,\n      this.props.config.beatResolution,\n      patternResolution,\n      Math.min( this.props.config.lineResolution, patternLines[0].length * patternResolution )\n    );\n    const beatChunks = notation.chunkArray(\n      numberLine,\n      this.props.config.beatResolution / patternResolution\n    );\n    return (\n      <React.Fragment>\n        {this.props.config.showBeatNumbers ? formatLine(\"beat\", beatChunks, 0) : \"\" }\n        {lineIndices.map(lineIndex=>formatLine(lineIndex.toString(), linesWithBeats[lineIndex], beatsPerLine * lineIndex))}\n      </React.Fragment>\n    );\n  }\n}\n\nexport default withStyles(styles)(Part);","import React from 'react';\nimport Part from \"./Part\";\n\nfunction getTitleType(headingLevel, defaultLevel)\n{\n    const validHeadingLevels = ['h1', 'h2', 'h3', 'h4', 'h5', 'h6'];\n    const safeHeading = headingLevel ? headingLevel.toLowerCase() : '';\n    const Title = validHeadingLevels.includes(safeHeading) ? safeHeading : defaultLevel;\n    return Title;\n}\n\nclass PartWithTitle extends React.Component\n{\n  constructor(props) {\n    super(props);\n    this.state = {\n    };\n  }\n\n  render() {\n    const Title = getTitleType(this.props.headingLevel, \"h4\");\n    return (\n      <article>\n        <Title>{this.props.instrumentName}</Title>\n        <Part\n          instrument={this.props.instrument}\n          tracks={this.props.tracks}\n          config={this.props.config}\n          activeNote={this.props.activeNote}\n        />\n      </article>\n    );\n  }\n}\n\nexport default PartWithTitle;","import React from 'react';\nimport PartWithTitle from \"./PartWithTitle\";\nimport { withStyles } from '@material-ui/core/styles';\n\nconst useStyles = theme => ({\n  root: {\n    \"margin-bottom\": theme.spacing(2),\n    fontFamily: \"Roboto Mono\",\n    textAlign: \"left\",\n    whiteSpace:\"pre\",\n    \"& .activeNote\": {\n      color : theme.palette.primary.main\n    },\n    \"margin\": \"auto\"\n  },\n});\n\nclass Pattern extends React.Component\n{\n  constructor(props) {\n    super(props);\n    this.state = {\n      patternTime : undefined\n    };\n  }\n\n  onPatternTimeChange(patternTime)\n  {\n    if( patternTime !== null && patternTime !== undefined )\n    {\n      this.setState({patternTime : patternTime});\n    }\n    else\n    {\n      this.setState({patternTime : undefined });\n    }\n  }\n\n  render() {\n    const { classes } = this.props;\n    const instrumentIndices = [...this.props.instruments.keys()];\n    const beatResolution = this.props.config.beatResolution;\n    return (\n      <div className={classes.root} >\n        <div style={{\"margin\": \"auto\"}}>\n        { instrumentIndices.map(\n            (instrumentIndex) => ( <PartWithTitle\n              key={\"part-\" + instrumentIndex.toString()}\n              instrumentName={this.props.instruments[instrumentIndex][0]}\n              instrument={this.props.instruments[instrumentIndex][1]}\n              tracks={this.props.tracks}\n              config={this.props.config}\n              activeNote={this.state.patternTime !== undefined ? Math.floor(this.state.patternTime / beatResolution) : undefined}\n            /> )\n          )\n        }\n        </div>\n      </div>\n    );\n  }\n}\n\nexport default withStyles(useStyles)(Pattern);","import React from \"react\";\nimport {\n  BrowserRouter as Router,\n  Switch,\n  Route,\n  Redirect\n} from \"react-router-dom\";\nimport App from \"./App\";\n\n\nexport default function Routes() {\n  return (\n    <Router basename={process.env.PUBLIC_URL}>\n        <Switch>\n          <Route\n            path=\"/song/:song\"\n            component={App}\n          />\n          <Route\n            path=\"/launch\"\n            component={App}\n          />\n          <Route\n            path=\"/\"\n          >\n            <Redirect to=\"/launch\" />\n          </Route>\n        </Switch>\n    </Router>\n  )\n};","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' },\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport Routes from './Routes';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(\n  <React.StrictMode>\n    <Routes />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n","\nclass notation\n{\n\n  static DEFAULT_FORMAT_CONFIG = {\n    \"restMark\" : \"-\",\n    \"beatMark\" : \"|\",\n    \"lineMark\" : \"|\",\n    \"numberRestMark\" : \"-\",\n    \"beatResolution\" : 48,\n    \"showBeatMark\" : true,\n    \"showBeatNumbers\" : true,\n    // lineResolution is typically determined on a per-pattern basis\n    // however it used to be in here, and some tests still rely on this\n    \"lineResolution\" : 48 * 8\n  };\n\n  static FORMAT_CONFIG_STRINGS = [\n    [\"restMark\",[\"-\", \".\", \" \"]],\n    [\"numberRestMark\",[\"-\", \".\", \" \"]]\n  ];\n\n  static FORMAT_CONFIG_BOOLS = [\n    \"showBeatMark\",\n    \"showBeatNumbers\"\n  ];\n\n  static validateConfig(config, patternResolution) {\n    if( patternResolution != null && ( config.beatResolution % patternResolution ) !== 0 )\n    {\n      throw new Error(\"patternResolution doesn't divide beatResolution\");\n    }\n    if( config.lineResolution <= 0 )\n    {\n      throw new Error(\"config.lineResolution must be greater than zero\");\n    }\n  }\n\n  static resolveConfig(formatConfig)\n  {\n    for( const propName of Object.keys(formatConfig))\n    {\n      if(!notation.DEFAULT_FORMAT_CONFIG.hasOwnProperty(propName))\n      {\n        throw new Error(\"passed unrecognised property \" + propName);\n      }\n    }\n\n    return Object.assign( Object.assign({}, notation.DEFAULT_FORMAT_CONFIG), formatConfig );\n  }\n\n  static chunkString(str, chunkSize) {\n    if( chunkSize <= 0 )\n    {\n      throw new Error(\"chunkSize must be > 0\")\n    }\n    return str.match(new RegExp('.{1,' + chunkSize + '}', 'g'));\n  }\n\n  static chunkArray(a, chunkSize)\n  {\n    if( chunkSize <= 0 )\n    {\n      throw new Error(\"chunkSize must be > 0\")\n    }\n    let chunks = [];\n    for( let i = 0; i < a.length; i += chunkSize )\n    {\n      chunks.push( a.slice(i, Math.min( i + chunkSize, a.length) ) );\n    }\n    return chunks;\n  }\n\n  static createNumberMarker(numberRestMark, beatResolution, patternResolution, lineLength)\n  {\n    if( lineLength <= 0 )\n    {\n      throw new Error(\"lineLength <= 0\");\n    }\n\n    if( ( beatResolution % patternResolution ) !== 0)\n    {\n      throw new Error(\"patternResolution \" + patternResolution.toString() + \" does not divide beatResolution \" + beatResolution.toString());\n    }\n\n    let beatCount = Math.ceil(lineLength / beatResolution);\n    let numberMarkerArray = Array.from( Array(lineLength / patternResolution), e => numberRestMark );\n\n    for( let beat = 0; beat < beatCount; beat++ )\n    {\n      numberMarkerArray[ beat * ( beatResolution / patternResolution ) ] = ( (beat+1) % 10 ).toString();\n    }\n    return numberMarkerArray;\n  }\n\n  static formatLineWithMarkers(config, line, patternResolution, asHTML)\n  {\n    notation.validateConfig(config);\n\n    const beatChunkSize = config.beatResolution / patternResolution;\n\n    const padZero = (n, width) => {\n      n = n + '';\n      return n.length >= width ? n : new Array(width - n.length + 1).join('0') + n;\n    };\n    const formatSymbolAsSpans = (symbol, numericPosition) => {\n      return \"<span class='note-\" + padZero(numericPosition, 4) + \"'>\" +  symbol + \"</span>\";\n    };\n\n    const formatSymbol = asHTML ? formatSymbolAsSpans : (symbol, numericPosition) => symbol;\n\n    let formattedLine = \"\";\n    for( let index = 0; index < line.length; ++ index )\n    {\n      const numericPosition = patternResolution * index;\n      formattedLine += formatSymbol(line.charAt(index), numericPosition);\n    }\n\n\n    const lineWithBeats = config.showBeatMark ? notation.chunkString(formattedLine, beatChunkSize * formatSymbol(\"X\", 0).length).join(config.beatMark) : formattedLine;\n    // note: we choose to always show the lineMarker even if it doesn't match the line resolution\n    return config.lineMark + lineWithBeats + config.lineMark;\n  }\n\n  static defaultLineResolution(\n    trackDict,\n    beatResolution\n  )\n  {\n    const instrumentTracks = Object.values(trackDict);\n    if(instrumentTracks.length === 0)\n    {\n      return 48 * 8;\n    }\n    const trackLength = instrumentTracks[0].length();\n    const beatCount = trackLength / beatResolution;\n    if( beatCount <= 12 )\n    {\n      return trackLength;\n    }\n    else if( beatCount > 32 )\n    {\n      return 48 * 16; // let's just be laazeee\n    }\n    else\n    {\n      // let's just apply a simple mapping, rather than think through logics\n      const mapping = [\n        trackLength, // 13\n        trackLength / 2, // 14\n        trackLength / 3, // 15\n        trackLength / 2, // 16\n        trackLength, // 17\n        trackLength / 3, // 18\n        trackLength, // 19\n        trackLength / 4, // 20\n        trackLength / 3, // 21\n        trackLength / 2, // 22\n        trackLength, // 23\n        trackLength / 3, // 24\n        trackLength / 5, // 25\n        trackLength, // 26\n        trackLength / 3, // 27\n        trackLength / 4, // 28\n        trackLength, // 29\n        trackLength / 6, // 30\n        trackLength, // 31\n        trackLength / 4, // 32\n      ];\n      return mapping[ beatCount - 13 ];\n    }\n  }\n\n  static guessPerPatternSettings(\n    trackDict\n  )\n  {\n    return {\n      \"lineResolution\" : notation.defaultLineResolution(trackDict, 48), // beatResolution (default)\n      \"beatResolution\" : 48 // should cover all the cases hopefully\n    };\n  }\n\n  static formatPatternString(\n    instrument,\n    trackDict,\n    restMark\n  )\n  {\n    let instrumentTracks = Object.values(trackDict);\n    if(instrumentTracks.length === 0)\n    {\n      return \"\";\n    }\n\n    const patternSize = instrumentTracks[0].length();\n    const patternResolution = instrumentTracks[0].resolution;\n    const notationLength = patternSize / patternResolution;\n\n    let patternArray = Array(notationLength).fill(restMark);\n    for( let charIndex = 0; charIndex < patternArray.length; ++charIndex)\n    {\n      // todo: handle collisions\n      for( const [trackID, trackSymbol] of Object.entries(instrument) )\n      {\n        const trackInstance = trackDict[trackID];\n        if( trackInstance != null && trackInstance.rep[charIndex] === 1 )\n        {\n          patternArray[charIndex] = trackSymbol;\n        }\n      }\n    }\n    return patternArray;\n  }\n\n  static fromInstrumentAndTrack(\n    instrument,\n    trackDict,\n    asHTML,\n    formatConfig = {}\n  )\n  {\n    const config = notation.resolveConfig(formatConfig);\n\n    let instrumentTracks = Object.values(trackDict);\n    if(instrumentTracks.length === 0)\n    {\n      return \"\";\n    }\n\n    // turn the tracks, into one char string\n    const patternArray = notation.formatPatternString( instrument, trackDict, config.restMark );\n    const patternString = patternArray.join(\"\");\n    const patternResolution = instrumentTracks[0].resolution;\n    const patternSize = instrumentTracks[0].length();\n\n    // handle lines and beatMarkers\n    let lineArray = notation.chunkString( patternString, config.lineResolution / patternResolution );\n\n    let formattedLineArray = [];\n    // add numbers on the first line\n    if( config.showBeatNumbers )\n    {\n      formattedLineArray.push( notation.formatLineWithMarkers(\n        config,\n        notation.createNumberMarker(config.numberRestMark, config.beatResolution, patternResolution, Math.min(config.lineResolution, patternSize)).join(\"\"),\n        patternResolution,\n        asHTML\n      ) );\n    }\n    for( let i = 0; i < lineArray.length; ++i )\n    {\n      formattedLineArray.push( notation.formatLineWithMarkers( config, lineArray[i], patternResolution, asHTML ) );\n    }\n\n    return formattedLineArray.join(\"\\n\");\n  }\n};\n\nexport default notation;","// Mobile.js\n\nfunction  isMobile()\n{\n  // the simple version from\n  // https://stackoverflow.com/questions/11381673/detecting-a-mobile-browser\n  const userAgent = (navigator.userAgent||navigator.vendor||window.opera);\n  const toMatch = [\n      /Android/i,\n      /webOS/i,\n      /iPhone/i,\n      /iPad/i,\n      /iPod/i,\n      /BlackBerry/i,\n      /Windows Phone/i\n  ];\n\n  return toMatch.some((toMatchItem) => {\n      return userAgent.match(toMatchItem);\n  });\n}\n\nexport { isMobile };","const DEFAULT_INSTRUMENT_SYMBOLS = {\n  \"Djembe Slap\" : \"S\",\n  \"Djembe Tone\" : \"t\",\n  \"Djembe Bass\" : \"O\",\n  \"Snare Ghost\" : \"x\",\n  \"Snare Accent\" : \"X\",\n  \"Shaker Ghost\" : \"x\",\n  \"Shaker Accent\" : \"X\",\n  \"Click\" : \"X\",\n  \"Bass\" : \"O\",\n  \"Tom\" : \"O\",\n  \"Default\" : \"X\"\n};\n\nfunction normalizeInstrumentsForFiguring(instruments)\n{\n  let n = [];\n  for(const inst of instruments)\n  {\n    let nInst = Object.assign({}, inst);\n    // for some reason these instruments are one-size arrays, and one id ... the track id from hydrogen\n    // this should be fixed, this doesn't make sense\n    nInst.name = nInst.name.toLowerCase();\n    n.push( nInst );\n  }\n  return n;\n}\n\nfunction figureDjembes(instrumentsRaw, symbolConfig)\n{\n  const instruments = normalizeInstrumentsForFiguring(instrumentsRaw);\n  const djembeTracks = instruments.filter( (inst) => inst.name.includes(\"djembe\") );\n  if(djembeTracks.length === 0)\n  {\n    return [];\n  }\n  else if(djembeTracks.length <= 3)\n  {\n    // let's lazily assume we have a slap, tone, bass\n    const slapArray = Array.from( djembeTracks, (inst) => inst.name.includes(\"slap\") );\n    const toneArray = Array.from( djembeTracks, (inst) => inst.name.includes(\"tone\") );\n    const bassArray = Array.from( djembeTracks, (inst) => inst.name.includes(\"bass\") );\n    for( let i = 0; i < djembeTracks.length; ++i )\n    {\n      let parityCheck = slapArray[i] + toneArray[i] + bassArray[i];\n      // failed to figure out how djembes work return empty array\n      if(parityCheck !== 1)\n      {\n        return [];\n      }\n    }\n    let djembeMapping = {};\n    for( let i = 0; i < djembeTracks.length; ++i )\n    {\n      if( slapArray[i] )\n      {\n        djembeMapping[ djembeTracks[i].id.toString() ] = symbolConfig[\"Djembe Slap\"];\n      }\n      else if( toneArray[i] )\n      {\n        djembeMapping[ djembeTracks[i].id.toString() ] = symbolConfig[\"Djembe Tone\"];\n      }\n      else if( bassArray[i] )\n      {\n        djembeMapping[ djembeTracks[i].id.toString() ] = symbolConfig[\"Djembe Bass\"];\n      }\n    }\n    return [ [ \"Djembe\", djembeMapping ] ];\n  }\n  else\n  {\n    // TODO: support more than one djembe\n    return []\n  }\n}\n\n// used by snare/shaker\nfunction manageAccentOrGhost(instrumentTracks, instrumentName, accentSymbol, ghostSymbol)\n{\n  let outputInstruments = [];\n  if(instrumentTracks.length === 2)\n  {\n    const t0 = instrumentTracks[0];\n    const t1 = instrumentTracks[1];\n    // attempt to determine ghost/accent\n    const zeroLouder = t0.volume > t1.volume || (t0.volume === t1.volume && t0.gain > t1.gain);\n    let mapping = {};\n    mapping[ t0.id.toString() ] = zeroLouder ? accentSymbol : ghostSymbol;\n    mapping[ t1.id.toString() ] = zeroLouder ? ghostSymbol : accentSymbol;\n    outputInstruments.push([instrumentName, mapping] );\n  }\n  else // if 1 it must be an accent, if >= 3 ... I don't want to try and assign ghosts/accents\n  {\n    // I don't want to support ghost/accent here right now\n    for( const track of instrumentTracks )\n    {\n      let mapping = {};\n      mapping[ track.id.toString() ] = accentSymbol;\n      outputInstruments.push([instrumentName, mapping] );\n    }\n  }\n  return outputInstruments;\n\n}\n\nfunction figureShakers(instrumentsRaw, symbolConfig)\n{\n  const instruments = normalizeInstrumentsForFiguring(instrumentsRaw);\n  // todo: support common alternative shakers? Tambourine?\n  const shakerTracks = instruments.filter( (inst) => ( inst.name.includes(\"shaker\") ) );\n  return manageAccentOrGhost(\n    shakerTracks,\n    \"Shaker\",\n    symbolConfig[\"Shaker Accent\"],\n    symbolConfig[\"Shaker Ghost\"]\n  );\n}\n\nfunction figureSnares(instrumentsRaw, symbolConfig)\n{\n  const instruments = normalizeInstrumentsForFiguring(instrumentsRaw);\n  const snareTracks = instruments.filter( (inst) => ( inst.name.includes(\"snare\") ) );\n  // todo: we currently assume 2 snares is accent/ghost ... but I think it's relatively\n  // common to be 2 snare parts too, I think the algorithm here is check patterns to\n  // see if they overlap ... if the \"ghosts\" overlap the \"hits\" sometimes, assume 2 parts\n  return manageAccentOrGhost(\n    snareTracks,\n    \"Snare\",\n    symbolConfig[\"Snare Accent\"],\n    symbolConfig[\"Snare Ghost\"]\n  );\n}\n\n\nfunction activeInstruments(patterns)\n{\n  let nonTrivialInstruments = new Set();\n  for( const p of patterns )\n  {\n    for(const [instrumentID, part] of Object.entries(p.instrumentTracks))\n    {\n      if( !part.empty() )\n      {\n        nonTrivialInstruments.add(parseInt(instrumentID));\n      }\n    }\n  }\n  return nonTrivialInstruments;\n}\n\nfunction activeInstrumentation(instrumentIndex, patterns)\n{\n  const active = activeInstruments(patterns);\n  let nonTrivialInstruments = [];\n  for( const inst of instrumentIndex)\n  {\n    if( active.has(inst.id) )\n    {\n      nonTrivialInstruments.push( inst );\n    }\n  }\n  return nonTrivialInstruments;\n}\n\nfunction figureClickyInstruments(instrumentsRaw, symbolConfig, patterns)\n{\n  const instruments = normalizeInstrumentsForFiguring(instrumentsRaw);\n  const worthwhileInstruments = activeInstruments(patterns);\n  const relevantTracks = instruments.filter( (inst) => ( worthwhileInstruments.has(inst.id) &&\n    !inst.name.includes(\"djembe\") &&\n    ( inst.name.includes(\"click\") ||\n    inst.name.includes(\"stick\") ||\n    inst.name.includes(\"tom\") ||\n    inst.name.includes(\"bass\") ||\n    inst.name.includes(\"kick\") )\n  ) );\n\n  const trackIsClick = Array.from(\n    relevantTracks,\n    (t) => t.name.includes(\"click\") || t.name.includes(\"stick\")\n  );\n  // we prioritise the early tracks\n  // and hope for the best\n\n  let tomIndex = 1;\n  let bassIndex = 1;\n  let collated = [];\n  for( let candidate = 0; candidate < Math.floor(relevantTracks.length/2); ++candidate )\n  {\n    if( trackIsClick[candidate*2] !== trackIsClick[candidate*2+1] )\n    {\n      const clickTrack = trackIsClick[candidate*2] ? relevantTracks[candidate*2] : relevantTracks[candidate*2+1];\n      const hitTrack = trackIsClick[candidate*2] ? relevantTracks[candidate*2+1] : relevantTracks[candidate*2];\n      const instrumentIsTom = hitTrack.name.includes(\"tom\");\n      let rawInstrumentName = instrumentIsTom ? \"Tom\" : \"Bass\";\n      let instrumentName = \"\"\n      if( instrumentIsTom )\n      {\n        instrumentName = rawInstrumentName + ( (tomIndex >= 2) ? \" \" + tomIndex.toString() : \"\" );\n        tomIndex = tomIndex + 1;\n      }\n      else\n      {\n        instrumentName = rawInstrumentName + ( (bassIndex >= 2) ? \" \" + bassIndex.toString() : \"\" );\n        bassIndex = bassIndex + 1;\n      }\n      let mapping = {};\n      mapping[hitTrack.id.toString()] = symbolConfig[rawInstrumentName];\n      mapping[clickTrack.id.toString()] = symbolConfig[\"Click\"];\n      collated.push([instrumentName, mapping] );\n    }\n  }\n\n  // If there's a remainder instrument and there's no click\n  if( ((relevantTracks.length % 2 ) !== 0) && !trackIsClick[ relevantTracks.length - 1 ] )\n  {\n    const lastTrack = relevantTracks[relevantTracks.length - 1];\n    const instrumentIsTom = lastTrack.name.includes(\"tom\");\n    let rawInstrumentName = instrumentIsTom ? \"Tom\" : \"Bass\";\n    let instrumentName = \"\"\n    if( instrumentIsTom )\n    {\n      instrumentName = rawInstrumentName + ( (tomIndex >= 2) ? \" \" + tomIndex.toString() : \"\" );\n      tomIndex = tomIndex + 1;\n    }\n    else\n    {\n      instrumentName = rawInstrumentName + ( (bassIndex >= 2) ? \" \" + bassIndex.toString() : \"\" );\n      bassIndex = bassIndex + 1;\n    }\n    let mapping = {};\n    mapping[lastTrack.id.toString()] = symbolConfig[rawInstrumentName];\n    collated.push([instrumentName, mapping] );\n  }\n  return collated;\n}\n\nfunction defaultSymbolForSingleInstrument(symbolConfig, name)\n{\n  // we expect these keys\n  /*\n    \"Djembe Slap\" : \"S\",\n    \"Djembe Tone\" : \"t\",\n    \"Djembe Bass\" : \"O\",\n    \"Snare Ghost\" : \"-\",\n    \"Snare Accent\" : \"X\",\n    \"Shaker Ghost\" : \"x\",\n    \"Shaker Accent\" : \"X\",\n    \"Click\" : \"X\",\n    \"Bass\" : \"O\",\n    \"Tom\" : \"O\",\n    \"Default\" : \"X\"\n  */\n  const lowerName = name.toLowerCase();\n  if( lowerName.includes(\"click\") || lowerName.includes(\"stick\") )\n  {\n    return symbolConfig[\"Click\"];\n  }\n  else if( lowerName.includes(\"bass\") || lowerName.includes(\"kick\") )\n  {\n    return symbolConfig[\"Bass\"]\n  }\n  else if( lowerName.includes(\"snare\") )\n  {\n    return symbolConfig[\"Snare Accent\"];\n  }\n  else if( lowerName.includes(\"shaker\") )\n  {\n    return symbolConfig[\"Shaker\"];\n  }\n  else if( lowerName.includes(\"tom\") )\n  {\n    return symbolConfig[\"Tom\"];\n  }\n  else if( lowerName.includes(\"djembe\") )\n  {\n    if( lowerName.includes(\"slap\") )\n    {\n      return symbolConfig[\"Djembe Slap\"];\n    }\n    else if( lowerName.includes(\"tone\") )\n    {\n      return symbolConfig[\"Djembe Tone\"];\n    }\n    else\n    {\n      return symbolConfig[\"Djembe Bass\"];\n    }\n  }\n  return symbolConfig[\"Default\"];\n}\n\nfunction figureInstruments(instrumentsRaw, symbolConfig, patterns)\n{\n  let output = [];\n  output = output.concat( figureClickyInstruments( instrumentsRaw, symbolConfig, patterns ) );\n  output = output.concat( figureDjembes( instrumentsRaw, symbolConfig ) );\n  output = output.concat( figureSnares( instrumentsRaw, symbolConfig ) );\n  output = output.concat( figureShakers( instrumentsRaw, symbolConfig ) );\n\n  // we ignore track used by multiple instruments\n\n  // but attempt to cover \"instrument not recognised anywhere\"\n\n  const worthwhileInstruments = activeInstruments(patterns);\n\n  for(const inst of instrumentsRaw)\n  {\n    if( !worthwhileInstruments.has(inst.id) )\n    {\n      continue;\n    }\n    let instrumentUsed = false;\n    for( const op of output)\n    {\n      if( inst.id.toString() in op[1] )\n      {\n        instrumentUsed = true;\n      }\n    }\n    if(instrumentUsed === false)\n    {\n      let mapping = {};\n      mapping[ inst.id.toString() ] = defaultSymbolForSingleInstrument( symbolConfig, inst.name );\n      output.push( [inst.name, mapping] );\n    }\n  }\n\n  return output;\n}\n\nexport { activeInstrumentation, DEFAULT_INSTRUMENT_SYMBOLS, figureClickyInstruments, figureDjembes, figureShakers, figureSnares, figureInstruments };","import React from 'react';\nimport { makeStyles } from '@material-ui/core/styles';\nimport FormControlLabel from '@material-ui/core/FormControlLabel';\nimport Checkbox from '@material-ui/core/Checkbox';\n\n// table\nimport Table from '@material-ui/core/Table';\nimport TableBody from '@material-ui/core/TableBody';\nimport TableCell from '@material-ui/core/TableCell';\nimport TableContainer from '@material-ui/core/TableContainer';\nimport TableHead from '@material-ui/core/TableHead';\nimport TableRow from '@material-ui/core/TableRow';\n\nimport AddBoxIcon from '@material-ui/icons/AddBox';\nimport EditIcon from '@material-ui/icons/Edit';\nimport Button from '@material-ui/core/Button';\nimport IconButton from '@material-ui/core/IconButton';\nimport ClearIcon from '@material-ui/icons/Clear';\n\nimport TextField from '@material-ui/core/TextField';\nimport Dialog from '@material-ui/core/Dialog';\nimport DialogActions from '@material-ui/core/DialogActions';\nimport DialogContent from '@material-ui/core/DialogContent';\nimport DialogContentText from '@material-ui/core/DialogContentText';\nimport DialogTitle from '@material-ui/core/DialogTitle';\nimport { withStyles } from '@material-ui/core/styles';\nimport Typography from '@material-ui/core/Typography';\n\nimport Grid from '@material-ui/core/Grid';\nimport VolumeOffIcon from '@material-ui/icons/VolumeOff';\nimport VolumeMuteIcon from '@material-ui/icons/VolumeMute';\nimport VolumeDownIcon from '@material-ui/icons/VolumeDown';\nimport VolumeUpIcon from '@material-ui/icons/VolumeUp';\nimport ClickNHold from 'react-click-n-hold';\nimport Slider from '@material-ui/core/Slider';\n\nimport {isMobile} from \"./Mobile\";\n\nconst useStyles = makeStyles((theme) => ({\n  root: {\n    display: 'flex',\n  }\n}));\n\nconst ThinFormControlLabel = withStyles({\n  root: {\n    marginLeft: 0,\n    marginRight: 0\n  }\n})(FormControlLabel);\n\nconst InlinableIconButton = withStyles({\n  root: {\n    padding: 2\n  }\n})(IconButton);\n\nconst NoDividerCenterTableCell = withStyles((theme) => ({\n  root: {\n    borderBottom: \"none\",\n    textAlign: \"center\",\n    paddingBottom: theme.spacing(0) // make instrument titles bunch up with their controls a little more\n  }\n}))(TableCell);\n\nconst CenterTableCell = withStyles((theme) => ({\n  root: {\n    textAlign: \"center\"\n  }\n}))(TableCell);\n\nfunction VolumeWidget(props)\n{\n  const [active, setActive] = React.useState(false);\n  const [sliderValue, setSliderValue] = React.useState(100);\n  const [muted, setMuted] = React.useState(props.muted);\n  const sliderRef = React.useRef(null);\n  const height = props.height ? props.height / 3 : 24;\n  const FixedHeightStylings = {\n    height: 3*height,\n    position: \"absolute\",\n    top: -height\n  };\n  const SliderStyles = Object.assign(active? {} : {\"visibility\": \"hidden\", paddingLeft: \"0px\"}, FixedHeightStylings);\n  const IconStyles = active ?  {\"visibility\":\"hidden\"} : {};\n\n  // currently: updating based on the normal volume event isn't nearly performant enough\n  // (because the app's state update is really sluggish)\n  // potential fixes - seperate the audio and the visual state and/or create smaller state objects\n  const setVolume = (event, value) =>\n  {\n    setSliderValue(value);\n    if( props.onChange )\n    {\n      props.onChange( value );\n    }\n  };\n\n  // for mobile\n  // we click'n'hold which opens the volume slider, but don't propagate focus\n\n  // for desktop/tablet\n  // we click'n'hold and propagate focus to the slider, so that our drag\n  // will pull the slider up and down\n  const mobile = isMobile();\n\n  const holdDesktop = (start, event)=>{\n    if(!active){ setActive(true); }\n    if(sliderRef){ sliderRef.current.dispatchEvent(event.nativeEvent);}\n  };\n\n  const holdMobile= (start, event)=>{\n    if(!active){ setActive(true); }\n  };\n\n  const holdEndDesktop = (e)=>{\n    setActive(false);\n  };\n\n  const commitVolume = (event,value)=>\n  {\n    if( mobile ){ setActive(false); }\n    setVolume(event,value);\n  };\n\n  const onMuteChange = () =>\n  {\n    setMuted(!muted);\n    props.onMuteEvent(!muted);\n  };\n\n  return (\n    <ClickNHold\n      time={0.5} // Time to keep pressing. Default is 2\n      onClickNHold={mobile ? holdMobile : holdDesktop}\n      onEnd={mobile ? null : holdEndDesktop} >\n      <InlinableIconButton disableRipple disableFocusRipple onClick={onMuteChange} >\n        <div style={SliderStyles}>\n          <Slider\n            defaultValue={100}\n            orientation=\"vertical\"\n            aria-labelledby=\"vertical-slider\"\n            onChange={commitVolume}\n            ref={sliderRef}\n          />\n        </div>\n        <div style={IconStyles}>\n          { muted ?  <VolumeOffIcon fontSize=\"small\" />\n          : sliderValue < 10 ? <VolumeMuteIcon fontSize=\"small\" />\n          : sliderValue < 50 ? <VolumeDownIcon fontSize=\"small\" />\n                             : <VolumeUpIcon fontSize=\"small\"/> }\n        </div>\n      </InlinableIconButton>\n    </ClickNHold>\n  );\n}\n\nclass RawInstrumentEditDialog extends React.Component\n{\n  constructor(props) {\n    super(props);\n    this.state = {\n      currentSymbol : null\n    };\n  }\n\n  render() {\n\n    const cancel = (e) => {\n      this.setState({\"currentSymbol\" : null});\n      if(this.props.onCancel){\n        this.props.onCancel();\n      }\n    };\n\n    const confirm = (e) => {\n      if(this.state.currentSymbol !== null && this.state.currentSymbol.length === 1)\n      {\n        if(this.props.onChange){\n          this.props.onChange(this.state.currentSymbol);\n        }\n      }\n      else\n      {\n        // todo: prettier error communication?\n        alert(\n          \"You selected an invalid symbol \\\"\" + this.state.currentSymbol + \"\\\".\\n\" +\n          \"Symbols must be precisely 1 character.\"\n        );\n      }\n    };\n\n    const handleEnter = (e) =>\n    {\n      if(e.keyCode === 13)\n      {\n        e.preventDefault();\n        confirm();\n      }\n    };\n\n    return (\n      <Dialog open={this.props.open} onClose={cancel} aria-labelledby=\"form-dialog-title\">\n        <DialogTitle id=\"form-dialog-title\"></DialogTitle>\n        <DialogContent>\n          <DialogContentText>\n            Enter notation symbol\n          </DialogContentText>\n          <TextField\n            autoFocus\n            margin=\"dense\"\n            id=\"name\"\n            fullWidth\n            value={this.state.currentSymbol ?? this.props.value}\n            onChange={(e)=>{this.setState({currentSymbol: e.target.value});}}\n            onKeyDown={handleEnter}\n          />\n        </DialogContent>\n        <DialogActions>\n          <Button onClick={cancel} color=\"primary\">\n            Cancel\n          </Button>\n          <Button onClick={confirm} color=\"primary\">\n            Confirm\n          </Button>\n        </DialogActions>\n      </Dialog>\n    );\n  }\n}\n\nclass InstrumentRenameDialog extends React.Component\n{\n  constructor(props)\n  {\n    super(props)\n    this.state = {\n      currentName : null\n    };\n  }\n\n  render()\n  {\n\n    const cancel = () => {\n      if(this.props.onCancel)\n      {\n        this.props.onCancel();\n      }\n      this.setState({currentName: null});\n    };\n\n    const confirm = () => {\n      if(this.state.currentName !== null)\n      {\n        const instrumentName = this.state.currentName.trim();\n        if( instrumentName.length > 0 )\n        {\n          if(this.props.onChange)\n          {\n            this.props.onChange(this.state.currentName);\n          }\n          this.setState({currentName: null});\n        }\n        else\n        {\n          // todo: prettier error communication?\n          alert(\n            \"You selected an invalid instrument name \\\"\" + this.state.currentName + \"\\\".\\n\" +\n            \"Must be non-empty.\"\n          );\n        }\n      }\n      else\n      {\n        cancel();\n      }\n    };\n\n    const handleEnter = (e) =>\n    {\n      if(e.keyCode === 13)\n      {\n        e.preventDefault();\n        confirm();\n      }\n    };\n\n    return (\n      <Dialog open={this.props.open} onClose={cancel} aria-labelledby=\"form-dialog-title\">\n        <DialogTitle id=\"form-dialog-title\"></DialogTitle>\n        <DialogContent>\n          <DialogContentText>\n            Enter instrument name\n          </DialogContentText>\n          <TextField\n            margin=\"dense\"\n            id=\"name\"\n            fullWidth\n            value={this.state.currentName ?? this.props.value}\n            onChange={(e)=>{this.setState({currentName: e.target.value});}}\n            onKeyDown={handleEnter}\n            autoFocus\n          />\n        </DialogContent>\n        <DialogActions>\n          <Button onClick={cancel} color=\"primary\">\n            Cancel\n          </Button>\n          <Button onClick={confirm} color=\"primary\">\n            Confirm\n          </Button>\n        </DialogActions>\n      </Dialog>\n    );\n  }\n};\n\nfunction InstrumentTable(props)\n{\n  const classes = useStyles();\n\n  const editRow = (y)=>{ if( props.onEditRow ){ props.onEditRow(y); }};\n  const editColumn = (x)=>{ if( props.onEditColumn ){ props.onEditColumn(x); }};\n  const addRow = ()=>{ if( props.onAddRow ){ props.onAddRow(); }};\n  const removeRow = (y)=>{ if( props.onRemoveRow ){ props.onRemoveRow(y); }};\n\n  const handleChange = (x,y, event) => {\n    const instrumentID = props.instrumentIndex[x].id;\n    const oldInstrumentIndex = props.instruments.findIndex( instrument => instrumentID in instrument[1]);\n    const dstInstrumentIndex = y;\n    if( oldInstrumentIndex === dstInstrumentIndex )\n    {\n      return;\n    }\n    const oldInstrument = props.instruments[oldInstrumentIndex];\n    let replacedSrcInstrument = [\n      \"\",\n      {}\n    ];\n    if( oldInstrument != null )\n    {\n      replacedSrcInstrument[0] = oldInstrument[0];\n      for( const key of Object.keys(oldInstrument[1]) )\n      {\n        if( key !== instrumentID.toString() )\n        {\n          replacedSrcInstrument[1][key] = oldInstrument[1][key];\n        }\n      }\n    }\n    let dstInstrument = [\n      props.instruments[dstInstrumentIndex][0],\n      Object.assign({}, props.instruments[dstInstrumentIndex][1] )\n    ];\n    if(oldInstrument != null )\n    {\n      dstInstrument[1][instrumentID.toString()] = oldInstrument[1][instrumentID];\n    }\n    else\n    {\n      dstInstrument[1][instrumentID.toString()] = \"X\";\n    }\n\n    let replacedInstruments = [];\n\n    for(let instrumentIndex = 0; instrumentIndex < props.instruments.length; ++instrumentIndex)\n    {\n      if( instrumentIndex === oldInstrumentIndex )\n      {\n        replacedInstruments.push( replacedSrcInstrument );\n      }\n      else if( instrumentIndex === dstInstrumentIndex )\n      {\n        replacedInstruments.push( dstInstrument )\n      }\n      else\n      {\n        replacedInstruments.push( props.instruments[instrumentIndex] );\n      }\n    }\n    props.onChange(replacedInstruments);\n  };\n\n  const createCell = (x,y) =>\n  {\n      return (\n        <TableCell\n          align=\"center\"\n          key={\"instrumentPanel-cell-\" + y.toString() + \"-\" + x.toString()}\n        >\n        <ThinFormControlLabel\n          control={<Checkbox checked={props.instrumentMask[x] === y} onChange={(e) =>{handleChange(x,y,e);}} name={x + \",\" + y.toString()} />}\n        />\n        </TableCell>\n      );\n  }\n\n  const createMatchingRow = (y) =>\n  {\n    return (\n      <TableRow key={\"instrumentPanel-row-\" + y.toString()}>\n        <TableCell component=\"th\" scope=\"row\" key={\"instrumentPanel-row-\" + y.toString() + \"-name\"}>\n          <Typography>{props.instruments[y][0]}</Typography>\n          <InlinableIconButton onClick={(e)=>{editRow(y);}}><EditIcon fontSize=\"small\"/></InlinableIconButton>\n          <InlinableIconButton onClick={(e)=>{removeRow(y);}}><ClearIcon fontSize=\"small\"/></InlinableIconButton>\n        </TableCell>\n        {[...Array(props.instrumentMask.length).keys()].map(x=>createCell(x,y))}\n      </TableRow>\n    );\n  };\n\n  const createEditRow = () =>\n  {\n    return (\n      <TableRow key={\"instrumentPanel-row-edit\"}>\n        <TableCell component=\"th\" scope=\"row\" key={\"instrumentPanel-row-edit-cell\"}>\n          <IconButton onClick={(e)=>{addRow();}} aria-label=\"add\">\n            <AddBoxIcon/>\n          </IconButton>\n        </TableCell>\n      </TableRow>\n    );\n  };\n\n  return (\n    <Table className={classes.table} aria-label=\"simple table\">\n      <TableHead>\n        <TableRow key={\"instrumentPanel-row-header\"}>\n          <NoDividerCenterTableCell key={\"instrumentPanel-row-instrument\"}> Instrument </NoDividerCenterTableCell>\n          {[...Array(props.instrumentIndex.length).keys()].map(x=>\n              <NoDividerCenterTableCell key={\"instrumentPanel-row-header-cell-\" + x.toString()}>\n                <Typography>{props.instrumentIndex[x].name}</Typography>\n              </NoDividerCenterTableCell>)}\n        </TableRow>\n        <TableRow key={\"instrumentPanel-row-controls\"}>\n          <TableCell key={\"instrumentPanel-row-instrument\"}></TableCell>\n          {[...Array(props.instrumentIndex.length).keys()].map(x=>\n              <CenterTableCell key={\"instrumentPanel-row-controls-cell-\" + x.toString()}>\n                <Grid container>\n                <Grid item xs={6}>\n                <InlinableIconButton onClick={(e)=>{editColumn(x);}}>\n                  <EditIcon fontSize=\"small\"/>\n                </InlinableIconButton>\n                </Grid>\n                <Grid item xs={6}>\n                  <VolumeWidget\n                    muted={props.instrumentIndex[x].muted}\n                    onChange={(value)=>{props.onVolumeEvent( {instrument: x, volume: value / 100.0}); }}\n                    onMuteEvent={(muted)=>{props.onVolumeEvent( {instrument: x, muted: muted})}}\n                    />\n                </Grid>\n                </Grid>\n              </CenterTableCell>)}\n        </TableRow>\n      </TableHead>\n      <TableBody>\n        {[...Array(props.instruments.length).keys()].map(y=>createMatchingRow(y))}\n        {createEditRow()}\n      </TableBody>\n    </Table>\n  );\n}\n\nfunction InstrumentConfig(props) {\n  const [editingSymbol, setEditingSymbol] = React.useState(null);\n  const [renamingInstrument, setRenamingInstrument] = React.useState(null);\n\n  const removeInstrument = (y) =>\n  {\n    let replacedInstruments = props.instruments.slice(0,y).concat(props.instruments.slice(y+1));\n    props.onChange(replacedInstruments);\n  };\n\n  const getSymbol = (x) => {\n    const instrumentID = props.instrumentIndex[editingSymbol].id;\n    const instrumentIndex = props.instruments.findIndex( instrument => instrumentID in instrument[1]);\n    return props.instruments[instrumentIndex][1][instrumentID];\n  };\n\n  const endEditingSymbol = (resolvedSymbol) =>\n  {\n    if(resolvedSymbol !== null)\n    {\n      const instrumentID = props.instrumentIndex[editingSymbol].id;\n      const instrumentIndex = props.instruments.findIndex( instrument => instrumentID in instrument[1]);\n      let replacedInstruments = Array.from(props.instruments);\n      replacedInstruments[instrumentIndex][1][instrumentID] = resolvedSymbol;\n      props.onChange(replacedInstruments);\n    }\n    setEditingSymbol( null );\n  };\n\n  const getName = (y) => {\n    return y < props.instruments.length ? props.instruments[y][0] : \"\";\n  };\n\n  const renameInstrument = (instrumentName)  =>\n  {\n    // this function also deals with the addition of new instruments\n    if( renamingInstrument === props.instruments.length )\n    {\n      const extraInstrument = [ instrumentName, {} ];\n      let replacedInstruments = Array.from( props.instruments );\n      replacedInstruments.push(extraInstrument);\n      props.onChange(replacedInstruments);\n    }\n    else\n    {\n      let replacedInstruments = Array.from( props.instruments );\n      replacedInstruments[renamingInstrument][0] = instrumentName;\n      props.onChange(replacedInstruments);\n    }\n    setRenamingInstrument(null);\n  };\n\n  const containerStyle = {\n    \"border\": \"2px solid rgba(255, 255, 255, 0.5)\",\n    \"outline\": \"none\",\n    \"borderRadius\": \"8px\"\n  };\n  return (\n    <div style={{\"paddingBottom\" : \"5px\"}}>\n      <InstrumentRenameDialog\n        open={renamingInstrument !== null}\n        onCancel={()=>{setRenamingInstrument(null);}}\n        onChange={(s)=>{renameInstrument(s);}}\n        value={renamingInstrument !== null ? getName(renamingInstrument) : \"\"}\n      />\n      <RawInstrumentEditDialog\n        open={editingSymbol !== null}\n        onCancel={()=>{endEditingSymbol(null);}}\n        onChange={(s)=>{endEditingSymbol(s);}}\n        value={editingSymbol !== null ? getSymbol(editingSymbol) : \"\"}\n        />\n      <TableContainer style={containerStyle}>\n        <InstrumentTable\n          instrumentIndex={props.instrumentIndex}\n          instrumentMask={props.instrumentMask}\n          instruments={props.instruments}\n          onEditColumn={(x)=>{setEditingSymbol(x);}}\n          onEditRow={(y)=>{setRenamingInstrument(y);}}\n          onAddRow={()=>{setRenamingInstrument(props.instruments.length)}}\n          onRemoveRow={(y)=>{removeInstrument(y);}}\n          onVolumeEvent={props.onVolumeEvent}\n          onChange={props.onChange}\n        />\n      </TableContainer>\n    </div>\n  );\n}\n\nfunction createInstrumentMask(instrumentIndex, instruments)\n{\n  let instrumentMask = Array(instrumentIndex.length);\n  for( let baseInstrumentIndex = 0; baseInstrumentIndex < instrumentIndex.length; ++baseInstrumentIndex )\n  {\n    const baseInstrumentId = instrumentIndex[baseInstrumentIndex].id;\n    for( let targetInstrumentIndex = 0; targetInstrumentIndex < instruments.length; ++targetInstrumentIndex)\n    {\n      const target = instruments[targetInstrumentIndex];\n      if(baseInstrumentId.toString() in target[1])\n      {\n        instrumentMask[baseInstrumentIndex] = targetInstrumentIndex;\n      }\n    }\n  }\n  return instrumentMask;\n}\n\nexport { createInstrumentMask, InstrumentConfig };"],"sourceRoot":""}