{"version":3,"sources":["App.js","formatSettings.js","FileImport.js","h2.js","Part.js","PartWithTitle.js","Pattern.js","Audio.js","ToneBoard.js","Routes.js","serviceWorker.js","index.js","notation.js","instrumentation.js","instrumentConfig.js","track.js","utilities.js"],"names":["theme","createMuiTheme","palette","type","primary","main","secondary","ignoreEvent","event","key","getJsonStorageUrl","slug","getJsonDestinationUrl","modalStyles","modal","display","alignItems","justifyContent","paper","backgroundColor","background","border","boxShadow","shadows","padding","spacing","App","props","state","instruments","instrumentIndex","instrumentMask","patterns","formatSettings","Object","assign","DefaultSettings","patternSettings","loadedFile","selectedPattern","settingsOpen","patternsOpen","progress","showSharingDialog","showTitleOptions","undefined","match","params","song","permanentUrl","pattern","React","createRef","this","fetch","then","response","json","js","decodedState","decodeState","hash","Error","handleJson","catch","e","setState","alert","destFilename","fileParts","split","length","slice","join","JSON","stringify","getExportState","blob","Blob","saveAs","zlib","deflateSync","toString","binaryBuffer","Buffer","decompressedString","inflateSync","parse","stateToShare","encodeState","stateHash","uploadUrl","metadata","method","headers","body","window","origin","err","Array","from","p","notation","guessPerPatternSettings","instrumentTracks","title","prevState","createInstrumentMask","patternData","replacedTracks","entries","id","trackData","track","rep","resolution","patternWithTracks","push","createTracks","file","name","includes","h2","parseHydrogenPromise","content","h","assessedInstruments","figureInstruments","DEFAULT_INSTRUMENT_SYMBOLS","activeInstrumentation","figurePatternSettings","error","Promise","resolve","patternIndex","resolvedSettings","Fragment","tracks","config","active","ref","onPatternTimeChange","time","current","k","createObjects","kuva","userAgent","navigator","vendor","opera","some","toMatchItem","trackLength","t","Math","max","min","optionalAlert","severity","controls","variant","onClick","loadExample","bind","style","margin","onImport","handleFileImport","accept","waitingMessage","position","bottom","href","iOS","mobile","classes","handlePatternsClose","disableBackdropTransition","disableDiscovery","className","drawer","open","onOpen","onClose","drawerHeader","drawerContainer","map","index","button","selectPattern","patternConfig","handleDrawerClose","patternToRender","patternDetails","getTrackLength","anchor","drawerPaper","onChange","existingPatternSettings","existingGlobalSettings","v","settings","color","default","save","share","aria-labelledby","aria-describedby","copy","renderTitlePage","patternContent","renderPattern","process","browser","test","checkMobile","instrumentConfigColumns","renderSharingDialog","width","aria-label","edge","clsx","hide","flexGrow","container","item","xs","renderPatternDrawer","renderSettingsDrawer","mainContent","renderMainContent","Component","withStyles","withRouter","useStyles","makeStyles","formControl","minWidth","camelToReadable","s","spacedString","replace","toUpperCase","FormatSettings","useTheme","tokenStateToItem","value","tokenItemToState","handleOptionChange","updatedState","handleCheckedChange","target","checked","createOptionMenu","options","itemToState","stateToItem","idString","labelId","op","lineLengths","beatResolution","sort","beatResolutions","c","lineResolution","root","FORMAT_CONFIG_STRINGS","reduce","prev","curr","FORMAT_CONFIG_BOOLS","control","label","parseInt","b","r","DEFAULT_FORMAT_CONFIG","FileImport","hiddenFileInput","fileObject","files","reader","FileReader","onload","loadEvent","result","readAsText","buttonProps","click","hidden","calculatePatternResolution","size","positions","notes","note","calculateResolution","parseHydrogenJs","instrumentElements","instrumentList","instrument","instrumentArray","element","instrumentComponent","inst","parseFloat","volume","isMuted","gain","drumkit","layer","filename","patternElements","patternList","patternArray","noteElements","noteList","patternSize","noteElement","filter","n","patternsWithTracks","relevantNotes","relevantHits","fromPositions","virtualPatternList","virtualPatternGroups","patternToRelated","virtualGroup","rootPatternName","relatedPatterns","virtual","Set","iteration","expandedObject","objectHasExpanded","related","expandedNodeSet","node","relatedPatternSet","rootPattern","find","patternToMergeName","patternToMerge","merged","aggregate","copiedTrack","format","xmlString","a","parser","xml2js","Parser","parseStringPromise","Part","values","formatPatternString","restMark","patternResolution","patternLines","chunkArray","beatsPerLine","beatChunkSize","linesWithBeats","line","lineIndices","keys","formatLine","startBeat","beats","lineMark","beat","activeNote","showBeatMark","beatMark","numberLine","createNumberMarker","numberRestMark","beatChunks","showBeatNumbers","lineIndex","whiteSpace","PartWithTitle","Title","headingLevel","defaultLevel","safeHeading","toLowerCase","getTitleType","instrumentName","Pattern","patternTime","instrumentIndices","floor","fontFamily","textAlign","Audio","AudioContext","webkitAudioContext","minResolution","empty","combined","peakValue","channel","numberOfChannels","combinedChannel","getChannelData","sample","abs","peakAmplitude","context","sounds","tempo","determineTrackLength","trackLengthSamples","totalSamples","samplesPerHydrogen","createBuffer","selected","audioBuffer","audioChannel","trackPoints","toPoints","sampleStart","normalizeAudioBuffer","buffer","source","createBufferSource","loop","playbackRate","connect","destination","DRUMKITS","ToneBoard","samplerCount","sequences","Tone","toDestination","bpm","drumkitName","expectedSamplerCount","mapping","selectedInstrument","relativeUrl","chooseAppropriateUrlForInstrument","samples","determineMinResolution","patternLength","tick","_part","mute","start","now","toSeconds","timeFromBarEnd","loopEnd","queueTransition","enableNewTrack","setLoopPoints","scheduleOnce","sampleCount","expectedSampleCount","indexFromStart","lastTickTime","trackLengthRes","samplesReady","schedule","notePosition","stop","populateSamples","createSequences","schedulePlaybackForNewTracks","prevProps","snapshot","Slider","defaultValue","step","valueLabelDisplay","IconButton","play","Grid","tempoControl","Routes","basename","path","Boolean","location","hostname","ReactDOM","render","StrictMode","document","getElementById","serviceWorker","ready","registration","unregister","console","message","formatConfig","propName","hasOwnProperty","str","chunkSize","RegExp","chunks","i","lineLength","beatCount","ceil","numberMarkerArray","asHTML","validateConfig","formatSymbol","symbol","numericPosition","formattedLine","charAt","lineWithBeats","chunkString","trackDict","defaultLineResolution","fill","charIndex","trackID","trackSymbol","trackInstance","resolveConfig","patternString","lineArray","formattedLineArray","formatLineWithMarkers","normalizeInstrumentsForFiguring","nInst","manageAccentOrGhost","accentSymbol","ghostSymbol","outputInstruments","t0","t1","zeroLouder","activeInstruments","nonTrivialInstruments","instrumentID","add","has","defaultSymbolForSingleInstrument","symbolConfig","lowerName","instrumentsRaw","output","concat","worthwhileInstruments","relevantTracks","trackIsClick","tomIndex","bassIndex","collated","candidate","clickTrack","hitTrack","instrumentIsTom","rawInstrumentName","lastTrack","figureClickyInstruments","djembeTracks","slapArray","toneArray","bassArray","djembeMapping","figureDjembes","figureSnares","figureShakers","instrumentUsed","ThinFormControlLabel","marginLeft","marginRight","FormControlLabel","InlinableIconButton","CenterTableCell","TableCell","InstrumentConfig","useState","renamingInstrument","setRenamingInstrument","nameState","setNameState","createCell","x","y","align","oldInstrumentIndex","findIndex","dstInstrumentIndex","oldInstrument","replacedSrcInstrument","dstInstrument","replacedInstruments","handleChange","createMatchingRow","component","scope","fontSize","removeInstrument","editSymbol","setEditSymbol","editSymbolState","setEditSymbolState","autoFocus","fullWidth","trim","extraInstrument","updatedSymbol","table","currentSymbol","startEditingSymbol","baseInstrumentIndex","baseInstrumentId","targetInstrumentIndex","findHCF","count","other","_sumOverlapsOfArrays","hcf","formatResolution","pat","totalLength","points","representPoints","arrayIndex","resolutionToUse","implicitPositions","allNotesPass"],"mappings":"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","file":"static/js/main.35debc19.chunk.js","sourcesContent":["import React from 'react';\nimport clsx from 'clsx';\nimport FileImport from \"./FileImport\";\nimport Pattern from \"./Pattern\";\nimport h2 from './h2';\nimport './App.css';\n\nimport { Alert } from '@material-ui/lab';\nimport CircularProgress from '@material-ui/core/CircularProgress';\n\n// define mui theme, including responsiveFont\nimport { createMuiTheme, ThemeProvider } from '@material-ui/core/styles';\n\n// drawer\nimport SwipeableDrawer from '@material-ui/core/SwipeableDrawer';\nimport CssBaseline from '@material-ui/core/CssBaseline';\nimport List from '@material-ui/core/List';\nimport ListItem from '@material-ui/core/ListItem';\nimport ListItemText from '@material-ui/core/ListItemText';\n\nimport IconButton from '@material-ui/core/IconButton';\nimport Button from '@material-ui/core/Button';\nimport MenuIcon from '@material-ui/icons/Menu';\nimport ChevronLeftIcon from \"@material-ui/icons/ChevronLeft\";\nimport ChevronRightIcon from \"@material-ui/icons/ChevronRight\";\nimport Divider from \"@material-ui/core/Divider\";\nimport Dialog from '@material-ui/core/Dialog';\nimport DialogActions from '@material-ui/core/DialogActions';\nimport DialogContent from '@material-ui/core/DialogContent';\nimport DialogContentText from '@material-ui/core/DialogContentText';\nimport { withStyles } from '@material-ui/core/styles';\nimport FileCopyIcon from '@material-ui/icons/FileCopy';\n\n// notationSettings\n\nimport {FormatSettings, DefaultSettings} from \"./formatSettings\";\nimport {createInstrumentMask, InstrumentConfig} from \"./instrumentConfig\";\nimport { activeInstrumentation, figureInstruments, DEFAULT_INSTRUMENT_SYMBOLS } from \"./instrumentation\";\nimport notation from \"./notation\";\n\nimport Grid from '@material-ui/core/Grid';\n\n// load static data\nimport kuva from \"./kuva.json\";\nimport track from \"./track\";\n\nimport { saveAs } from 'file-saver';\n\nimport ToneBoard from \"./ToneBoard\";\nimport { withRouter } from \"react-router-dom\";\n\nimport hash from \"object-hash\";\nimport zlib from \"zlib\";\nimport copy from \"copy-to-clipboard\";\n\n// mui theme config\nlet theme = createMuiTheme( { \n  palette: { \n    type: 'dark',\n    primary: { main: '#36d9be' },\n    secondary: { main: '#f50057' }\n   } \n} );\n\nconst ignoreEvent = (event) => {\n  return event && event.type === 'keydown' && (event.key === 'Tab' || event.key === 'Shift');\n};\n\nconst getJsonDestinationUrl = (slug) => {\n  const jsonbase_url = \"https://jsonbase.com/tabit-song/\" + slug;\n  return jsonbase_url;\n}\n\nconst getJsonStorageUrl = (slug) => {\n  // jsonbase doesn't give cross-origin headers, \n  // so we use cors-anywhere to add them\n\n  // this is obviously a hack, but it enables us to use jsonbase\n  // as a transitive (semi-permanent) database, on a static site!\n  const cors_url = \"https://cors-anywhere.herokuapp.com/\";\n  return cors_url + getJsonDestinationUrl(slug);\n}\n\nconst modalStyles = {\n  modal: {\n    display: 'flex',\n    alignItems: 'center',\n    justifyContent: 'center',\n  },\n  paper: {\n    backgroundColor: theme.palette.background.paper,\n    border: '2px solid #000',\n    boxShadow: theme.shadows[5],\n    padding: theme.spacing(2, 4, 3),\n  },\n};\n\nclass App extends React.Component\n{\n  constructor(props) {\n    super(props);\n    this.state = {\n      // data\n      instruments : null,\n      instrumentIndex : null,\n      instrumentMask : null,\n      patterns : null,\n      formatSettings : Object.assign({}, DefaultSettings),\n      patternSettings : [],\n      // ui state\n      loadedFile : null,\n      selectedPattern : null,\n      settingsOpen : false,\n      patternsOpen : false,\n      progress : null,\n      showSharingDialog : false,\n      showTitleOptions : this.props.match.params.song === undefined,\n      permanentUrl : \"\"\n    };\n    this.pattern = React.createRef();\n  }\n\n  componentDidMount()\n  {\n    if( this.props.match.params.song )\n    {\n      fetch(getJsonStorageUrl(this.props.match.params.song))\n      .then( response => { return response.json(); } )\n      .then( js => {\n        const decodedState = this.decodeState(js);\n        const stateHash = hash(js);\n        if( stateHash !== this.props.match.params.song )\n        {\n          throw new Error(\"Hash did not match\");\n        }\n        this.handleJson(null, decodedState);\n      }).catch( (e) => {\n        this.setState({showTitleOptions : true});\n        alert(\"Song \" + this.props.match.params.song + \" could not be found.\" );\n      } );\n    }\n  }\n\n  getExportState()\n  {\n    return {\n      instruments : this.state.instruments,\n      instrumentIndex : this.state.instrumentIndex,\n      patterns : this.state.patterns,\n      formatSettings: this.state.formatSettings,\n      patternSettings : this.state.patternSettings\n    }\n  }\n\n  save()\n  {\n    let destFilename = \"download.tabit\";\n    if(this.state.loadedFile)\n    {\n      const fileParts = this.state.loadedFile.split(\".\");\n      if( fileParts.length === 1 )\n      {\n        destFilename = fileParts[0] + \".tabit\";\n      }\n      else\n      {\n        destFilename = fileParts.slice(0, fileParts.length - 1).join(\".\") + \".tabit\";\n      }\n    }\n\n    const js = JSON.stringify(this.getExportState(), null, 4);\n    const blob = new Blob([js], {type: \"application/json\"});\n    saveAs(blob, destFilename);\n  }\n\n  encodeState(state)\n  {\n    // json\n    const js = JSON.stringify(this.getExportState());\n    // compress\n    const compressedState = zlib.deflateSync(js).toString(\"base64\");\n    return { state : compressedState };\n  }\n\n  decodeState(state)\n  {\n    const binaryBuffer = new Buffer(state.state, \"base64\");\n    const decompressedString = zlib.inflateSync(binaryBuffer);\n    return JSON.parse(decompressedString);\n  }\n\n  share()\n  {\n    const stateToShare = this.encodeState(this.getExportState());\n    const stateHash = hash(stateToShare);\n    const uploadUrl = getJsonStorageUrl(stateHash);\n\n    const metadata = {\n      method: \"PUT\",\n      headers: { 'Content-Type': 'application/json' },\n      body: JSON.stringify(stateToShare)\n    };\n\n    const permanentUrl = window.origin + process.env.PUBLIC_URL + \"/song/\" + stateHash;\n    fetch(uploadUrl, metadata).then(\n      e => {\n        this.setState({permanentUrl : permanentUrl, showSharingDialog: true})\n      }\n    ).catch(err => { alert(\"Couldn't upload song at this time. Sorry for any inconvenience.\"); });\n  }\n\n  figurePatternSettings(patterns)\n  {\n    return Array.from(\n      patterns,\n      (p) => notation.guessPerPatternSettings( p.instrumentTracks )\n    );\n  }\n\n\n  handleJson(title, prevState)\n  {\n    const createTracks = (patternData) =>\n    {\n      // the instruments currently work as simple objects\n      // we need to create tracks!\n      let patterns = [];\n      for( let pattern of patternData )\n      {\n        let replacedTracks = {};\n        // todo: find a more compact way of doing this\n        for( const [id, trackData] of Object.entries(pattern.instrumentTracks) )\n        {\n          replacedTracks[id] = new track( trackData.rep, trackData.resolution );\n        }\n        let patternWithTracks = Object.assign({}, pattern);\n        patternWithTracks.instrumentTracks = replacedTracks;\n        patterns.push(patternWithTracks);\n      }\n      return patterns;\n    }\n    this.setState( {\n      instrumentIndex : prevState.instrumentIndex,\n      instrumentMask : createInstrumentMask(prevState.instrumentIndex, prevState.instruments),\n      instruments : prevState.instruments,\n      patterns : createTracks(prevState.patterns),\n      formatSettings : prevState.formatSettings,\n      patternSettings : prevState.patternSettings,\n      // general app state\n      loadedFile : title ?? prevState.loadedFile,\n      selectedPattern : prevState.patterns.length === 0 ? null : 0,\n      patternsOpen : prevState.patterns.length !== 0\n    } );\n  }\n\n  handleFileImport(e)\n  {\n    if( e.file.name.includes(\"h2song\") )\n    {\n      // e = { file : , content : }\n      h2.parseHydrogenPromise(e.content).then(h => {\n        const assessedInstruments = figureInstruments(h.instruments, DEFAULT_INSTRUMENT_SYMBOLS, h.patterns);\n        const instrumentIndex = activeInstrumentation(h.instruments, h.patterns);\n        this.setState({\n          // data\n          instrumentIndex : instrumentIndex,\n          instrumentMask : createInstrumentMask(instrumentIndex, assessedInstruments),\n          instruments : assessedInstruments,\n          patterns : h.patterns,\n          patternSettings : this.figurePatternSettings(h.patterns),\n          // general app state\n          loadedFile : e.file.name,\n          patternsOpen : true,\n          selectedPattern : h.patterns.length === 0 ? null : 0,\n        });\n      }).catch( (error)=>{ alert(\"Failed to load file \" + e.file.name  + \" with error \" + error); } );\n    }\n    else\n    {\n\n      // assume it's a tabit file!\n      Promise.resolve(e.content)\n        .then(JSON.parse)\n        .then( prevState => { this.handleJson(e.file.name,prevState); } )\n        .catch( (error)=>{ alert(\"Failed to load file \" + e.file.name  + \" with error \" + error); } );\n    }\n  }\n\n  selectPattern(patternIndex)\n  {\n    this.setState( { selectedPattern: patternIndex } );\n  }\n\n  // todo: this is a separate component!\n  renderPattern(pattern, resolvedSettings)\n  {\n    return (\n      <React.Fragment>\n        <Pattern \n          instruments={this.state.instruments} \n          tracks={pattern.instrumentTracks}\n          config={resolvedSettings}\n          active={this.state.progress}\n          ref={this.pattern}\n        />\n        <ToneBoard \n          instruments={this.state.instruments} \n          instrumentIndex={this.state.instrumentIndex} \n          selectedPattern={pattern}\n          patterns={this.state.patterns}\n          onPatternTimeChange = {(time)=>{this.onPatternTimeChange(time);}}\n        />\n      </React.Fragment>\n    );\n  }\n\n  onPatternTimeChange(time)\n  {\n    this.pattern.current.onPatternTimeChange(time);\n  }\n\n  loadExample()\n  {\n    const createObjects = (state) => \n    {\n      // the instruments currently work as simple objects\n      // we need to create tracks!\n      for( let pattern of state.patterns )\n      {\n        let replacedTracks = {};\n        // todo: find a more compact way of doing this\n        for( const [id, trackData] of Object.entries(pattern.instrumentTracks) )\n        {\n          replacedTracks[id] = new track( trackData.rep, trackData.resolution );\n        }\n        pattern.instrumentTracks = replacedTracks;\n      }\n      return state;\n    }\n    const k = createObjects(kuva);\n    const assessedInstruments = figureInstruments(k.instruments, DEFAULT_INSTRUMENT_SYMBOLS, k.patterns);\n    const instrumentIndex = activeInstrumentation(k.instruments, k.patterns);\n    this.setState({\n      instrumentIndex : instrumentIndex,\n      instrumentMask : createInstrumentMask(instrumentIndex, assessedInstruments),\n      instruments : assessedInstruments,\n      patterns : k.patterns,\n      selectedPattern : k.patterns.length === 0 ? null : 0,\n      loadedFile : \"kuva.example\",\n      patternsOpen : true,\n      patternSettings : this.figurePatternSettings(k.patterns)\n    });\n  }\n\n  checkMobile()\n  {\n    // the simple version from\n    // https://stackoverflow.com/questions/11381673/detecting-a-mobile-browser\n    const userAgent = (navigator.userAgent||navigator.vendor||window.opera);\n    const toMatch = [\n        /Android/i,\n        /webOS/i,\n        /iPhone/i,\n        /iPad/i,\n        /iPod/i,\n        /BlackBerry/i,\n        /Windows Phone/i\n    ];\n\n    return toMatch.some((toMatchItem) => {\n        return userAgent.match(toMatchItem);\n    });\n  }\n\n\n  getTrackLength(pattern)\n  {\n    let trackLength = 48;\n    for(const [,t] of Object.entries(pattern.instrumentTracks))\n    {\n        trackLength = Math.max( trackLength, t.length() );\n    }\n    return trackLength;\n  }\n\n  getResolution(pattern)\n  {\n    let resolution = 48;\n    for(const [,t] of Object.entries(pattern.instrumentTracks))\n    {\n        resolution = Math.min( resolution, t.resolution );\n    }\n    return resolution;\n  }\n\n  renderTitlePage()\n  {\n    const showAlert = this.state.patterns != null && this.state.patterns.length === 0;\n    const optionalAlert = showAlert ? ( <Alert severity=\"error\">{this.state.loadedFile} contained no patterns! Try another.</Alert> )\n                                    : \"\";\n    // if a load of a song is in flight don't show file open buttons\n    const controls = (\n      <React.Fragment>\n        <Button variant=\"contained\" onClick={this.loadExample.bind(this)} style={{margin: \"1em\"}}>Load example</Button>\n        <FileImport\n          style={{margin: \"1em\"}}\n          variant=\"contained\"\n          onImport={this.handleFileImport.bind(this)}\n          accept=\".tabit,.h2song\"\n          />\n          {optionalAlert}\n      </React.Fragment>\n    );\n    const waitingMessage = (<React.Fragment>\n        <p> Loading song... </p>\n        <CircularProgress />\n      </React.Fragment>\n    );\n    return (\n      <React.Fragment>\n      <div>\n        <h2>tabit</h2>\n        <p>I read .h2songs and write tab</p>\n        {this.state.showTitleOptions ? controls : waitingMessage}\n      </div>\n      <div style={{ position:\"absolute\", bottom:0 }} >\n        <p>tabit relies on publicly available sound libraries listed at <a href=\"https://github.com/andrew-murray/tabit\">https://github.com/andrew-murray/tabit</a></p>\n      </div>\n      </React.Fragment>\n    );\n  }\n\n  renderPatternDrawer(iOS, mobile)\n  {\n    const classes = this.props;\n    const handlePatternsClose = (e) => {\n      if( ignoreEvent(e) ){ return; }\n      this.setState( { patternsOpen : false } );\n    };\n    const handlePatternsOpen = (e) => {\n      if( ignoreEvent(e) ){ return; }\n      this.setState( { patternsOpen : true } );\n    };\n\n    return (\n      <SwipeableDrawer disableBackdropTransition={!iOS} disableDiscovery={iOS}\n      className={classes.drawer}\n      variant={ mobile ? undefined : \"persistent\" }\n      open={this.state.patternsOpen}\n      onOpen={handlePatternsOpen}\n      onClose={handlePatternsClose}\n      >\n        <div className={classes.drawerHeader}>\n          <IconButton onClick={handlePatternsClose}>\n              <ChevronLeftIcon />\n          </IconButton>\n        </div>\n        <Divider />\n        <div className={classes.drawerContainer}>\n          <List>\n            {(this.state.patterns ?? []).map( (pattern, index) => (\n              <ListItem button key={\"drawer-pattern\" + index.toString()} onClick={() => this.selectPattern(index)}>\n                  <ListItemText primary={pattern.name} />\n              </ListItem>\n            ))}\n          </List>\n        </div>\n      </SwipeableDrawer>\n    );\n  }\n\n\n\n  renderSettingsDrawer(iOS, mobile, patternConfig)\n  {\n    const classes = this.props;\n    const settingsChangeCallback = (config) => {\n      let existingPatternSettings = Array.from( this.state.patternSettings );\n      let existingGlobalSettings = Object.assign( {}, this.state.formatSettings );\n      for( let [k,v] of Object.entries(config) )\n      {\n        if( k in existingPatternSettings[this.state.selectedPattern] )\n        {\n          existingPatternSettings[this.state.selectedPattern][k] = v;\n        }\n        else\n        {\n          existingGlobalSettings[k] = v;\n        }\n      }\n      this.setState( { formatSettings: existingGlobalSettings, patternSettings : existingPatternSettings } );\n    };\n\n    const handleDrawerOpen = (e) => {\n      if( ignoreEvent(e) ){ return; }\n      this.setState( {settingsOpen : true} );\n    };\n\n    const handleDrawerClose = (e) => {\n      if( ignoreEvent(e) ){ return; }\n      this.setState( {settingsOpen : false} );\n    };\n\n    const patternToRender = this.state.patterns[this.state.selectedPattern];\n\n    const patternDetails = {\n      name : patternToRender.name,\n      resolution : patternToRender.resolution,\n      \"length\" : this.getTrackLength(patternToRender)\n    };\n\n    return (\n      <SwipeableDrawer disableBackdropTransition={!iOS} disableDiscovery={iOS}\n        className={classes.drawer}\n        variant={ mobile ? undefined : \"persistent\" }\n        anchor=\"right\"\n        open={this.state.settingsOpen}\n        onOpen={handleDrawerOpen}\n        onClose={handleDrawerClose}\n        classes={{\n          paper: classes.drawerPaper\n        }}\n      >\n        <div className={classes.drawerHeader}>\n          <IconButton onClick={handleDrawerClose}>\n              <ChevronRightIcon />\n          </IconButton>\n        </div>\n        <Divider />\n        <FormatSettings\n          onChange={settingsChangeCallback}\n          settings={patternConfig}\n          pattern={patternDetails}\n          />\n        <Button\n          style={{backgroundColor : \"white\", color : theme.palette.background.default}}\n          onClick={(e) => { this.save(); } }\n        >Download</Button>\n        <Divider />\n        <Button\n          style={{backgroundColor : \"white\", color : theme.palette.background.default}}\n          onClick={(e) => { this.share(); } }\n        >Share</Button>\n      </SwipeableDrawer>\n    );\n  }\n\n  renderSharingDialog()\n  {\n    return (\n      <Dialog\n        open={this.state.showSharingDialog}\n        onClose={(e)=>{this.setState({showSharingDialog: false});}}\n        aria-labelledby=\"alert-dialog-title\"\n        aria-describedby=\"alert-dialog-description\"\n      >\n        <DialogContent>\n          <DialogContentText id=\"alert-dialog-description\">\n          Your song is available at\n          </DialogContentText>\n          <DialogContentText>\n          {this.state.permanentUrl}\n          <IconButton onClick={(e)=>{ copy(this.state.permanentUrl); }}>\n            <FileCopyIcon />\n          </IconButton>\n          </DialogContentText>\n          <DialogActions>\n            <Button onClick={(e)=>{this.setState({showSharingDialog: false})}}>\n              Close\n            </Button>\n          </DialogActions>\n        </DialogContent>\n      </Dialog>\n    );\n  }\n\n  renderMainContent()\n  {\n    if(this.state.patterns == null || this.state.patterns.length === 0)\n    {\n      return this.renderTitlePage();\n    }\n    else\n    {\n      const patternToRender = this.state.patterns[this.state.selectedPattern];\n      const patternConfig = Object.assign(\n        Object.assign({}, this.state.formatSettings), // global settings\n        this.state.patternSettings[this.state.selectedPattern] // then apply per-pattern settings\n      );\n      const patternContent = this.renderPattern(patternToRender, patternConfig);\n       \n\n      const changeInstrumentsCallback = (instruments) => {\n        this.setState( {\n          instruments : instruments,\n          instrumentMask : createInstrumentMask(this.state.instrumentIndex, instruments)\n        } );\n      }\n\n      const classes = this.props;\n      const iOS = process.browser && /iPad|iPhone|iPod/.test(navigator.userAgent);\n      const mobile = this.checkMobile();\n\n      const instrumentConfigColumns = mobile ? 12 : 8;\n\n      return (\n        <React.Fragment>\n          {this.renderSharingDialog()}\n          <div style={{display:\"flex\", width: \"95%\"}}> \n            <IconButton\n              color=\"inherit\"\n              aria-label=\"open pattern list\"\n              edge=\"start\"\n              onClick={(e)=>{ this.setState( {patternsOpen: true } )}}\n              className={clsx({\n                [classes.hide] : !this.state.patternsOpen\n              })}\n            >\n              <ChevronRightIcon />\n            </IconButton>\n            <div className=\"content-title\" style={{flexGrow:1}}>\n            </div>\n            <IconButton\n              color=\"inherit\"\n              aria-label=\"open settings\"\n              edge=\"end\"\n              onClick={(e)=>{ this.setState( {settingsOpen: true } )}}\n              className={clsx(this.state.settingsOpen && classes.hide)}\n            >\n              <MenuIcon />\n            </IconButton>\n          </div>\n          {patternContent}\n          <Grid container>\n          <Grid item xs={(12 - instrumentConfigColumns ) / 2} />\n          <Grid item xs={instrumentConfigColumns}>\n            <InstrumentConfig\n              instruments={this.state.instruments}\n              instrumentIndex={this.state.instrumentIndex}\n              instrumentMask={this.state.instrumentMask}\n              onChange={changeInstrumentsCallback}\n            />\n          </Grid>\n          <Grid item xs={(12 - instrumentConfigColumns ) / 2} />\n          </Grid>\n          {this.renderPatternDrawer(iOS,mobile)}\n          {this.renderSettingsDrawer(iOS,mobile, patternConfig)}\n        </React.Fragment>\n      );\n    }\n  }\n\n  render() {\n    const mainContent = this.renderMainContent();\n    return (\n      <div className=\"App\">\n        <ThemeProvider theme={theme}>\n          <CssBaseline />\n          {mainContent}\n        </ThemeProvider>\n      </div>\n    );\n  }\n}\n\nexport default withStyles(modalStyles)(withRouter(App));\n","import React from 'react';\nimport { makeStyles, useTheme } from '@material-ui/core/styles';\nimport InputLabel from '@material-ui/core/InputLabel';\nimport MenuItem from '@material-ui/core/MenuItem';\nimport FormControl from '@material-ui/core/FormControl';\nimport FormGroup from '@material-ui/core/FormGroup';\nimport FormControlLabel from '@material-ui/core/FormControlLabel';\nimport Switch from '@material-ui/core/Switch';\nimport Select from '@material-ui/core/Select';\nimport notation from \"./notation\";\nimport HelpIcon from '@material-ui/icons/HelpOutlined';\nimport Tooltip from '@material-ui/core/Tooltip';\nimport Icon from '@material-ui/core/Icon';\nimport Grid from '@material-ui/core/Grid';\n\nconst useStyles = makeStyles((theme) => ({\n  formControl: {\n    margin: theme.spacing(1),\n    minWidth: 120,\n  }\n}));\n\nfunction camelToReadable(s)\n{\n  const spacedString = s.replace(/([A-Z])/g, ' $1');\n  return spacedString[0].toUpperCase() + spacedString.slice(1);\n}\n\nfunction FormatSettings(props) {\n  const classes = useStyles(props);\n  const theme = useTheme();\n  // todo: change to multiple useState calls?\n\n  function tokenStateToItem(value)\n  {\n    return value === \" \" ? \"space\" : value;\n  }\n\n  function tokenItemToState(value)\n  {\n    return value === \"space\" ? \" \" : value;\n  }\n\n  const handleOptionChange = (name, value) => {\n    const updatedState = {...props.settings, [name]: value};\n    props.onChange(updatedState);\n  };\n\n  const handleCheckedChange = (event) => {\n    const updatedState = {...props.settings, [event.target.name]: event.target.checked};\n    props.onChange(updatedState);\n  };\n\n  function createOptionMenu(\n    name,\n    options,\n    itemToState = tokenItemToState,\n    stateToItem = tokenStateToItem\n  )\n  {\n    const idString = \"form-control-\" + name + \"-id\";\n    return (\n      <FormControl variant=\"filled\" className={classes.formControl} key={idString} id={idString}>\n        <InputLabel id=\"settings-option-{name}\">{name}</InputLabel>\n        <Select\n          labelId={\"settings-option-\" + name + \"-labelID\"}\n          id={\"settings-option-\" + name + \"-id\"}\n          value={stateToItem(props.settings[name])}\n          name={name}\n          onChange={(e) => handleOptionChange( e.target.name, itemToState(e.target.value))}\n        >\n          {options.map((op) => <MenuItem key={\"settings-menu-item-\" + name + \"-\" + op} value={stateToItem(op)}>{stateToItem(op)}</MenuItem>)}\n        </Select>\n      </FormControl>\n    );\n  };\n\n  function createBoolControl(name)\n  {\n    return (\n      <FormControlLabel\n        control={<Switch checked={props.settings[name]} onChange={handleCheckedChange} name={name} />}\n        label={camelToReadable(name)}\n        key={\"switch-\"+name}\n      />\n    );\n  };\n\n  const resolutionToBeatString = (r) => ( r / props.settings.beatResolution ).toString();\n  const beatStringToResolution = (b) => props.settings.beatResolution * parseInt(b);\n  \n  const candidateLineLengths = [ 2, 3, 4, 5, 6, 7, 8, 14, 16, 32 ];\n  let lineLengths = [];\n  for( const c of candidateLineLengths )\n  {\n    const resolution = c * 48;\n    if( (resolution % props.settings.beatResolution) === 0\n      && (resolution <= props.pattern.length)\n     )\n    {\n      lineLengths.push( resolution );\n    }\n  }\n\n  if( !lineLengths.includes( props.pattern.length ) )\n  {\n    lineLengths.push( props.pattern.length );\n    lineLengths.sort();\n  }\n\n  const candidateBeatResolutions = [24, 36, 48, 72, 96];\n  let beatResolutions = [];\n  for( const c of candidateBeatResolutions )\n  {\n    if( (c % props.pattern.resolution) === 0 && ( props.settings.lineResolution % c ) === 0)\n    {\n      beatResolutions.push( c );\n    }\n  }\n  const beatLineHelp = \"Only options that produce lines made up of 'n' whole beats (no part-beats) are shown. \"\n  + \"If the options displayed for either lineResolution or beatResolution are too restrictive, try changing the other option.\"\n  + \"If lineResolution only results in one line, more options for beatResolution will be shown.\"\n  return (\n    <FormGroup className={classes.root}>\n      {notation.FORMAT_CONFIG_STRINGS.map( op => createOptionMenu( op[0], op[1] ) ).reduce((prev, curr) => [prev, curr])}\n      {notation.FORMAT_CONFIG_BOOLS.map( op => createBoolControl( op )).reduce((prev, curr) => [prev, curr]) }\n      <div style={{backgroundColor : \"white\", color : theme.palette.background.default}}><p> {props.pattern.name + \" Options\"} </p></div>\n      {\n        createOptionMenu(\n          \"beatResolution\",\n          beatResolutions,\n          (v) => v.toString(), // stateToItem\n          (v) => parseInt(v) // itemToState\n        )\n      }\n      {createOptionMenu(\n        \"lineResolution\",\n        lineLengths,\n        beatStringToResolution,\n        resolutionToBeatString\n      )}\n      <Grid container>\n        <Grid item xs={8}/>\n        <Grid item xs={4}>\n          <Tooltip title={beatLineHelp} aria-label=\"help\">\n            <Icon>\n              <HelpIcon />\n            </Icon>\n          </Tooltip>\n        </Grid>\n      </Grid>\n    </FormGroup>\n  );\n}\n\nconst DefaultSettings = notation.DEFAULT_FORMAT_CONFIG; \n\n\nexport { FormatSettings, DefaultSettings }\nexport default FormatSettings;","// FileUpload.react.js\n\n// inspired by https://gist.github.com/AshikNesin/e44b1950f6a24cfcd85330ffc1713513\n// and https://stackoverflow.com/questions/55830414/how-to-read-text-file-in-react\n\nimport React from 'react'\nimport Button from '@material-ui/core/Button';\n\nclass FileImport extends React.Component {\n\n  constructor(props) {\n    super(props);\n    this.hiddenFileInput = React.createRef();\n  }\n\n  onChange(e) {\n    const fileObject = e.target.files[0]\n    const reader = new FileReader()\n    reader.onload = loadEvent => {\n      if( this.props.onImport )\n      {\n        this.props.onImport(\n          { file: fileObject, content : loadEvent.target.result}\n        );\n      }\n    }\n    reader.readAsText(fileObject);\n  }\n\n  render() {\n    const clickFile = (e) => {\n      this.hiddenFileInput.current.click();\n    }\n\n    const {onImport, accept, ...buttonProps} = {...this.props};\n    return (\n      <React.Fragment>\n        <Button onClick={clickFile} {...buttonProps}>Import File</Button>\n        <input\n          type=\"file\"\n          hidden\n          accept={accept}\n          onChange={(e) => this.onChange(e)} ref={this.hiddenFileInput}\n          />\n      </React.Fragment>\n   )\n  }\n}\n\nexport default FileImport;\n","// h2.js\n\nimport track from \"./track\";\nimport xml2js from \"xml2js\";\nimport { calculateResolution } from \"./utilities\";\n\n// TODO: This file was written with the hope that using xml2js would make things cleaner\n// it didn't, purely because xml2js is an okay library doing a difficult task\n// it ensures to produce a good json file but in doing so muddles the data a bit.\n// Should replace this with dom-parser and window.DOMParser\n\n// let's think about the data representation needed\n\nfunction calculatePatternResolution(pattern, size)\n{\n  const positions = Array.from(pattern.notes, note => note.position)\n  return calculateResolution(positions, size);\n}\n\nfunction parseHydrogenJs(result)\n{\n    // fixme:\n    // this parsing often assumes there's >=2 elements\n\n    // this \"zero\" here is presumably an artefact of xml --> json representation\n    const instrumentElements = result.song.instrumentList[0].instrument;\n\n    // instruments\n    // [  { id, name } ]\n    const instrumentArray = Array.from(\n      instrumentElements,\n      function(element){\n        const instrumentComponent = element.instrumentComponent[0];\n        let inst = {\n          \"id\" : parseInt(element.id), \n          \"name\" : element.name[0],\n           \"volume\" : parseFloat(element.volume), \n           \"muted\" : element.isMuted[0] === \"true\",\n           \"gain\" : parseFloat(element.gain),\n           \"drumkit\" : element.drumkit[0]\n        };\n        if( \"layer\" in instrumentComponent )\n        {\n          inst[\"filename\"] = instrumentComponent.layer[0].filename[0];\n        }\n        return inst;\n      }\n    );\n\n    const patternElements = result.song.patternList[0].pattern;\n    // patterns\n    // [  { name, size, notes } ]\n    const patternArray = Array.from(\n      patternElements,\n      function(element){\n        const noteElements = element.noteList[0].note;\n        const patternSize = parseInt(element.size);\n        let notes = [];\n        if( noteElements )\n        {\n          // notes \n          // [ {position, instrument(id}]\n          notes = Array.from(\n            noteElements,\n            function(noteElement){\n              return {\"position\" : parseInt(noteElement.position), \"instrument\" : parseInt(noteElement.instrument)};\n            }\n          );\n\n          // hydrogen permits you to have notes that reach past the pattern size, \n          // they then get revealed when you extend the pattern, \n          // here's an easy point to get rid of them, we don't want them to factor into any calculations\n          notes = notes.filter( n => n.position < patternSize );\n        }\n        return {\n          \"size\" : patternSize, \n          \"name\" : element.name[0],\n          \"notes\" : notes\n        };\n      }\n    );\n\n    // transform pattern to a managable data\n    const patternsWithTracks = Array.from(\n      patternArray,\n      function(pattern)\n      { \n        const resolution = calculatePatternResolution(pattern, pattern.size);\n        let instrumentTracks = {};\n        for( const instrument of instrumentArray )\n        {\n          const relevantNotes = pattern.notes.filter( \n            note => (note.instrument === instrument.id)\n          );\n          const relevantHits = Array.from(\n            relevantNotes,\n            note => note.position\n          );\n          instrumentTracks[ instrument.id.toString() ] = track.fromPositions( relevantHits, pattern.size, resolution);\n        }\n        pattern.resolution = resolution;\n        pattern.instrumentTracks = instrumentTracks;\n        return pattern;\n      }\n    );\n\n    // todo: refactor into (at least one) separate function\n    if(result.song.virtualPatternList)\n    {\n      // so unfortunately, virtualPatternGroup represents a directional graph and we have to build\n      // the tree of dependencies for each node, we implement this in a very simplistic way\n      // let's build a mapping( name -> [ names ] ) and continue to resolve it\n      // until we're done\n      const virtualPatternGroups = result.song.virtualPatternList[0].pattern;    \n      if( virtualPatternGroups )\n      {\n        // each element looks like\n        //\n        // <pattern>\n        // <name>p2-a-djembe</name>\n        // <virtual>p2-a-bass</virtual>\n        // <virtual>p2-snare</virtual>\n        // </pattern>\n\n        let patternToRelated = {};\n\n        // record initial relations\n        for( const virtualGroup of Array.from(virtualPatternGroups) )\n        {\n          const rootPatternName = virtualGroup.name[0];\n          const relatedPatterns = Array.from(virtualGroup.virtual);\n          patternToRelated[rootPatternName] = new Set(relatedPatterns);\n        }\n\n        // expand connections until our object stops changing, brute-force\n        // this is a relatively large limit but is better than the potential of an infinite loop\n        // I think 3 layers would be pushing this feature\n        const MAX_ITERATIONS = 20;\n        for(let iteration = 0; iteration < MAX_ITERATIONS; ++iteration)\n        {\n          let expandedObject = {};\n          // we could do a check at the end of each loop, but it's easier to track object equality this way\n          let objectHasExpanded = false;\n          for(const [root, related] of Object.entries(patternToRelated))\n          {\n            let expandedNodeSet = new Set(related);\n            for( const node of expandedNodeSet )\n            {\n              if( node in patternToRelated )\n              {\n                // set union\n                expandedNodeSet = new Set([...expandedNodeSet, ...patternToRelated[node]]);\n              }\n            }\n            objectHasExpanded = objectHasExpanded || ( expandedNodeSet.size !== related.size );\n            expandedObject[ root ] = expandedNodeSet;\n\n          }\n          // exit if no change\n          if(!objectHasExpanded)\n          {\n            break;\n          }\n          // throw if we've failed to resolve all the connections by now, morelikely something has gone wrong\n          if( iteration === MAX_ITERATIONS )\n          {\n            throw new Error(\"Reached max virtual_pattern recursion depth.\");\n          }\n          // otherwise update mapping and continue\n          patternToRelated = expandedObject;\n        }\n\n        for( const [rootPatternName, relatedPatternSet] of Object.entries(patternToRelated) )\n        {\n          // could do filter, and assert on length?\n          let rootPattern = patternsWithTracks.find(p => p.name === rootPatternName);\n          for( const patternToMergeName of relatedPatternSet )\n          {\n            const patternToMerge = patternsWithTracks.find(p => p.name === patternToMergeName );\n            for( const [id, t] of Object.entries(patternToMerge.instrumentTracks) )\n            {\n              if( id in rootPattern.instrumentTracks )\n              {\n                const merged = rootPattern.instrumentTracks[ id ].aggregate( t );\n                // we match hydrogen's implementation here and discard values past the length of the original track\n                merged.rep.length = rootPattern.size  / merged.resolution;\n                rootPattern.instrumentTracks[ id ] = merged; \n              }\n              else\n              {\n                // ensure track is the appropriate length & res\n                let copiedTrack = t.format(rootPattern.resolution);\n                copiedTrack.length = rootPattern.size  / rootPattern.resolution;\n                rootPattern.instrumentTracks[id] = copiedTrack;\n              }\n            }\n          }\n          // reassess resolution and apply to all tracks\n          // this may not be necessary but it's probably nice\n          const resolution = calculatePatternResolution(rootPattern, rootPattern.size);\n          rootPattern.resolution = resolution;\n          for( const [id, track] of Object.entries(rootPattern.instrumentTracks) )\n          {\n            // ensure that \n            rootPattern[id] = track.format( resolution );\n          }\n        }\n\n      }\n    }\n\n\n    return {\n      \"instruments\" : instrumentArray,\n      \"patterns\" : patternsWithTracks\n    }\n}\n\nasync function parseHydrogenPromise(xmlString)\n{\n  let parser = new xml2js.Parser();\n\n  return parser.parseStringPromise(xmlString).then(parseHydrogenJs);\n}\n\nexport default { parseHydrogenPromise };","import React from 'react';\nimport notation from \"./notation\"\nimport { withStyles } from '@material-ui/core/styles';\n\nconst useStyles = theme => ({\n  root: {\n    whiteSpace:\"pre\"\n  },\n});\n\nclass Part extends React.Component\n{\n  constructor(props) {\n    super(props);\n    this.state = {\n    };\n  }\n\n  render() {\n    const tracks = Object.values(this.props.tracks);\n    if(tracks.length === 0 )\n    {\n      return <React.Fragment />\n    }\n    const patternArray = notation.formatPatternString(\n      this.props.instrument,\n      this.props.tracks,\n      this.props.config.restMark\n    );\n    // don't support a multi-line pattern, that doesn't divide the beatResolution\n    // because it's a nightmare!\n    const patternResolution = tracks[0].resolution;\n    if( (this.props.config.lineResolution % this.props.config.beatResolution) !== 0\n        && ( patternArray.length * patternResolution > this.props.config.lineResolution ) )\n    {\n      throw new Error(\"This code only supports a beatResolution that divides the lineResolution\");\n    }\n    // this code has got very convoluted\n    const patternLines = notation.chunkArray(patternArray, this.props.config.lineResolution / patternResolution, 0);\n    const beatsPerLine = this.props.config.lineResolution / this.props.config.beatResolution;\n    const beatChunkSize = this.props.config.beatResolution / patternResolution;\n    const linesWithBeats = patternLines.map(\n      line => notation.chunkArray( line, beatChunkSize )\n    );\n    const lineIndices = [...patternLines.keys()];\n    const formatLine = (key, line, startBeat)=>{\n      const beats = [...line.keys()];\n      return (\n        <p key={\"pattern-line-\" + key}>\n          <span key={\"line-start-\" + key}>{this.props.config.lineMark}</span>\n          {\n            beats.map( beat => <React.Fragment key={\"fragment-beat-\"+ (beat + startBeat).toString()}>\n              <span key={\"span-beat-\" + (beat + startBeat).toString()} className={(beat + startBeat) === this.props.activeNote ? \"activeNote\" : \"\"}>{line[beat].join(\"\")}</span>\n              <span key={\"span-beat-marker-\" + (beat + startBeat).toString()}>{(this.props.config.showBeatMark && beat !== beats[beats.length-1]) ? this.props.config.beatMark : \"\"}</span>\n            </React.Fragment>\n            )\n          }\n          <span key={\"line-end-\" + key}>{this.props.config.lineMark}</span>\n        </p>\n      );\n    };\n\n    const numberLine = notation.createNumberMarker(\n      this.props.config.numberRestMark,\n      this.props.config.beatResolution,\n      patternResolution,\n      Math.min( this.props.config.lineResolution, patternLines[0].length * patternResolution )\n    );\n    const beatChunks = notation.chunkArray(\n      numberLine,\n      this.props.config.beatResolution / patternResolution\n    );\n    return (\n      <React.Fragment>\n        {this.props.config.showBeatNumbers ? formatLine(\"beat\", beatChunks, 0) : \"\" }\n        {lineIndices.map(lineIndex=>formatLine(lineIndex.toString(), linesWithBeats[lineIndex], beatsPerLine * lineIndex))}\n      </React.Fragment>\n    );\n  }\n}\n\nexport default withStyles(useStyles)(Part);","import React from 'react';\nimport Part from \"./Part\";\n\nfunction getTitleType(headingLevel, defaultLevel)\n{\n    const validHeadingLevels = ['h1', 'h2', 'h3', 'h4', 'h5', 'h6'];\n    const safeHeading = headingLevel ? headingLevel.toLowerCase() : '';\n    const Title = validHeadingLevels.includes(safeHeading) ? safeHeading : defaultLevel;\n    return Title;\n}\n\nclass PartWithTitle extends React.Component\n{\n  constructor(props) {\n    super(props);\n    this.state = {\n    };\n  }\n\n  render() {\n    const Title = getTitleType(this.props.headingLevel, \"h4\");\n    return (\n      <article>\n        <Title>{this.props.instrumentName}</Title>\n        <Part \n          instrument={this.props.instrument}\n          tracks={this.props.tracks}\n          config={this.props.config}\n          activeNote={this.props.activeNote}\n        />\n      </article>\n    );\n  }\n}\n\nexport default PartWithTitle;","import React from 'react';\nimport PartWithTitle from \"./PartWithTitle\";\nimport { withStyles } from '@material-ui/core/styles';\n\nconst useStyles = theme => ({\n  root: {\n    \"margin-bottom\": theme.spacing(2),\n    fontFamily: \"Roboto Mono\",\n    textAlign: \"left\",\n    whiteSpace:\"pre\",\n    \"& .activeNote\": {\n      color : theme.palette.primary.main\n    }\n  },\n});\n\nclass Pattern extends React.Component\n{\n  constructor(props) {\n    super(props);\n    this.state = {\n      patternTime : undefined\n    };\n  }\n\n  onPatternTimeChange(patternTime)\n  {\n    if( patternTime !== null && patternTime !== undefined )\n    {\n      this.setState({patternTime : patternTime});\n    }\n    else\n    {\n      this.setState({patternTime : undefined });\n    }\n  }\n\n  render() {\n    const { classes } = this.props;\n    const instrumentIndices = [...this.props.instruments.keys()];\n    const beatResolution = this.props.config.beatResolution;\n    return (\n      <div className={classes.root} >\n        { instrumentIndices.map( \n            (instrumentIndex) => ( <PartWithTitle \n              key={\"part-\" + instrumentIndex.toString()}\n              instrumentName={this.props.instruments[instrumentIndex][0]}\n              instrument={this.props.instruments[instrumentIndex][1]}\n              tracks={this.props.tracks}\n              config={this.props.config}\n              activeNote={this.state.patternTime !== undefined ? Math.floor(this.state.patternTime / beatResolution) : undefined}\n            /> )\n          )\n        }\n      </div>\n    );\n  }\n}\n\nexport default withStyles(useStyles)(Pattern);","class Audio\n{\n\n  // todo: we replace a valid audioContext with a blank object, so that we can run tests in node\n  //       this should probably be replaced by https://github.com/audiojs/web-audio-api \n  //       and a test-suite written\n  static createWebContext()\n  {\n    return new (window.AudioContext || window.webkitAudioContext || Object)();\n  }\n\n  static determineMinResolution(\n    instrumentIndex,\n    tracks\n  )\n  {\n      let minResolution = 48; \n      for(const [id,t] of Object.entries(tracks))\n      { \n        // the lookup and iteration shouldn't look like this\n        const selected =  instrumentIndex.filter(inst => inst.id.toString() === id);\n        if( \n          selected.length > 0 \n          && !t.empty()\n        )\n        {\n          minResolution = Math.min( minResolution, t.resolution );\n        }\n      }\n      return minResolution;\n  }\n\n  static determineTrackLength(\n    instrumentIndex,\n    tracks\n  )\n  {\n      let trackLength = 48;\n      for(const [id,t] of Object.entries(tracks))\n      { \n        // the lookup and iteration shouldn't look like this\n        const selected =  instrumentIndex.filter(inst => inst.id.toString() === id);\n        if( \n          selected.length > 0 \n          && !t.empty() \n        )\n        {\n          trackLength = Math.max( trackLength, t.length() );\n        }\n      }\n      return trackLength;\n  }\n\n  static peakAmplitude(\n    combined\n  )\n  {\n    let peakValue = 0.0;\n    for (let channel = 0; channel < combined.numberOfChannels; channel++) {\n      let combinedChannel = combined.getChannelData(channel);\n      for( let sample = 0; sample < combinedChannel.length; ++sample)\n      {\n        peakValue = Math.max( Math.abs(combinedChannel[sample]), peakValue );\n      }\n    }\n    return peakValue;\n  }\n\n  static normalizeAudioBuffer(\n    combined\n  )\n  {\n    const peakValue = Audio.peakAmplitude( combined );\n    if( peakValue > 1.0 )\n    {\n      for (let channel = 0; channel < combined.numberOfChannels; channel++) {\n        let combinedChannel = combined.getChannelData(channel);\n        for( let sample = 0; sample < combinedChannel.length; ++sample)\n        {\n          combinedChannel[sample] = combinedChannel[sample] / peakValue;\n        }\n      }\n    }\n    return combined;\n  }\n\n  static createMasterTrack(\n    context,\n    tracks,\n    instrumentIndex,\n    sounds,\n    tempo\n  )\n  {\n    const trackLength = Audio.determineTrackLength( instrumentIndex, tracks );\n\n\n    const beatTime =  (60.0 / tempo) * 1000;\n    const timePerHydrogen = beatTime / 48.0;\n\n\n    // let's assume we can do some simple things\n\n    const sampleRate = 44100;\n    const channels = 2;\n    const trackLengthMs = trackLength * timePerHydrogen;\n    const trackLengthSamples = trackLengthMs * sampleRate / 1000.0;\n    const totalSamples = Math.floor(trackLengthSamples);\n    const samplesPerHydrogen = Math.floor( totalSamples / trackLength );\n    const combined = context.createBuffer(channels, totalSamples, sampleRate);\n\n    // populate blank buffer with sounds\n    for (let channel = 0; channel < combined.numberOfChannels; channel++) {\n      let combinedChannel = combined.getChannelData(channel);\n      for(const [id,t] of Object.entries(tracks))\n      { \n        // the lookup and iteration shouldn't look like this\n        const selected =  instrumentIndex.filter(inst => inst.id.toString() === id);\n        if( \n          selected.length > 0 \n          && selected[0].id in sounds\n          && !t.empty()\n        )\n        {\n          const audioBuffer = sounds[selected[0].id];\n          // fallback to copying the mono buffer across both channels\n          const audioChannel = audioBuffer.numberOfChannels === 2 ? audioBuffer.getChannelData(channel) : audioBuffer.getChannelData(0);\n          const trackPoints = t.toPoints();\n          for( const noteStart of trackPoints )\n          {\n            const sampleStart = noteStart * samplesPerHydrogen;\n            // console.log(\"inserting sample at \" + sampleStart * (trackLengthBeats/trackLengthSamples));\n            for( let sample = 0; sample < audioBuffer.length; ++sample )\n            {\n              // add sample to mega track\n              combinedChannel[sampleStart + sample] = combinedChannel[sampleStart + sample] + audioChannel[sample];\n            }\n          }\n        }\n      }\n    }\n\n    return Audio.normalizeAudioBuffer( combined );\n  }\n\n  static createAudioSource(context, buffer, tempo)\n  {\n    var source = context.createBufferSource();\n    // set the buffer in the AudioBufferSourceNode\n    source.buffer = buffer;\n    source.loop=true;\n    if( tempo !== null )\n    {\n      source.playbackRate.value = tempo / 100.0;\n    }\n    // connect the AudioBufferSourceNode to the\n    // destination so we can hear the sound\n    source.connect(context.destination);\n    return source;\n  }\n  static createOneShotAudioSource(context, buffer, tempo)\n  {\n    var source = context.createBufferSource();\n    // set the buffer in the AudioBufferSourceNode\n    source.buffer = buffer;\n    source.loop=false;\n    if( tempo !== null )\n    {\n      source.playbackRate.value = tempo / 100.0;\n    }\n    // connect the AudioBufferSourceNode to the\n    // destination so we can hear the sound\n    source.connect(context.destination);\n    return source;\n  }\n}\n\nexport default Audio;","import React from 'react';\nimport Audio from \"./Audio\"\n\nimport IconButton from '@material-ui/core/IconButton';\nimport PlayArrowIcon from '@material-ui/icons/PlayArrow';\nimport StopIcon from '@material-ui/icons/Stop';\nimport Slider from '@material-ui/core/Slider';\nimport Grid from '@material-ui/core/Grid';\nimport * as Tone from \"tone\";\n\n// these are the hydrogen drumkits available by GPL/CC\n\nconst DRUMKITS = [\n  \"circAfrique v4\",\n  \"DeathMetal\",\n  \"The Black Pearl 1.0\",\n  \"GMRockKit\",\n  \"TR808EmulationKit\"\n];\n\n// TODO: This is very much not a react component, as it stands\n//   \n\nclass ToneBoard extends React.Component\n{\n\n  constructor(props) {\n    super(props);\n    this.state = {\n      tempo: 100.0\n    };\n    this.samplerCount = 0;\n    this.sequences = {};\n    this.gain = new Tone.Gain();\n    this.gain.toDestination();\n    Tone.Transport.bpm.value = this.state.tempo;\n  }\n\n\n  chooseAppropriateUrlForInstrument(drumkitName, instrumentName)\n  {\n    const name = instrumentName.toLowerCase();\n    // this is currently very basic\n    if(name.includes(\"kick\"))\n    {\n        return \"The Black Pearl 1.0/PearlKick-Hard.wav\";\n    }\n    else if(name.includes(\"stick\"))\n    {\n        return \"DeathMetal/16297_ltibbits_sticks_low_pitch.wav\";\n    }\n    else if(name.includes(\"tom\"))\n    {\n        return \"TR808EmulationKit/808_Tom_Mid.wav\"\n    }\n    else if(name.includes(\"clap\"))\n    {\n        return \"TR808EmulationKit/808_Clap.wav\";\n    }\n    else if(name.includes(\"snare\"))\n    {\n      return \"GMRockKit/Snare-Soft.wav\";\n    }\n    else\n    {\n      // todo: snare, cymbals\n      return null;\n    }\n  }\n\n\n  populateSamples()\n  {\n    this.samplerCount = 0;\n    this.expectedSamplerCount = 0;\n    let mapping = {};\n    const tracks = this.props.selectedPattern.instrumentTracks;\n    for(const [id,] of Object.entries(tracks))\n    {\n      const selected = this.props.instrumentIndex.filter(inst => inst.id.toString() === id);\n      if( selected.length > 0)\n      {\n        const selectedInstrument = selected[0];\n        if(\n          \"drumkit\" in selectedInstrument && \n          \"filename\" in selectedInstrument &&\n          DRUMKITS.includes(selectedInstrument.drumkit) )\n        {\n          const filename = selectedInstrument.filename.replace(\".flac\", \".wav\");\n          mapping[selectedInstrument.id] = new Tone.Player( \n            process.env.PUBLIC_URL + \"/wav/\" + selectedInstrument.drumkit + \"/\" + filename, \n            () => { this.samplerCount++; } \n          );\n          mapping[selectedInstrument.id].connect(this.gain);\n          this.expectedSamplerCount++;\n        }\n        else if( \"drumkit\" in selectedInstrument )\n        {\n          const relativeUrl = this.chooseAppropriateUrlForInstrument( selectedInstrument.drumkit, selectedInstrument.name );\n          if(relativeUrl !== null)\n          {\n            mapping[selectedInstrument.id] = new Tone.Player( \n              process.env.PUBLIC_URL + \"/wav/\" + relativeUrl, \n              () => { this.samplerCount++; } \n            );\n            mapping[selectedInstrument.id].connect(this.gain);\n            this.expectedSamplerCount++;\n          }\n        }\n      }\n    }\n    this.samples = mapping;\n  }\n\n  createSequences()\n  {\n    const instrumentIndex = this.props.instrumentIndex;\n    let sequences = {};\n    for( let p of this.props.patterns )\n    {\n      const patternResolution = Audio.determineMinResolution(instrumentIndex, p.instrumentTracks);\n      const patternLength = Audio.determineTrackLength(instrumentIndex, p.instrumentTracks);\n      sequences[ p.name ] = new Tone.Sequence(\n        (time,index) => { this.tick(time, index); },\n        [...Array(patternLength / patternResolution).keys()],\n        Tone.Time(\"4n\") * ( patternResolution / 48.0 )\n      );\n      // start the sequence, but the ticks won't be triggered when muted\n      // note: setting mute on the sequence directly seems to have no effect\n      sequences[ p.name ]._part.mute = true;\n      sequences[ p.name ].start(0);\n    }\n    return sequences;\n  }\n\n  schedulePlaybackForNewTracks()\n  {\n    const instrumentIndex = this.props.instrumentIndex;\n    const tracks = this.props.selectedPattern.instrumentTracks;\n    let board = this;\n    // todo: precompute these numbers for smoother transitions?\n    const resolution = Audio.determineMinResolution(instrumentIndex, tracks );\n    const length = Audio.determineTrackLength(instrumentIndex, tracks );\n\n    // we have a little fudge in here... if we're transitioning from a 4 beat loop\n    // to an 8 beat pattern ... we probably really wanted to hit the start of that pattern,\n    // not to transition at 3.75 beats and play the latter half\n    const now = Tone.Transport.toSeconds(Tone.Transport.position);\n    const timeFromBarEnd = Tone.Transport.loopEnd  - now;\n    const queueTransition = Tone.Transport.state === \"started\" \n    && ( timeFromBarEnd > 0 && timeFromBarEnd < Tone.Time(\"8n\").toSeconds())\n    && ( length > this.state.length);\n    const enableNewTrack = () => {\n      // note: setting mute on the sequence directly seems to have no effect\n      this.sequences[this.props.selectedPattern.name]._part.mute = false;\n      Tone.Transport.loop = true;\n      Tone.Transport.setLoopPoints(0, Tone.Time(\"4n\") * (length / 48.0));\n    };\n    // react won't set state if these variables are equal\n    // this mostly illustrates this component probably shouldn't have two state philosophies\n    // note: we only trigger \"queueTransition\" when length > this.state.length so don't worry about that\n    if( resolution === this.state.resolution && length === this.state.length )\n    {\n      enableNewTrack();\n      return;\n    }\n    board.setState( \n      { \n        resolution : resolution,\n        length : length\n      },\n      () => { \n        if( queueTransition ) { \n          Tone.Transport.scheduleOnce(\n            enableNewTrack,\n            Tone.Time(\"0\")\n          );\n        }\n        else\n        {\n          enableNewTrack();\n        }\n      }\n    );\n  }\n\n  samplesReady()\n  {\n    return this.sampleCount === this.expectedSampleCount;\n  }\n\n  tick(time,indexFromStart)\n  {\n    if( time === this.lastTickTime )\n    {\n      // this sometimes seems to happen\n      // and the samples complain\n      // \"start time must be strictly greater than previous start time\"\n      // this is a horrible temporary fix\n      return;\n    }\n    this.lastTickTime = time;\n    const trackLengthRes = ( this.state.length / this.state.resolution );\n    const index = indexFromStart % trackLengthRes;\n    if(!this.samplesReady())\n    {\n      return;\n    }\n    const tracks = this.props.selectedPattern.instrumentTracks;\n    for(const [id,t] of Object.entries(tracks))\n    {\n        if( t.rep[index] )\n        {\n          this.samples[id].start(time);\n        }\n    }\n    if( this.props.onPatternTimeChange )\n    {\n      Tone.Draw.schedule(\n        ()=>{\n          const notePosition = ( indexFromStart * this.state.resolution ) % this.state.length;\n          this.props.onPatternTimeChange( notePosition );\n        },\n        time\n      );\n    }\n  }\n\n  play()\n  {\n    // Tone.start is needed to be triggered from a user interaction\n    // (web-audio-context policy of not playing until a user interaction)\n    Tone.start().then(()=>{Tone.Transport.start();});\n  }\n\n  stop()\n  {\n    // it's slightly unclear what the synchronisation semantics of this Tone.Transport.stop() call are.\n    // If a tick is currently in flight on Tone.Transport we have to ensure that\n    // the reset of patternTime occurs *afterwards*. \n    // The below calls seem to work for this, but I couldn't tell you why.\n    if( Tone.Transport.state === \"started\")\n    {\n      Tone.Transport.stop();\n      if( this.props.onPatternTimeChange )\n      {\n        Tone.Draw.schedule(\n          ()=>{\n            this.props.onPatternTimeChange( null );\n          },\n          Tone.Transport.now()\n        );\n      }\n    }\n  }\n\n  componentDidMount()\n  {\n    this.populateSamples();\n    this.sequences = this.createSequences();\n    this.schedulePlaybackForNewTracks();\n  }\n\n  componentDidUpdate(prevProps, prevState, snapshot)\n  {\n    // theoretically we should be evaluating a rougher equality on the tracks here\n    // but ... as is !== will never be wrong here, and our linter warns if we don't use it \n    const patternChange = prevProps.selectedPattern.name !== this.props.selectedPattern.name;\n    if( patternChange )\n    {\n      this.sequences[prevProps.selectedPattern.name]._part.mute = true;\n      this.schedulePlaybackForNewTracks();\n    }\n  }\n\n  tempoControl()\n  {\n    const onTempoChange = (event, tempo) => {\n      this.setState( { tempo : tempo } );\n      Tone.Transport.bpm.value = tempo;\n    };\n    return (\n      <Slider\n        defaultValue={100}\n        min={60}\n        step={1}\n        max={180}\n        onChange={onTempoChange}\n        valueLabelDisplay=\"auto\"\n      />\n    );\n\n  }\n\n  render() {\n    const tempoControlColumns = 4;\n\n    return (\n      <React.Fragment>\n        <div>\n          <IconButton\n            color=\"primary\"\n            aria-label=\"play\"\n            onClick={(e)=>{this.play();}}\n          >\n            <PlayArrowIcon />\n          </IconButton>\n          <IconButton\n            color=\"secondary\"\n            aria-label=\"stop\"\n            onClick={(e)=>{this.stop();}}\n          >\n            <StopIcon />\n          </IconButton>\n        </div>\n\n        <Grid container>\n        <Grid item xs={(12 - tempoControlColumns) / 2} />\n        <Grid item xs={tempoControlColumns}>\n        {this.tempoControl()}\n        </Grid>\n        <Grid item xs={(12 - tempoControlColumns ) / 2} />\n        </Grid>\n\n      </React.Fragment>\n   );\n  }\n\n};\n\nexport default ToneBoard;","import React from \"react\";\nimport {\n  BrowserRouter as Router,\n  Switch,\n  Route\n} from \"react-router-dom\";\nimport App from \"./App\";\n\n\nexport default function Routes() {\n  return (\n    <Router basename={process.env.PUBLIC_URL}>\n        <Switch>\n          <Route path=\"/song/:song\">\n            <App/>\n          </Route>\n          <Route path=\"/\">\n            <App/>\n          </Route>\n        </Switch>\n    </Router>\n  )\n};","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' },\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport Routes from './Routes';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(\n  <React.StrictMode>\n    <Routes />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n","\nclass notation\n{\n\n  static DEFAULT_FORMAT_CONFIG = {\n    \"restMark\" : \"-\",\n    \"beatMark\" : \"|\",\n    \"lineMark\" : \"|\",\n    \"numberRestMark\" : \"-\",\n    \"beatResolution\" : 48,\n    \"showBeatMark\" : true,\n    \"showBeatNumbers\" : true,\n    // lineResolution is typically determined on a per-pattern basis\n    // however it used to be in here, and some tests still rely on this\n    \"lineResolution\" : 48 * 8\n  };\n\n  static FORMAT_CONFIG_STRINGS = [\n    [\"restMark\",[\"-\", \".\", \" \"]],\n    [\"numberRestMark\",[\"-\", \".\", \" \"]]\n  ];\n\n  static FORMAT_CONFIG_BOOLS = [\n    \"showBeatMark\",\n    \"showBeatNumbers\"\n  ];\n\n  static validateConfig(config, patternResolution) {\n    if( patternResolution != null && ( config.beatResolution % patternResolution ) !== 0 )\n    {\n      throw new Error(\"patternResolution doesn't divide beatResolution\");\n    }\n    if( config.lineResolution <= 0 )\n    {\n      throw new Error(\"config.lineResolution must be greater than zero\");\n    }\n  }\n\n  static resolveConfig(formatConfig)\n  {\n    for( const propName of Object.keys(formatConfig))\n    {\n      if(!notation.DEFAULT_FORMAT_CONFIG.hasOwnProperty(propName))\n      {\n        throw new Error(\"passed unrecognised property \" + propName);\n      }\n    }\n\n    return Object.assign( Object.assign({}, notation.DEFAULT_FORMAT_CONFIG), formatConfig );\n  }\n\n  static chunkString(str, chunkSize) {\n    if( chunkSize <= 0 )\n    {\n      throw new Error(\"chunkSize must be > 0\")\n    }\n    return str.match(new RegExp('.{1,' + chunkSize + '}', 'g'));\n  }\n\n  static chunkArray(a, chunkSize)\n  {\n    if( chunkSize <= 0 )\n    {\n      throw new Error(\"chunkSize must be > 0\")\n    }\n    let chunks = [];\n    for( let i = 0; i < a.length; i += chunkSize )\n    {\n      chunks.push( a.slice(i, Math.min( i + chunkSize, a.length) ) );\n    }\n    return chunks;\n  }\n\n  static createNumberMarker(numberRestMark, beatResolution, patternResolution, lineLength)\n  {\n    if( lineLength <= 0 )\n    {\n      throw new Error(\"lineLength <= 0\");\n    }\n\n    if( ( beatResolution % patternResolution ) !== 0)\n    {\n      throw new Error(\"patternResolution \" + patternResolution.toString() + \" does not divide beatResolution \" + beatResolution.toString());\n    }\n\n    let beatCount = Math.ceil(lineLength / beatResolution);\n    let numberMarkerArray = Array.from( Array(lineLength / patternResolution), e => numberRestMark );\n\n    for( let beat = 0; beat < beatCount; beat++ )\n    {\n      numberMarkerArray[ beat * ( beatResolution / patternResolution ) ] = ( (beat+1) % 10 ).toString();\n    }\n    return numberMarkerArray;\n  }\n\n  static formatLineWithMarkers(config, line, patternResolution, asHTML)\n  {\n    notation.validateConfig(config);\n\n    const beatChunkSize = config.beatResolution / patternResolution;\n\n    const padZero = (n, width) => {\n      n = n + '';\n      return n.length >= width ? n : new Array(width - n.length + 1).join('0') + n;\n    };\n    const formatSymbolAsSpans = (symbol, numericPosition) => {\n      return \"<span class='note-\" + padZero(numericPosition, 4) + \"'>\" +  symbol + \"</span>\";\n    };\n\n    const formatSymbol = asHTML ? formatSymbolAsSpans : (symbol, numericPosition) => symbol;\n\n    let formattedLine = \"\";\n    for( let index = 0; index < line.length; ++ index )\n    {\n      const numericPosition = patternResolution * index;\n      formattedLine += formatSymbol(line.charAt(index), numericPosition);\n    }\n\n\n    const lineWithBeats = config.showBeatMark ? notation.chunkString(formattedLine, beatChunkSize * formatSymbol(\"X\", 0).length).join(config.beatMark) : formattedLine;\n    // note: we choose to always show the lineMarker even if it doesn't match the line resolution\n    return config.lineMark + lineWithBeats + config.lineMark;\n  }\n\n  static defaultLineResolution(\n    trackDict,\n    beatResolution\n  )\n  {\n    const instrumentTracks = Object.values(trackDict);\n    if(instrumentTracks.length === 0)\n    {\n      return 48 * 8;\n    }\n    const trackLength = instrumentTracks[0].length();\n    const beatCount = trackLength / beatResolution;\n    if( beatCount <= 12 )\n    {\n      return trackLength;\n    }\n    else if( beatCount > 32 )\n    {\n      return 48 * 16; // let's just be laazeee\n    }\n    else\n    {\n      // let's just apply a simple mapping, rather than think through logics\n      const mapping = [\n        trackLength, // 13 \n        trackLength / 2, // 14\n        trackLength / 3, // 15\n        trackLength / 2, // 16\n        trackLength, // 17\n        trackLength / 3, // 18\n        trackLength, // 19\n        trackLength / 4, // 20\n        trackLength / 3, // 21\n        trackLength / 2, // 22\n        trackLength, // 23\n        trackLength / 3, // 24\n        trackLength / 5, // 25\n        trackLength, // 26\n        trackLength / 3, // 27\n        trackLength / 4, // 28\n        trackLength, // 29\n        trackLength / 6, // 30\n        trackLength, // 31\n        trackLength / 4, // 32\n      ];\n      return mapping[ beatCount - 13 ];\n    }\n  }\n\n  static guessPerPatternSettings(\n    trackDict\n  )\n  {\n    return {\n      \"lineResolution\" : notation.defaultLineResolution(trackDict, 48), // beatResolution (default)\n      \"beatResolution\" : 48 // should cover all the cases hopefully\n    };\n  }\n\n  static formatPatternString(\n    instrument,\n    trackDict,\n    restMark\n  )\n  {\n    let instrumentTracks = Object.values(trackDict);\n    if(instrumentTracks.length === 0)\n    {\n      return \"\";\n    }\n\n    const patternSize = instrumentTracks[0].length();\n    const patternResolution = instrumentTracks[0].resolution;\n    const notationLength = patternSize / patternResolution;\n\n    let patternArray = Array(notationLength).fill(restMark);\n    for( let charIndex = 0; charIndex < patternArray.length; ++charIndex)\n    {\n      // todo: handle collisions\n      for( const [trackID, trackSymbol] of Object.entries(instrument) )\n      {\n        const trackInstance = trackDict[trackID];\n        if( trackInstance != null && trackInstance.rep[charIndex] === 1 )\n        {\n          patternArray[charIndex] = trackSymbol;\n        }\n      }\n    }\n    return patternArray;\n  }\n\n  static fromInstrumentAndTrack(\n    instrument,\n    trackDict,\n    asHTML,\n    formatConfig = {}\n  )\n  {\n    const config = notation.resolveConfig(formatConfig);\n\n    let instrumentTracks = Object.values(trackDict);\n    if(instrumentTracks.length === 0)\n    {\n      return \"\";\n    }\n\n    // turn the tracks, into one char string\n    const patternArray = notation.formatPatternString( instrument, trackDict, config.restMark );\n    const patternString = patternArray.join(\"\");\n    const patternResolution = instrumentTracks[0].resolution;\n    const patternSize = instrumentTracks[0].length();\n\n    // handle lines and beatMarkers\n    let lineArray = notation.chunkString( patternString, config.lineResolution / patternResolution );\n\n    let formattedLineArray = [];\n    // add numbers on the first line\n    if( config.showBeatNumbers )\n    {\n      formattedLineArray.push( notation.formatLineWithMarkers( \n        config, \n        notation.createNumberMarker(config.numberRestMark, config.beatResolution, patternResolution, Math.min(config.lineResolution, patternSize)).join(\"\"),\n        patternResolution,\n        asHTML\n      ) );\n    }\n    for( let i = 0; i < lineArray.length; ++i )\n    {\n      formattedLineArray.push( notation.formatLineWithMarkers( config, lineArray[i], patternResolution, asHTML ) );\n    }\n\n    return formattedLineArray.join(\"\\n\");\n  }\n};\n\nexport default notation;","const DEFAULT_INSTRUMENT_SYMBOLS = {\n  \"Djembe Slap\" : \"S\",\n  \"Djembe Tone\" : \"t\",\n  \"Djembe Bass\" : \"O\",\n  \"Snare Ghost\" : \"x\",\n  \"Snare Accent\" : \"X\",\n  \"Shaker Ghost\" : \"x\",\n  \"Shaker Accent\" : \"X\",\n  \"Click\" : \"X\",\n  \"Bass\" : \"O\",\n  \"Tom\" : \"O\",\n  \"Default\" : \"X\"\n};\n\nfunction normalizeInstrumentsForFiguring(instruments)\n{\n  let n = [];\n  for(const inst of instruments)\n  {\n    let nInst = Object.assign({}, inst);\n    // for some reason these instruments are one-size arrays, and one id ... the track id from hydrogen\n    // this should be fixed, this doesn't make sense\n    nInst.name = nInst.name.toLowerCase();\n    n.push( nInst );\n  }\n  return n;\n}\n\nfunction figureDjembes(instrumentsRaw, symbolConfig)\n{\n  const instruments = normalizeInstrumentsForFiguring(instrumentsRaw);\n  const djembeTracks = instruments.filter( (inst) => inst.name.includes(\"djembe\") );\n  if(djembeTracks.length === 0)\n  {\n    return [];\n  }\n  else if(djembeTracks.length <= 3)\n  {\n    // let's lazily assume we have a slap, tone, bass\n    const slapArray = Array.from( djembeTracks, (inst) => inst.name.includes(\"slap\") );\n    const toneArray = Array.from( djembeTracks, (inst) => inst.name.includes(\"tone\") );\n    const bassArray = Array.from( djembeTracks, (inst) => inst.name.includes(\"bass\") );\n    for( let i = 0; i < djembeTracks.length; ++i )\n    {\n      let parityCheck = slapArray[i] + toneArray[i] + bassArray[i];\n      // failed to figure out how djembes work return empty array\n      if(parityCheck !== 1)\n      {\n        return [];\n      }\n    }\n    let djembeMapping = {};\n    for( let i = 0; i < djembeTracks.length; ++i )\n    {\n      if( slapArray[i] )\n      {\n        djembeMapping[ djembeTracks[i].id.toString() ] = symbolConfig[\"Djembe Slap\"];\n      }\n      else if( toneArray[i] )\n      {\n        djembeMapping[ djembeTracks[i].id.toString() ] = symbolConfig[\"Djembe Tone\"];\n      }\n      else if( bassArray[i] )\n      {\n        djembeMapping[ djembeTracks[i].id.toString() ] = symbolConfig[\"Djembe Bass\"];\n      }\n    }\n    return [ [ \"Djembe\", djembeMapping ] ];\n  }\n  else\n  {\n    // TODO: support more than one djembe\n    return []\n  }\n}\n\n// used by snare/shaker\nfunction manageAccentOrGhost(instrumentTracks, instrumentName, accentSymbol, ghostSymbol)\n{\n  let outputInstruments = [];\n  if(instrumentTracks.length === 2)\n  {\n    const t0 = instrumentTracks[0];\n    const t1 = instrumentTracks[1];\n    // attempt to determine ghost/accent\n    const zeroLouder = t0.volume > t1.volume || (t0.volume === t1.volume && t0.gain > t1.gain);\n    let mapping = {};\n    mapping[ t0.id.toString() ] = zeroLouder ? accentSymbol : ghostSymbol;\n    mapping[ t1.id.toString() ] = zeroLouder ? ghostSymbol : accentSymbol;\n    outputInstruments.push([instrumentName, mapping] );  \n  }\n  else // if 1 it must be an accent, if >= 3 ... I don't want to try and assign ghosts/accents\n  {\n    // I don't want to support ghost/accent here right now\n    for( const track of instrumentTracks )\n    {\n      let mapping = {};\n      mapping[ track.id.toString() ] = accentSymbol;\n      outputInstruments.push([instrumentName, mapping] );  \n    }\n  }\n  return outputInstruments;\n\n}\n\nfunction figureShakers(instrumentsRaw, symbolConfig)\n{\n  const instruments = normalizeInstrumentsForFiguring(instrumentsRaw);\n  // todo: support common alternative shakers? Tambourine?\n  const shakerTracks = instruments.filter( (inst) => ( inst.name.includes(\"shaker\") ) );\n  return manageAccentOrGhost( \n    shakerTracks, \n    \"Shaker\", \n    symbolConfig[\"Shaker Accent\"],\n    symbolConfig[\"Shaker Ghost\"]\n  );\n}\n\nfunction figureSnares(instrumentsRaw, symbolConfig)\n{\n  const instruments = normalizeInstrumentsForFiguring(instrumentsRaw);\n  const snareTracks = instruments.filter( (inst) => ( inst.name.includes(\"snare\") ) );\n  // todo: we currently assume 2 snares is accent/ghost ... but I think it's relatively\n  // common to be 2 snare parts too, I think the algorithm here is check patterns to\n  // see if they overlap ... if the \"ghosts\" overlap the \"hits\" sometimes, assume 2 parts\n  return manageAccentOrGhost( \n    snareTracks, \n    \"Snare\", \n    symbolConfig[\"Snare Accent\"],\n    symbolConfig[\"Snare Ghost\"]\n  );\n}\n\n\nfunction activeInstruments(patterns)\n{\n  let nonTrivialInstruments = new Set();\n  for( const p of patterns )\n  {\n    for(const [instrumentID, part] of Object.entries(p.instrumentTracks))\n    {\n      if( !part.empty() )\n      {\n        nonTrivialInstruments.add(parseInt(instrumentID));\n      }\n    }\n  }\n  return nonTrivialInstruments;\n}\n\nfunction activeInstrumentation(instrumentIndex, patterns)\n{\n  const active = activeInstruments(patterns);\n  let nonTrivialInstruments = [];\n  for( const inst of instrumentIndex)\n  {\n    if( active.has(inst.id) )\n    {\n      nonTrivialInstruments.push( inst );\n    }\n  }\n  return nonTrivialInstruments;\n}\n\nfunction figureClickyInstruments(instrumentsRaw, symbolConfig, patterns)\n{\n  const instruments = normalizeInstrumentsForFiguring(instrumentsRaw);\n  const worthwhileInstruments = activeInstruments(patterns);\n  const relevantTracks = instruments.filter( (inst) => ( worthwhileInstruments.has(inst.id) &&\n    !inst.name.includes(\"djembe\") &&\n    ( inst.name.includes(\"click\") || \n    inst.name.includes(\"stick\") || \n    inst.name.includes(\"tom\") || \n    inst.name.includes(\"bass\") ||\n    inst.name.includes(\"kick\") )\n  ) );\n\n  const trackIsClick = Array.from(\n    relevantTracks,\n    (t) => t.name.includes(\"click\") || t.name.includes(\"stick\")\n  );\n  // we prioritise the early tracks\n  // and hope for the best\n\n  let tomIndex = 1;\n  let bassIndex = 1;\n  let collated = [];\n  for( let candidate = 0; candidate < Math.floor(relevantTracks.length/2); ++candidate )\n  {\n    if( trackIsClick[candidate*2] !== trackIsClick[candidate*2+1] )\n    {\n      const clickTrack = trackIsClick[candidate*2] ? relevantTracks[candidate*2] : relevantTracks[candidate*2+1];\n      const hitTrack = trackIsClick[candidate*2] ? relevantTracks[candidate*2+1] : relevantTracks[candidate*2];\n      const instrumentIsTom = hitTrack.name.includes(\"tom\");\n      let rawInstrumentName = instrumentIsTom ? \"Tom\" : \"Bass\";\n      let instrumentName = \"\"\n      if( instrumentIsTom )\n      {\n        instrumentName = rawInstrumentName + ( (tomIndex >= 2) ? \" \" + tomIndex.toString() : \"\" );\n        tomIndex = tomIndex + 1;\n      }\n      else\n      {\n        instrumentName = rawInstrumentName + ( (bassIndex >= 2) ? \" \" + bassIndex.toString() : \"\" );\n        bassIndex = bassIndex + 1;\n      }\n      let mapping = {};\n      mapping[hitTrack.id.toString()] = symbolConfig[rawInstrumentName];\n      mapping[clickTrack.id.toString()] = symbolConfig[\"Click\"];\n      collated.push([instrumentName, mapping] );  \n    }\n  }\n\n  // If there's a remainder instrument and there's no click\n  if( ((relevantTracks.length % 2 ) !== 0) && !trackIsClick[ relevantTracks.length - 1 ] )\n  {\n    const lastTrack = relevantTracks[relevantTracks.length - 1];\n    const instrumentIsTom = lastTrack.name.includes(\"tom\");\n    let rawInstrumentName = instrumentIsTom ? \"Tom\" : \"Bass\";\n    let instrumentName = \"\"\n    if( instrumentIsTom )\n    {\n      instrumentName = rawInstrumentName + ( (tomIndex >= 2) ? \" \" + tomIndex.toString() : \"\" );\n      tomIndex = tomIndex + 1;\n    }\n    else\n    {\n      instrumentName = rawInstrumentName + ( (bassIndex >= 2) ? \" \" + bassIndex.toString() : \"\" );\n      bassIndex = bassIndex + 1;\n    }\n    let mapping = {};\n    mapping[lastTrack.id.toString()] = symbolConfig[rawInstrumentName];\n    collated.push([instrumentName, mapping] );  \n  }\n  return collated;\n}\n\nfunction defaultSymbolForSingleInstrument(symbolConfig, name)\n{\n  // we expect these keys\n  /*\n    \"Djembe Slap\" : \"S\",\n    \"Djembe Tone\" : \"t\",\n    \"Djembe Bass\" : \"O\",\n    \"Snare Ghost\" : \"-\",\n    \"Snare Accent\" : \"X\",\n    \"Shaker Ghost\" : \"x\",\n    \"Shaker Accent\" : \"X\",\n    \"Click\" : \"X\",\n    \"Bass\" : \"O\",\n    \"Tom\" : \"O\",\n    \"Default\" : \"X\"\n  */\n  const lowerName = name.toLowerCase();\n  if( lowerName.includes(\"click\") || lowerName.includes(\"stick\") )\n  {\n    return symbolConfig[\"Click\"];\n  }  \n  else if( lowerName.includes(\"bass\") || lowerName.includes(\"kick\") )\n  {\n    return symbolConfig[\"Bass\"]\n  }\n  else if( lowerName.includes(\"snare\") )\n  {\n    return symbolConfig[\"Snare Accent\"];\n  }\n  else if( lowerName.includes(\"shaker\") )\n  {\n    return symbolConfig[\"Shaker\"];\n  }\n  else if( lowerName.includes(\"tom\") )\n  {\n    return symbolConfig[\"Tom\"];\n  }\n  else if( lowerName.includes(\"djembe\") )\n  {\n    if( lowerName.includes(\"slap\") )\n    {\n      return symbolConfig[\"Djembe Slap\"];\n    }\n    else if( lowerName.includes(\"tone\") )\n    {\n      return symbolConfig[\"Djembe Tone\"];\n    }\n    else\n    {\n      return symbolConfig[\"Djembe Bass\"];\n    }\n  }\n  return symbolConfig[\"Default\"];\n}\n\nfunction figureInstruments(instrumentsRaw, symbolConfig, patterns)\n{\n  let output = [];\n  output = output.concat( figureClickyInstruments( instrumentsRaw, symbolConfig, patterns ) );\n  output = output.concat( figureDjembes( instrumentsRaw, symbolConfig ) );\n  output = output.concat( figureSnares( instrumentsRaw, symbolConfig ) );\n  output = output.concat( figureShakers( instrumentsRaw, symbolConfig ) );\n\n  // we ignore track used by multiple instruments\n\n  // but attempt to cover \"instrument not recognised anywhere\"\n\n  const worthwhileInstruments = activeInstruments(patterns);\n\n  for(const inst of instrumentsRaw)\n  {\n    if( !worthwhileInstruments.has(inst.id) )\n    {\n      continue;\n    }\n    let instrumentUsed = false;\n    for( const op of output)\n    {\n      if( inst.id.toString() in op[1] ) \n      {\n        instrumentUsed = true;\n      }\n    }\n    if(instrumentUsed === false)\n    {\n      let mapping = {};\n      mapping[ inst.id.toString() ] = defaultSymbolForSingleInstrument( symbolConfig, inst.name );\n      output.push( [inst.name, mapping] );\n    }\n  }\n  \n  return output; \n}\n\nexport { activeInstrumentation, DEFAULT_INSTRUMENT_SYMBOLS, figureClickyInstruments, figureDjembes, figureShakers, figureSnares, figureInstruments };","import React from 'react';\nimport { makeStyles } from '@material-ui/core/styles';\nimport FormControlLabel from '@material-ui/core/FormControlLabel';\nimport Checkbox from '@material-ui/core/Checkbox';\n\n// table\nimport Table from '@material-ui/core/Table';\nimport TableBody from '@material-ui/core/TableBody';\nimport TableCell from '@material-ui/core/TableCell';\nimport TableContainer from '@material-ui/core/TableContainer';\nimport TableHead from '@material-ui/core/TableHead';\nimport TableRow from '@material-ui/core/TableRow';\n\nimport AddBoxIcon from '@material-ui/icons/AddBox';\nimport EditIcon from '@material-ui/icons/Edit';\nimport Button from '@material-ui/core/Button';\nimport IconButton from '@material-ui/core/IconButton';\nimport ClearIcon from '@material-ui/icons/Clear';\n\nimport TextField from '@material-ui/core/TextField';\nimport Dialog from '@material-ui/core/Dialog';\nimport DialogActions from '@material-ui/core/DialogActions';\nimport DialogContent from '@material-ui/core/DialogContent';\nimport DialogContentText from '@material-ui/core/DialogContentText';\nimport DialogTitle from '@material-ui/core/DialogTitle';\nimport { withStyles } from '@material-ui/core/styles';\nimport Typography from '@material-ui/core/Typography';\n\nconst useStyles = makeStyles((theme) => ({\n  root: {\n    display: 'flex',\n  }\n}));\n\nconst ThinFormControlLabel = withStyles({\n  root: {\n    marginLeft: 0,\n    marginRight: 0\n  }\n})(FormControlLabel);\n\nconst InlinableIconButton = withStyles({\n  root: {\n    padding: 2\n  }\n})(IconButton);\n\nconst CenterTableCell = withStyles({\n  root: {\n    textAlign: \"center\"\n  }\n})(TableCell);\n\nfunction InstrumentConfig(props) {\n  const classes = useStyles();\n\n  const handleChange = (x,y, event) => {\n    const instrumentID = props.instrumentIndex[x].id;\n    const oldInstrumentIndex = props.instruments.findIndex( instrument => instrumentID in instrument[1]);\n    const dstInstrumentIndex = y;\n    if( oldInstrumentIndex === dstInstrumentIndex )\n    {\n      return;\n    }\n    const oldInstrument = props.instruments[oldInstrumentIndex];\n    let replacedSrcInstrument = [\n      \"\",\n      {}\n    ];\n    if( oldInstrument != null )\n    {\n      replacedSrcInstrument[0] = oldInstrument[0];\n      for( const key of Object.keys(oldInstrument[1]) )\n      {\n        if( key !== instrumentID.toString() )\n        {\n          replacedSrcInstrument[1][key] = oldInstrument[1][key];\n        }\n      }\n    }\n    let dstInstrument = [\n      props.instruments[dstInstrumentIndex][0],\n      Object.assign({}, props.instruments[dstInstrumentIndex][1] )\n    ];\n    if(oldInstrument != null )\n    {\n      dstInstrument[1][instrumentID.toString()] = oldInstrument[1][instrumentID];\n    }\n    else\n    {\n      dstInstrument[1][instrumentID.toString()] = \"X\";\n    }\n\n    let replacedInstruments = [];\n\n    for(let instrumentIndex = 0; instrumentIndex < props.instruments.length; ++instrumentIndex)\n    {\n      if( instrumentIndex === oldInstrumentIndex )\n      {\n        replacedInstruments.push( replacedSrcInstrument );\n      }\n      else if( instrumentIndex === dstInstrumentIndex )\n      {\n        replacedInstruments.push( dstInstrument )\n      }\n      else\n      {\n        replacedInstruments.push( props.instruments[instrumentIndex] );\n      }\n    }\n    props.onChange(replacedInstruments);\n  };\n\n  const removeInstrument = (y) => \n  {\n    let replacedInstruments = props.instruments.slice(0,y).concat(props.instruments.slice(y+1));\n    props.onChange(replacedInstruments);\n  };\n\n  const [renamingInstrument, setRenamingInstrument] = React.useState(-1);\n  let [nameState, setNameState] = React.useState(\"\");\n\n  const createCell = (x,y) =>\n  {\n      return ( \n        <TableCell\n          align=\"center\"\n          key={\"instrumentPanel-cell-\" + y.toString() + \"-\" + x.toString()}\n        >\n        <ThinFormControlLabel\n          control={<Checkbox checked={props.instrumentMask[x] === y} onChange={(e) => handleChange(x,y,e)} name={x + \",\" + y.toString()} />}\n        />\n        </TableCell>\n      );\n  }\n\n  const createMatchingRow = (y) =>\n  {\n    return (\n      <TableRow key={\"instrumentPanel-row-\" + y.toString()}>\n        <TableCell component=\"th\" scope=\"row\" key={\"instrumentPanel-row-\" + y.toString() + \"-name\"}> \n          <Typography>{props.instruments[y][0]}</Typography>\n          <InlinableIconButton onClick={(e)=>setRenamingInstrument(y)}><EditIcon fontSize=\"small\"/></InlinableIconButton>\n          <InlinableIconButton onClick={(e)=>{removeInstrument(y);}}><ClearIcon fontSize=\"small\"/></InlinableIconButton>\n        </TableCell>\n        {[...Array(props.instrumentIndex.length).keys()].map(x=>createCell(x,y))}\n      </TableRow>\n    );\n  };\n\n  const createEditRow = () =>\n  {\n    return (\n      <TableRow key={\"instrumentPanel-row-edit\"}>\n        <TableCell component=\"th\" scope=\"row\" key={\"instrumentPanel-row-edit-cell\"}>\n          <IconButton onClick={(e)=>setRenamingInstrument(props.instruments.length)} aria-label=\"add\">\n            <AddBoxIcon/>\n          </IconButton>\n        </TableCell>\n      </TableRow>\n    );\n  };\n\n  const renameInstrument = (e)  => \n  {\n    const instrumentName = nameState.trim();\n    if( instrumentName.length > 0 )\n    {\n      if( renamingInstrument === props.instruments.length )\n      {\n        const extraInstrument = [ instrumentName, {} ];\n        let replacedInstruments = Array.from( props.instruments );\n        replacedInstruments.push(extraInstrument);\n        props.onChange(replacedInstruments);\n      }\n      else\n      {\n        let replacedInstruments = Array.from( props.instruments );\n        replacedInstruments[renamingInstrument][0] = instrumentName;\n        props.onChange(replacedInstruments);\n      }\n    }\n    // we just ignore empty string\n    setRenamingInstrument(-1);\n    setNameState(\"\");\n  };\n\n  // todo: The text field is very slow\n  // that could be because the dialog and the table content are all one component\n  // I should try and fix that first\n  // otherwise, it's just that shoving react in the middle is too slow\n\n  const [editSymbol, setEditSymbol] = React.useState(-1);\n  let [editSymbolState, setEditSymbolState] = React.useState(\"\");\n\n  const startEditingSymbol = (x) =>\n  {\n    const instrumentID = props.instrumentIndex[x].id;\n    const instrumentIndex = props.instruments.findIndex( instrument => instrumentID in instrument[1]);\n    const currentSymbol = props.instruments[instrumentIndex][1][instrumentID];\n    setEditSymbolState(currentSymbol);\n    setEditSymbol(x);\n  };\n\n  const changeSymbol = (e) =>\n  {\n    const updatedSymbol = editSymbolState;\n    if(updatedSymbol.length===1)\n    {\n      const instrumentID = props.instrumentIndex[editSymbol].id;\n      const instrumentIndex = props.instruments.findIndex( instrument => instrumentID in instrument[1]);\n      let replacedInstruments = Array.from(props.instruments);\n      replacedInstruments[instrumentIndex][1][instrumentID] = editSymbolState;\n      props.onChange(replacedInstruments);\n    }\n    else\n    {\n      // todo: prettier error communication?\n      alert(\n        \"You selected an invalid symbol \\\"\" + updatedSymbol + \"\\\".\\n\" + \n        \"Symbols must be precisely 1 character.\"\n      );\n    }\n    setEditSymbol(-1);\n  };\n\n  return (\n    <React.Fragment>\n      <Dialog open={renamingInstrument >= 0} onClose={(e)=>setRenamingInstrument(-1)} aria-labelledby=\"form-dialog-title\">\n        <DialogTitle id=\"form-dialog-title\"></DialogTitle>\n        <DialogContent>\n          <DialogContentText>\n            Enter instrument name\n          </DialogContentText>\n          <TextField\n            autoFocus\n            margin=\"dense\"\n            id=\"name\"\n            fullWidth\n            value={nameState}\n            onChange={(e)=>setNameState(e.target.value)}\n          />\n        </DialogContent>\n        <DialogActions>\n          <Button onClick={(e)=>setRenamingInstrument(-1)} color=\"primary\">\n            Cancel\n          </Button>\n          <Button onClick={renameInstrument} color=\"primary\">\n            Confirm\n          </Button>\n        </DialogActions>\n      </Dialog>\n      <Dialog open={editSymbol >= 0} onClose={(e)=>setEditSymbol(-1)} aria-labelledby=\"form-dialog-title\">\n        <DialogTitle id=\"form-dialog-title\"></DialogTitle>\n        <DialogContent>\n          <DialogContentText>\n            Enter notation symbol\n          </DialogContentText>\n          <TextField\n            autoFocus\n            margin=\"dense\"\n            id=\"name\"\n            fullWidth\n            value={editSymbolState}\n            onChange={(e)=>setEditSymbolState(e.target.value)}\n          />\n        </DialogContent>\n        <DialogActions>\n          <Button onClick={(e)=>setEditSymbol(-1)} color=\"primary\">\n            Cancel\n          </Button>\n          <Button onClick={changeSymbol} color=\"primary\">\n            Confirm\n          </Button>\n        </DialogActions>\n      </Dialog>\n      <TableContainer>\n        <Table className={classes.table} aria-label=\"simple table\">\n          <TableHead>\n            <TableRow key={\"instrumentPanel-row-header\"}>\n              <TableCell key={\"instrumentPanel-row-instrument\"}> Instrument </TableCell>\n              {[...Array(props.instrumentIndex.length).keys()].map(x=><CenterTableCell key={\"instrumentPanel-row-header-cell-\" + x.toString()}><Typography>{props.instrumentIndex[x].name}</Typography><InlinableIconButton onClick={(e)=>startEditingSymbol(x)} ><EditIcon fontSize=\"small\"/></InlinableIconButton></CenterTableCell>)}\n            </TableRow>\n          </TableHead>\n          <TableBody>\n\n            {[...Array(props.instruments.length).keys()].map(y=>createMatchingRow(y))}\n            {createEditRow()}\n          </TableBody>\n        </Table>\n      </TableContainer>\n    </React.Fragment>\n  );\n}\n\nfunction createInstrumentMask(instrumentIndex, instruments)\n{\n  let instrumentMask = Array(instrumentIndex.length);\n  for( let baseInstrumentIndex = 0; baseInstrumentIndex < instrumentIndex.length; ++baseInstrumentIndex )\n  {\n    const baseInstrumentId = instrumentIndex[baseInstrumentIndex].id;\n    for( let targetInstrumentIndex = 0; targetInstrumentIndex < instruments.length; ++targetInstrumentIndex)\n    {\n      const target = instruments[targetInstrumentIndex];\n      if(baseInstrumentId.toString() in target[1])\n      {\n        instrumentMask[baseInstrumentIndex] = targetInstrumentIndex;\n      }\n    }\n  }\n  return instrumentMask;\n}\n\nexport { createInstrumentMask, InstrumentConfig };","import { calculateResolution } from \"./utilities\"\n\n// stolen from https://studymaths.co.uk/topics/findingHCFWithJavaScript.php\nfunction findHCF(x, y) {\n\n   // If the input numbers are less than 1 return an error message.\n   if (x < 1 || y < 1) {\n    throw new Error(\"x<1 || y<1\");\n      // return \"Please enter values greater than zero.\";\n   }\n\n   // Now apply Euclid's algorithm to the two numbers.\n   while (Math.max(x, y) % Math.min(x, y) !== 0) {\n      if (x > y) {\n         x %= y;\n      }\n      else {\n         y %= x;\n      }\n   }\n   \n   // When the while loop finishes the minimum of x and y is the HCF.\n   return Math.min(x, y);\n}\n\nclass track\n{\n  \n  constructor(patternArray, resolution)\n  {\n    if(patternArray.length === 0)\n    {\n      throw new Error(\"patternArray must not be zero length\");\n    }\n    this.rep = patternArray;\n    this.resolution = resolution;\n  }\n\n  length()\n  {\n    return this.rep.length * this.resolution;\n  }\n\n  empty()\n  {\n    return this.rep.reduce( (a,b) => ( a + b ) ) === 0;\n  }\n\n  _sumOverlapsOfArrays(a,b)\n  {\n    let count = 0;\n    for( let i = 0; i < a.length; ++i)\n    {\n      if(a[i] && b[i])\n      {\n        count++;\n      }\n    }\n    return count;\n  }\n\n  countOverlaps(other)\n  {\n    if( this.resolution === other.resolution )\n    {\n      return this._sumOverlapsOfArrays( this.rep, other.rep );\n    }\n    else\n    {\n      const hcf = findHCF(this.resolution, other.resolution);\n      const a = this.formatResolution( hcf );\n      const b = other.formatResolution( hcf );\n      return this._sumOverlapsOfArrays( a.rep, b.rep );\n    }\n  }\n\n  aggregate(other)\n  {\n\n    if( this.resolution === other.resolution )\n    {\n      // when we aggregate, we specifically\n      const length = Math.max( this.rep.length, other.rep.length );\n      const pat = new Array(length).fill(0);\n      for(let index = 0; index < pat.length; ++index)\n      {\n        pat[index] = ( ( index < this.rep.length ) ? this.rep[index] : 0 )\n                  || ( ( index < other.rep.length ) ? other.rep[index] : 0 );\n      }\n      return new track( pat, this.resolution );\n    }\n    else\n    {\n      const hcf = findHCF(this.resolution, other.resolution);\n      const a = this.formatResolution( hcf );\n      const b = other.formatResolution( hcf );\n      return a.aggregate(b);\n    }\n  }\n\n  static representPoints(points, resolution, size)\n  {\n    if( size <= 0 )\n    {\n      throw new Error(\"size must be greater than zero\");\n    }\n    if( size < resolution || (size % resolution) !== 0)\n    {\n      throw new Error(\"resolution must be less than size and divide it evenly\");\n    }\n    let s = new Array(size / resolution).fill(0);\n    for( const p of points )\n    {\n      if( (p % resolution) !== 0)\n      {\n        throw new Error(\"Failed to represent point \" + p.toString() + \" at resolution \" + resolution.toString());\n      }\n      if (p >= size)\n      {\n        throw new Error(\"Failed to represent point \" + p.toString() + \" for invalid specified size \" + size.toString());\n      }\n      const arrayIndex = p / resolution;\n      s[arrayIndex] = 1;\n    }\n    return s;\n  }\n\n  format(formatResolution)\n  {\n    // formatResolution must cleanly divide for every hit & the length of the pattern\n\n    const totalLength = (this.resolution * this.rep.length);\n    const points = this.toPoints();\n    const rep = track.representPoints(points, formatResolution, totalLength);\n    if(!rep)\n    {\n      return null;\n    }\n    return new track(\n      rep,\n      formatResolution\n    );\n  }\n\n  toPoints()\n  {\n    let points = [];\n    for( const arrayIndex of Array(this.rep.length).keys() )\n    {\n      const indicator = this.rep[arrayIndex];\n      if(indicator)\n      {\n        points.push( this.resolution * arrayIndex )\n      }\n    }\n    return points;\n  }\n\n  static fromPositions(positions, size, resolution = null)\n  {\n    const resolutionToUse = resolution ?? calculateResolution( positions, size );\n    return new track( \n      track.representPoints(positions, resolutionToUse, size), \n      resolutionToUse\n    );\n  }\n}\n\nexport default track;","// utilities.js\n\nfunction calculateResolution(positions, size)\n{\n  // hydrogen treats 48 as a beat\n  const basesToTry = [\n    48, // beat\n    24, // 1/2 beat\n    16, // 1/3 beat\n    12, // 1/4\n    8, // 1/6 \n    6, // 1/8\n    4, // 1/12\n    3, // 1/16\n    2, // 1/24\n    1 // 1/48\n  ];\n\n  // note that, fundamentally the size of the pattern is a \"keypoint\"\n  // that needs to be properly recorded by the resolution\n  const implicitPositions = positions.concat( [size] );\n\n  for( const b of basesToTry )\n  {\n    let allNotesPass = true;\n    for( const p of implicitPositions )\n    {\n      if( (p % b) !== 0 )\n      {\n        allNotesPass = false;\n        break;\n      }\n    }\n    if(allNotesPass)\n    {\n      return b;\n    }\n  }\n  throw new Error(\"Failed to predict base\");\n}\n\nexport { calculateResolution };"],"sourceRoot":""}